var documenterSearchIndex = {"docs":
[{"location":"api/#Core-functions","page":"API","title":"Core functions","text":"","category":"section"},{"location":"api/#Average-marginal-effects-(AME)","page":"API","title":"Average marginal effects (AME)","text":"","category":"section"},{"location":"api/#Margins.margins","page":"API","title":"Margins.margins","text":"margins(\n  model,\n  vars::Union{Symbol, AbstractVector{Symbol}},\n  df::AbstractDataFrame;\n  vcov::Function = StatsBase.vcov,\n  repvals::Dict{Symbol, Vector} = Dict{Symbol, Vector}()\n) -> MarginsResult\n\nCompute average marginal effects (AME) for one or more predictors.\n\nArguments\n\nmodel : a fitted GLM/GLMM/LinearModel/MixedModel\nvars  : either a single Symbol or a Vector{Symbol} of predictors\ndf    : the DataFrame used to fit the model (required)\nvcov  : function to extract the fixed-effects covariance matrix            (defaults to StatsBase.vcov)\nrepvals: a Dict{Symbol, Vector} of representative values for MERs\n\nReturns\n\nAn MarginsResult containing AMEs, standard errors, and gradients for each var.\n\n\n\n\n\n","category":"function"},{"location":"api/#Margins.contrast","page":"API","title":"Margins.contrast","text":"contrast(a, b; var, vcov=nothing) -> ContrastResult\n\nCompare the AME of var between two MarginsResult objects. If each AME is a dictionary (grid), perform the comparison at every key. Otherwise, compare the single scalar AMEs.\n\nKeyword Arguments\n\nvar::Symbol: Name of the predictor to contrast.\nvcov: Optional covariance matrix of model coefficients (defaults to independent).\n\n\n\n\n\ncontrast(a; var1, var2, vcov=nothing) -> ContrastResult\n\nContrast the AME between two different predictors in a single MarginsResult. Handles both scalar and grid-based AMEs when both variables share the same keys.\n\nKeyword Arguments\n\nvar1, var2: Predictor names to compare.\nvcov: Optional covariance matrix of model coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Margins.contrast_levels","page":"API","title":"Margins.contrast_levels","text":"contrast_levels(a, var; comparisons=:all, vcov=nothing) -> ContrastResult\n\nCompute pairwise contrasts of AMEs across levels (or representative values) of var.\n\nKeyword Arguments\n\ncomparisons: :all for every i<j, or :adjacent for adjacent pairs.\nvcov: Optional covariance matrix of model coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Average-predictions-at-the-mean-(APM)","page":"API","title":"Average predictions at the mean (APM)","text":"","category":"section"},{"location":"api/#Margins.effects2!","page":"API","title":"Margins.effects2!","text":"effects2!(\n    reference_grid::DataFrame,\n    model::RegressionModel,\n    df::AbstractDataFrame;\n    eff_col    = nothing,\n    err_col    = :err,\n    typical    = mean,\n    invlink    = AutoInvLink(),\n    vcov_func  = vcov,\n    filtervars = true\n)\n\nCompute “effects-at-the-mean” (or other typical values) predictions for each row of a reference grid, given a fitted RegressionModel (e.g. from GLM.jl or MixedModels.jl).\n\nArguments\n\nreference_grid::DataFrame   A DataFrame whose columns specify the focal predictor values at which you want predictions.\nmodel::RegressionModel   A fitted model supporting coef, fixef/coef, formula, and a variance-covariance extractor.\ndf::AbstractDataFrame   The original data frame used to fit model; used to compute “typical” values of any predictors not already in reference_grid.\n\nKeyword Arguments\n\neff_col::Union{Symbol,Nothing}   Name of the column to write the predicted responses (on the response scale).   If nothing, defaults to the model's response variable name.\nerr_col::Symbol   Name of the column to write the standard error of each prediction (on the response scale). Default :err.\ntypical::Function   Function to compute “typical” values (e.g. mean, median) for covariates not present in reference_grid. For categorical predictors, mean uses level proportions.\ninvlink::Union{Function,AutoInvLink}   The inverse-link transformation to apply to the linear predictor (e.g. identity, logistic),  or the special AutoInvLink() which picks the correct back-transformation from model.\nvcov_func::Function   Function to extract the coefficient variance-covariance matrix (e.g. StatsBase.vcov).\nfiltervars::Bool   If true, after computing predictions will drop all columns except: the original grid columns plus the two new output columns.\n\nReturns\n\nA mutated (and possibly filtered) copy of reference_grid with two added columns:\n\nThe back-transformed predictions (column name given by eff_col or the default).  \nTheir standard errors (column named by err_col).\n\nDetails\n\nRecords the original grid columns.  \nFills in any missing predictors via typicals!.  \nBuilds the fixed-effects design matrix from model.  \nExtracts coefficients (fixef(model)) and their covariance (vcov_func(model)).  \nComputes the linear predictor η = Xβ and its SE = √diag(X V X′).  \nApplies the inverse-link via _difference_method! (for numeric stability when needed).  \nWrites η and SE into reference_grid.  \nIf filtervars is true, drops back to only the original grid plus the two new columns.\n\nExample\n\n```julia using DataFrames, CategoricalArrays, GLM\n\nSimulate data\n\ndf = DataFrame(     y = randn(100) .+ 2 .* (rand(100) .> 0.5),     x = rand(100),     g = categorical(rand([\"A\",\"B\"], 100)) )\n\nFit a linear model\n\nm = lm(@formula(y ~ x + g), df)\n\nBuild a reference grid over x\n\ngrid = DataFrame(x = range(extrema(df.x)..., 5))\n\nCompute effects at the mean of g\n\neffects2!(grid, m, df; effcol=:pred, errcol=:se_pred)\n\ngrid now contains :pred and :se_pred columns\n\n\n\n\n\neffects2!(\n    reference_grid::DataFrame,\n    model::RegressionModel;\n    eff_col = nothing,\n    err_col = :err,\n    typical = mean,\n    invlink = identity,\n    vcov = StatsBase.vcov\n)\n\nCompute adjusted (\"effects at the mean\") predictions for each row of a reference grid,  using a fitted GLM (or other RegressionModel).\n\nArguments\n\nreference_grid::DataFrame A DataFrame whose columns specify the focal predictor values at which you want predictions.\nmodel::RegressionModel A fitted model returned by GLM.jl (e.g. lm or glm), or any object supporting coef, formula, and StatsBase.vcov.\n\nKeyword Arguments\n\neff_col::Union{Symbol,Nothing}   Name of the column to store the predicted (transformed) responses.   If nothing, a default name based on the model’s response variable is used.\nerr_col::Symbol   Name of the column to store the standard error of each prediction. Default :err.\ntypical::Function   Function to compute “typical” values (e.g. mean, median) for covariates not present in reference_grid. For categorical variables, level-proportions are computed when typical==mean.\ninvlink::Function   Inverse link function for back-transforming the linear predictor (e.g. identity, logistic).   Default is identity (no transformation).\nvcov::Function   Function to extract the coefficient variance-covariance matrix. Default is StatsBase.vcov.\n\nReturns\n\nA mutated copy of reference_grid with two new columns:\n\nThe adjusted predictions on the response scale (column named by eff_col or a default).  \nTheir standard errors (column named by err_col).\n\nExample\n\n```julia using DataFrames, CategoricalArrays, GLM\n\nSimulate data\n\ndf = DataFrame(     y = randn(100) .+ 2 .* (rand(100) .> 0.5),     x = rand(100),     g = categorical(rand([\"A\",\"B\"], 100)) )\n\nFit a linear model\n\nm = lm(@formula(y ~ x + g), df)\n\nBuild a reference grid over x\n\ngrid = DataFrame(x = range(extrema(df.x)..., length=5))\n\nCompute effects at the mean of g\n\neffects2!(grid, m; effcol=:pred, errcol=:se_pred)\n\ngrid now contains :pred and :se_pred columns\n\n\n\n\n\n","category":"function"},{"location":"api/#Margins.effectsΔyΔx","page":"API","title":"Margins.effectsΔyΔx","text":"    effectsΔyΔx(\n        reference_grid::AbstractDataFrame, model::RegressionModel;\n        eff_col=nothing, err_col=:err,\n        typical=mean, invlink=identity, vcov=StatsBase.vcov,\n        digits = 3\n    )\n\nDescription\n\nCalculate the discrete marginal effect on a two-row dataframe that represents a reference grid.\n\nN.B., This appears to be the correct way to calculate contrasts (as opposed to empairs).\nAs it stands, this is like empairs() but correctly adjusts the standard error\n\n(it doesn't assume independence).\n\n\n\n\n\n","category":"function"},{"location":"#Margins.jl-Documentation","page":"Introduction","title":"Margins.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This Julia package provides a suite of functions to compute marginal effects and related contrasts for predictors in GLM/GLMM models:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Adjusted predictions at the mean (APM) and marginal effects at the mean (MEM)\nAverage Marginal Effects (AMEs) and marginal effects at representative values (MERS)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As it stands, marginal effect calculations, and AME calculations in particular, are a huge gap in statistical modeling in Julia that really limits the ways researchers can take advantage of packages like MixedModels.jl.[1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: Furthermore, other packages that seek to convert models estimated in Julia into R objects (which can then be used with the mature modeling ecosystem) ultimately feed into another two-language problem (though this strategy may be the best current option in many situations).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that this package is similar in spirit to Effects.jl, and borrows directly from it for the APM calculations. Ultimately, the design of this package refers heavily to Stata's \"margins\" commands.","category":"page"},{"location":"#Resources","page":"Introduction","title":"Resources","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Williams, R. (2012). Using the margins command to estimate and interpret adjusted predictions and marginal effects. The Stata Journal, 12(2), 308–331. https://www.stata-journal.com/article.html?article=st0260","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Williams, R. (2021, January 25). Using the margins command to estimate and interpret adjusted predictions and marginal effects [PDF]. University of Notre Dame. https://www3.nd.edu/~rwilliam/stats/Margins01.pdf","category":"page"}]
}
