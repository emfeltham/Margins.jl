<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Population Scenarios · Margins.jl</title><meta name="title" content="Population Scenarios · Margins.jl"/><meta property="og:title" content="Population Scenarios · Margins.jl"/><meta property="twitter:title" content="Population Scenarios · Margins.jl"/><meta name="description" content="Documentation for Margins.jl."/><meta property="og:description" content="Documentation for Margins.jl."/><meta property="twitter:description" content="Documentation for Margins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Margins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Margins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../computational_architecture/">Computational Architecture</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../reference_grids/">Reference Grids</a></li><li><a class="tocitem" href="../profile_margins/">Profile Analysis</a></li><li class="is-active"><a class="tocitem" href>Population Scenarios</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Conceptual-Model"><span>Conceptual Model</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Application-examples"><span>Application examples</span></a></li><li><a class="tocitem" href="#Common-Patterns-and-Idioms"><span>Common Patterns and Idioms</span></a></li><li><a class="tocitem" href="#Architecture-Overview"><span>Architecture Overview</span></a></li><li><a class="tocitem" href="#Computation-Details"><span>Computation Details</span></a></li><li><a class="tocitem" href="#Grouping-(groups-...)"><span>Grouping (groups = ...)</span></a></li><li><a class="tocitem" href="#Weights"><span>Weights</span></a></li><li><a class="tocitem" href="#Column-Naming-and-Ordering"><span>Column Naming and Ordering</span></a></li><li><a class="tocitem" href="#Programmatic-Identification"><span>Programmatic Identification</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li><li><a class="tocitem" href="#Technical-Implementation-Notes"><span>Technical Implementation Notes</span></a></li><li><a class="tocitem" href="#Relationship-to-Profile-Analysis"><span>Relationship to Profile Analysis</span></a></li><li><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></li></ul></li><li><a class="tocitem" href="../second_differences/">Second Differences</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../grouping/">Population Grouping</a></li><li><a class="tocitem" href="../backend_selection/">Backend Selection</a></li><li><a class="tocitem" href="../performance/">Performance Guide</a></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><a class="tocitem" href="../stata_migration/">Migration Guide</a></li><li><a class="tocitem" href="../comparison/">Package Comparison</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Population Scenarios</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Population Scenarios</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl/" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Population-Scenarios-(Stata-at())"><a class="docs-heading-anchor" href="#Population-Scenarios-(Stata-at())">Population Scenarios (Stata <code>at()</code>)</a><a id="Population-Scenarios-(Stata-at())-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Scenarios-(Stata-at())" title="Permalink"></a></h1><p><em>Counterfactual analysis for population-averaged effects and predictions</em></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Population scenarios enable <strong>&quot;what if&quot;</strong> analysis by computing marginal effects or predictions under counterfactual covariate values. This is analogous to Stata&#39;s <code>at()</code> option but with population averaging semantics.</p><p><strong>Key Concept:</strong> Scenarios modify variable values for the <em>entire population</em> while computing population-averaged quantities (AME or AAP), allowing you to answer questions like:</p><ul><li>&quot;What would the average treatment effect be if everyone were college-educated?&quot;</li><li>&quot;How do predicted outcomes differ between policy scenarios?&quot;</li><li>&quot;What&#39;s the effect of X when intervention Y is set to specific levels?&quot;</li></ul><h3 id="Scope-and-Design"><a class="docs-heading-anchor" href="#Scope-and-Design">Scope and Design</a><a id="Scope-and-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Scope-and-Design" title="Permalink"></a></h3><ul><li><strong>Supported in:</strong> <code>population_margins()</code> only (population-averaged analysis)</li><li><strong>Not supported in:</strong> <code>profile_margins()</code> (use reference grids like <code>cartesian_grid()</code> instead)</li><li><strong>Design priorities:</strong> Statistical correctness (proper delta-method SEs with full covariance matrix Σ) and zero-allocation performance</li></ul><h2 id="Conceptual-Model"><a class="docs-heading-anchor" href="#Conceptual-Model">Conceptual Model</a><a id="Conceptual-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Conceptual-Model" title="Permalink"></a></h2><p>Given a fitted model and a dataset, a scenario specifies a set of variable overrides to evaluate counterfactuals. For population analysis, we:</p><ul><li>Keep the original rows and any grouping subset (if <code>groups</code> are used).</li><li>Evaluate effects or predictions at the counterfactual covariates by overriding row values during evaluation (no data mutation).</li><li>Average over the selected rows (weighted or unweighted), compute the averaged parameter gradient, and apply the delta method with the full covariance matrix.</li></ul><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><h3 id="Single-Variable-Scenarios"><a class="docs-heading-anchor" href="#Single-Variable-Scenarios">Single-Variable Scenarios</a><a id="Single-Variable-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Variable-Scenarios" title="Permalink"></a></h3><p>Evaluate effects or predictions at different values of one variable:</p><pre><code class="language-julia hljs"># Compare predictions under treatment vs control
result = population_margins(model, data;
    type=:predictions,
    scenarios=(treatment=[0, 1])
)
# Result: 2 rows showing AAP when treatment=0 and treatment=1

# Effect of X under different policy environments
result = population_margins(model, data;
    type=:effects,
    vars=[:x],
    scenarios=(policy=[&quot;baseline&quot;, &quot;reform&quot;])
)
# Result: 2 rows showing AME of x under each policy scenario</code></pre><h3 id="Multi-Variable-Scenarios-(Cartesian-Product)"><a class="docs-heading-anchor" href="#Multi-Variable-Scenarios-(Cartesian-Product)">Multi-Variable Scenarios (Cartesian Product)</a><a id="Multi-Variable-Scenarios-(Cartesian-Product)-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Variable-Scenarios-(Cartesian-Product)" title="Permalink"></a></h3><p>Multiple scenario variables create a Cartesian product of all combinations:</p><pre><code class="language-julia hljs"># 2×3 = 6 scenarios
result = population_margins(model, data;
    type=:predictions,
    scenarios=(
        treatment=[0, 1],
        policy=[&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;]
    )
)
# Result: 6 rows for all (treatment, policy) combinations

# 2×2×3 = 12 scenarios
result = population_margins(model, data;
    type=:effects,
    vars=[:income],
    scenarios=(
        education=[&quot;HS&quot;, &quot;College&quot;],
        region=[&quot;Urban&quot;, &quot;Rural&quot;],
        tax_rate=[0.15, 0.25, 0.35]
    )
)
# Result: 12 rows showing income effect under all scenario combinations</code></pre><h3 id="Scenarios-with-Grouping"><a class="docs-heading-anchor" href="#Scenarios-with-Grouping">Scenarios with Grouping</a><a id="Scenarios-with-Grouping-1"></a><a class="docs-heading-anchor-permalink" href="#Scenarios-with-Grouping" title="Permalink"></a></h3><p>Combine scenarios with grouping for within-group counterfactual analysis:</p><pre><code class="language-julia hljs"># Effects of x within gender groups, under different policy scenarios
result = population_margins(model, data;
    type=:effects,
    vars=[:x],
    groups=:gender,
    scenarios=(policy=[&quot;none&quot;, &quot;pilot&quot;, &quot;full&quot;])
)
# Result: 6 rows (2 genders × 3 policies)

# Complex: education×region groups × treatment scenarios
result = population_margins(model, data;
    type=:predictions,
    groups=[:education, :region],
    scenarios=(treatment=[0, 1], dosage=[1, 2, 3])
)
# Result: (# education levels × # regions × 2 treatments × 3 dosages) rows</code></pre><h2 id="Application-examples"><a class="docs-heading-anchor" href="#Application-examples">Application examples</a><a id="Application-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Application-examples" title="Permalink"></a></h2><h3 id="Policy-Impact-Analysis"><a class="docs-heading-anchor" href="#Policy-Impact-Analysis">Policy Impact Analysis</a><a id="Policy-Impact-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Policy-Impact-Analysis" title="Permalink"></a></h3><p><strong>Question:</strong> How do predicted outcomes change under different policy interventions?</p><pre><code class="language-julia hljs"># Healthcare: Compare predicted health outcomes under coverage scenarios
using GLM, DataFrames, Margins

model = glm(@formula(health_score ~ age + income + insurance + education),
            health_data, Normal(), IdentityLink())

policy_comparison = population_margins(model, health_data;
    type=:predictions,
    scenarios=(insurance=[&quot;none&quot;, &quot;basic&quot;, &quot;comprehensive&quot;])
)

df = DataFrame(policy_comparison)
# Shows average predicted health score under each insurance scenario</code></pre><p><strong>Result Interpretation:</strong></p><ul><li>Each row shows population-averaged predicted outcome under a specific policy</li><li>Standard errors account for uncertainty in model parameters</li><li>Can compare scenarios: <code>df[df.at_insurance .== &quot;comprehensive&quot;, :estimate] - df[df.at_insurance .== &quot;none&quot;, :estimate]</code></li></ul><h3 id="Treatment-Effect-Heterogeneity"><a class="docs-heading-anchor" href="#Treatment-Effect-Heterogeneity">Treatment Effect Heterogeneity</a><a id="Treatment-Effect-Heterogeneity-1"></a><a class="docs-heading-anchor-permalink" href="#Treatment-Effect-Heterogeneity" title="Permalink"></a></h3><p><strong>Question:</strong> Does the treatment effect vary across subpopulations?</p><pre><code class="language-julia hljs"># Education program: Effect of tutoring hours across SES groups
model = lm(@formula(test_score ~ tutoring_hours + ses + prior_score), student_data)

heterogeneous_effects = population_margins(model, student_data;
    type=:effects,
    vars=[:tutoring_hours],
    groups=:ses,
    scenarios=(prior_score=[40, 50, 60, 70, 80])  # Standardize baseline
)

df = DataFrame(heterogeneous_effects)
# Shows tutoring effect within each SES group, holding prior_score constant</code></pre><h3 id="Intervention-Dosage-Analysis"><a class="docs-heading-anchor" href="#Intervention-Dosage-Analysis">Intervention Dosage Analysis</a><a id="Intervention-Dosage-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Intervention-Dosage-Analysis" title="Permalink"></a></h3><p><strong>Question:</strong> What&#39;s the optimal intervention level?</p><pre><code class="language-julia hljs"># Medication study: Predicted outcomes at different dosages
dosage_response = population_margins(medication_model, patient_data;
    type=:predictions,
    scenarios=(dosage=[0, 5, 10, 15, 20, 25])  # mg
)

df = DataFrame(dosage_response)
# Plot estimate vs at_dosage to visualize dose-response curve</code></pre><h3 id="Demographic-Standardization"><a class="docs-heading-anchor" href="#Demographic-Standardization">Demographic Standardization</a><a id="Demographic-Standardization-1"></a><a class="docs-heading-anchor-permalink" href="#Demographic-Standardization" title="Permalink"></a></h3><p><strong>Question:</strong> What would effects be if population demographics were different?</p><pre><code class="language-julia hljs"># Labor economics: Income effect standardized to college-educated population
college_standardized = population_margins(wage_model, worker_data;
    type=:effects,
    vars=[:experience],
    scenarios=(education=[&quot;College&quot;])  # Everyone has college degree
)

# Compare to actual population (mixed education)
actual_population = population_margins(wage_model, worker_data;
    type=:effects,
    vars=[:experience]
)</code></pre><h3 id="Multi-Dimensional-Policy-Space"><a class="docs-heading-anchor" href="#Multi-Dimensional-Policy-Space">Multi-Dimensional Policy Space</a><a id="Multi-Dimensional-Policy-Space-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Dimensional-Policy-Space" title="Permalink"></a></h3><p><strong>Question:</strong> How do multiple policies interact?</p><pre><code class="language-julia hljs"># Tax policy: Joint effects of rates and deductions
tax_scenarios = population_margins(income_model, taxpayer_data;
    type=:predictions,
    scenarios=(
        tax_rate=[0.15, 0.22, 0.30],
        deduction_cap=[5000, 10000, 25000],
        credit_phase_out=[40000, 60000, 80000]
    )
)
# Result: 3×3×3 = 27 scenarios showing all policy combinations</code></pre><h2 id="Common-Patterns-and-Idioms"><a class="docs-heading-anchor" href="#Common-Patterns-and-Idioms">Common Patterns and Idioms</a><a id="Common-Patterns-and-Idioms-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Patterns-and-Idioms" title="Permalink"></a></h2><h3 id="Scenario-Naming-Convention"><a class="docs-heading-anchor" href="#Scenario-Naming-Convention">Scenario Naming Convention</a><a id="Scenario-Naming-Convention-1"></a><a class="docs-heading-anchor-permalink" href="#Scenario-Naming-Convention" title="Permalink"></a></h3><p>Scenarios appear in results with <code>at_</code> prefix:</p><pre><code class="language-julia hljs">result = population_margins(model, data;
    type=:predictions,
    scenarios=(treatment=[0, 1], dosage=[10, 20])
)

df = DataFrame(result)
names(df)  # Includes: :at_treatment, :at_dosage, :estimate, :se, ...</code></pre><h3 id="Extracting-Specific-Scenarios"><a class="docs-heading-anchor" href="#Extracting-Specific-Scenarios">Extracting Specific Scenarios</a><a id="Extracting-Specific-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-Specific-Scenarios" title="Permalink"></a></h3><pre><code class="language-julia hljs">df = DataFrame(result)

# Filter to treatment=1 scenarios only
treated = df[df.at_treatment .== 1, :]

# Compare two specific scenarios
baseline = df[(df.at_treatment .== 0) .&amp; (df.at_dosage .== 10), :]
intervention = df[(df.at_treatment .== 1) .&amp; (df.at_dosage .== 20), :]
difference = intervention.estimate .- baseline.estimate</code></pre><h3 id="Scenario-Differences-(Contrasts)"><a class="docs-heading-anchor" href="#Scenario-Differences-(Contrasts)">Scenario Differences (Contrasts)</a><a id="Scenario-Differences-(Contrasts)-1"></a><a class="docs-heading-anchor-permalink" href="#Scenario-Differences-(Contrasts)" title="Permalink"></a></h3><p>To compute differences between scenarios, use predictions:</p><pre><code class="language-julia hljs"># Wrong: Don&#39;t try to compute &quot;effect of treatment&quot; using effects + scenarios
# population_margins(model, data; type=:effects, vars=[:treatment], scenarios=(...))
# → treatment will be skipped (see skip rule in grouping.md)

# Right: Use predictions with treatment scenarios
predictions = population_margins(model, data;
    type=:predictions,
    scenarios=(treatment=[0, 1])
)

df = DataFrame(predictions)
ate = df[df.at_treatment .== 1, :estimate][1] - df[df.at_treatment .== 0, :estimate][1]
# Average Treatment Effect (ATE) = difference in predicted outcomes</code></pre><h3 id="Combining-with-Weights"><a class="docs-heading-anchor" href="#Combining-with-Weights">Combining with Weights</a><a id="Combining-with-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-with-Weights" title="Permalink"></a></h3><p>Scenarios respect sampling weights:</p><pre><code class="language-julia hljs"># Weighted scenarios (e.g., survey data)
result = population_margins(model, survey_data;
    type=:predictions,
    scenarios=(income=[30000, 50000, 70000]),
    weights=:survey_weight
)
# Predictions are population-weighted averages</code></pre><h2 id="Architecture-Overview"><a class="docs-heading-anchor" href="#Architecture-Overview">Architecture Overview</a><a id="Architecture-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Architecture-Overview" title="Permalink"></a></h2><p>Scenario handling is built around FormulaCompiler’s DataScenario system:</p><ul><li>DataScenario: a lightweight structure that maps variable overrides (e.g., <code>:z =&gt; 0.5</code>) and supplies them to the compiled evaluator per-row.</li><li>Core evaluation calls (internal):<ul><li><code>_predict_with_scenario(compiled, scenario, row, scale, β, link, row_buf)</code></li><li><code>_gradient_with_scenario!(out, compiled, scenario, row, scale, β, link, row_buf)</code></li></ul></li></ul><p>Key properties:</p><ul><li>Zero per-row allocations (reuse pre-allocated row and gradient buffers).</li><li>O(1) memory per context (reuse scenarios; continuous FD constructs only minimal override sets).</li><li>No mutation of the data; categorical types remain safe (no re-pooling required).</li></ul><h2 id="Computation-Details"><a class="docs-heading-anchor" href="#Computation-Details">Computation Details</a><a id="Computation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-Details" title="Permalink"></a></h2><h3 id="Continuous-Effects-under-Scenarios"><a class="docs-heading-anchor" href="#Continuous-Effects-under-Scenarios">Continuous Effects under Scenarios</a><a id="Continuous-Effects-under-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Effects-under-Scenarios" title="Permalink"></a></h3><ul><li>For each row i in the context and variable x, FD constructs centered differences around <code>x_i</code> while merging user overrides for other variables.</li><li>Average per-row effects and per-row gradients across the context (weighted or unweighted) and apply the delta method with the averaged gradient: <code>se = sqrt(ḡ&#39; Σ ḡ)</code>.</li></ul><h3 id="Categorical/Boolean-Effects-under-Scenarios"><a class="docs-heading-anchor" href="#Categorical/Boolean-Effects-under-Scenarios">Categorical/Boolean Effects under Scenarios</a><a id="Categorical/Boolean-Effects-under-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical/Boolean-Effects-under-Scenarios" title="Permalink"></a></h3><ul><li>Build contrasts (baseline or pairwise), merge overrides for non-effect variables into each level scenario, compute per-row differences and gradients, then average as above and apply the delta method.</li></ul><h3 id="Predictions-under-Scenarios"><a class="docs-heading-anchor" href="#Predictions-under-Scenarios">Predictions under Scenarios</a><a id="Predictions-under-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Predictions-under-Scenarios" title="Permalink"></a></h3><ul><li>Construct a single DataScenario per context, evaluate predictions and gradients per-row, average (weighted/unweighted), and apply the delta method with the averaged gradient.</li></ul><h2 id="Grouping-(groups-...)"><a class="docs-heading-anchor" href="#Grouping-(groups-...)">Grouping (groups = ...)</a><a id="Grouping-(groups-...)-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-(groups-...)" title="Permalink"></a></h2><ul><li>Group subsets are determined first (categorical crosses, quantile bins, thresholds).</li><li>Scenario evaluation occurs within each subset using the same overrides.</li><li>Large combination protection prevents explosion; invalid combinations error (error-first policy).</li></ul><h2 id="Weights"><a class="docs-heading-anchor" href="#Weights">Weights</a><a id="Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Weights" title="Permalink"></a></h2><ul><li>Weighted contexts use proper normalization by total weight: <code>Σw</code> is used for both effects and averaged gradients.</li><li>Sampling and frequency weights are supported; weights can be provided as a column <code>Symbol</code> or a vector.</li></ul><h2 id="Column-Naming-and-Ordering"><a class="docs-heading-anchor" href="#Column-Naming-and-Ordering">Column Naming and Ordering</a><a id="Column-Naming-and-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Column-Naming-and-Ordering" title="Permalink"></a></h2><ul><li>Group variables appear unprefixed (e.g., <code>education</code>).</li><li>Scenario variables appear with <code>at_</code> prefix (e.g., <code>at_x</code>).</li><li>Column order: context columns first (groups, then scenarios), then statistical columns.</li></ul><h2 id="Programmatic-Identification"><a class="docs-heading-anchor" href="#Programmatic-Identification">Programmatic Identification</a><a id="Programmatic-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Programmatic-Identification" title="Permalink"></a></h2><pre><code class="language-julia hljs">groups, scenarios = Margins.context_columns(result)
# groups == [:education, ...], scenarios == [:x, :policy, ...]</code></pre><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><h3 id="When-to-Use-Scenarios"><a class="docs-heading-anchor" href="#When-to-Use-Scenarios">When to Use Scenarios</a><a id="When-to-Use-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Scenarios" title="Permalink"></a></h3><p><strong>Use scenarios when you want:</strong></p><ul><li>Population-averaged counterfactuals (&quot;What if everyone had X=value?&quot;)</li><li>Policy impact assessment with population averaging</li><li>Standardization to common covariate values</li><li>Treatment effect estimation (via prediction differences)</li></ul><p><strong>Don&#39;t use scenarios when you want:</strong></p><ul><li>Effects at specific covariate points → Use <code>profile_margins()</code> with <code>cartesian_grid()</code></li><li>Representative individual analysis → Use <code>profile_margins()</code> with <code>means_grid()</code></li><li>Detailed covariate combinations → Use <code>profile_margins()</code> with reference grids</li></ul><h3 id="Avoiding-Common-Mistakes"><a class="docs-heading-anchor" href="#Avoiding-Common-Mistakes">Avoiding Common Mistakes</a><a id="Avoiding-Common-Mistakes-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-Common-Mistakes" title="Permalink"></a></h3><h4 id="Mistake-1:-Confusing-Scenarios-with-Profile-Analysis"><a class="docs-heading-anchor" href="#Mistake-1:-Confusing-Scenarios-with-Profile-Analysis">Mistake 1: Confusing Scenarios with Profile Analysis</a><a id="Mistake-1:-Confusing-Scenarios-with-Profile-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Mistake-1:-Confusing-Scenarios-with-Profile-Analysis" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Wrong: Using scenarios for &quot;effects at x=10&quot;
# This computes population-average effect when everyone has x=10 (not what you want)
population_margins(model, data; type=:effects, vars=[:z], scenarios=(x=[10]))

# Right: Use profile analysis for &quot;effects at x=10&quot;
profile_margins(model, data, cartesian_grid(x=[10]); type=:effects, vars=[:z])</code></pre><h4 id="Mistake-2:-Skip-Rule-Violation"><a class="docs-heading-anchor" href="#Mistake-2:-Skip-Rule-Violation">Mistake 2: Skip Rule Violation</a><a id="Mistake-2:-Skip-Rule-Violation-1"></a><a class="docs-heading-anchor-permalink" href="#Mistake-2:-Skip-Rule-Violation" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Wrong: x appears in both vars and scenarios
# Result: x will be skipped, only other variables computed
population_margins(model, data; type=:effects, vars=[:x, :z], scenarios=(x=[1, 2]))

# Right: Use predictions to see how outcomes change as x varies
population_margins(model, data; type=:predictions, scenarios=(x=[1, 2]))</code></pre><h4 id="Mistake-3:-Too-Many-Scenario-Combinations"><a class="docs-heading-anchor" href="#Mistake-3:-Too-Many-Scenario-Combinations">Mistake 3: Too Many Scenario Combinations</a><a id="Mistake-3:-Too-Many-Scenario-Combinations-1"></a><a class="docs-heading-anchor-permalink" href="#Mistake-3:-Too-Many-Scenario-Combinations" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Dangerous: 10×10×10×10 = 10,000 scenarios
# result = population_margins(model, data;
#     type=:predictions,
#     scenarios=(a=1:10, b=1:10, c=1:10, d=1:10)
# )

# Better: Focus on key scenarios
result = population_margins(model, data;
    type=:predictions,
    scenarios=(a=[1, 5, 10], b=[1, 5, 10])  # 3×3 = 9 scenarios
)</code></pre><h3 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h3><p><strong>Scenario Count:</strong></p><ul><li>Each scenario requires a full population pass</li><li>100 scenarios on 10,000 observations = 1 million evaluations</li><li>Keep scenario counts reasonable (&lt; 100 for most applications)</li></ul><p><strong>Grouping Interaction:</strong></p><ul><li>Scenarios are evaluated within each group</li><li>10 groups × 20 scenarios = 200 computations</li><li>Computational cost is O(groups × scenarios × observations)</li></ul><p><strong>Memory:</strong></p><ul><li>Zero per-row allocations (efficient)</li><li>Memory scales with number of unique scenarios, not observations</li><li>Large scenario counts use O(scenarios) memory for result storage</li></ul><h2 id="Technical-Implementation-Notes"><a class="docs-heading-anchor" href="#Technical-Implementation-Notes">Technical Implementation Notes</a><a id="Technical-Implementation-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Implementation-Notes" title="Permalink"></a></h2><h3 id="Statistical-Correctness"><a class="docs-heading-anchor" href="#Statistical-Correctness">Statistical Correctness</a><a id="Statistical-Correctness-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-Correctness" title="Permalink"></a></h3><p>All scenarios maintain <strong>publication-grade statistical validity</strong>:</p><ul><li>Full delta-method standard errors using complete covariance matrix Σ</li><li>Proper gradient averaging across population</li><li>No independence assumptions</li><li>Accounts for parameter uncertainty</li></ul><h3 id="Computational-Architecture"><a class="docs-heading-anchor" href="#Computational-Architecture">Computational Architecture</a><a id="Computational-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Architecture" title="Permalink"></a></h3><p><strong>Zero-Allocation Design:</strong></p><ul><li>Scenarios use FormulaCompiler&#39;s DataScenario system for efficient variable overrides</li><li>Pre-allocated buffers reused across all scenario evaluations</li><li>No data mutation (original data remains unchanged)</li><li>Categorical types safe (no re-pooling required)</li></ul><p><strong>Performance Characteristics:</strong></p><ul><li>O(1) memory per scenario (reuse buffers)</li><li>O(n) time per scenario where n = observations</li><li>Scenarios evaluated in parallel when possible</li><li>FD backend: minimal override sets constructed</li><li>AD backend: exact derivatives with zero allocation</li></ul><h3 id="Column-Naming-Convention"><a class="docs-heading-anchor" href="#Column-Naming-Convention">Column Naming Convention</a><a id="Column-Naming-Convention-1"></a><a class="docs-heading-anchor-permalink" href="#Column-Naming-Convention" title="Permalink"></a></h3><p>Results use consistent naming:</p><ul><li><strong>Group variables:</strong> Unprefixed (e.g., <code>education</code>, <code>region</code>)</li><li><strong>Scenario variables:</strong> <code>at_</code> prefix (e.g., <code>at_treatment</code>, <code>at_dosage</code>)</li><li><strong>Statistical columns:</strong> <code>estimate</code>, <code>se</code>, <code>ci_lower</code>, <code>ci_upper</code>, etc.</li></ul><p><strong>Programmatic Access:</strong></p><pre><code class="language-julia hljs"># Identify which columns are groups vs scenarios
groups, scenarios = Margins.context_columns(result)
# groups == [:education, ...], scenarios == [:treatment, :dosage, ...]</code></pre><h2 id="Relationship-to-Profile-Analysis"><a class="docs-heading-anchor" href="#Relationship-to-Profile-Analysis">Relationship to Profile Analysis</a><a id="Relationship-to-Profile-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship-to-Profile-Analysis" title="Permalink"></a></h2><p><strong>Key Distinction:</strong></p><ul><li><strong>Population scenarios (<code>population_margins</code> + <code>scenarios</code>):</strong> Population-averaged quantities under counterfactual values</li><li><strong>Profile analysis (<code>profile_margins</code> + reference grids):</strong> Quantities at specific covariate combinations</li></ul><p><strong>When to use each:</strong></p><table><tr><th style="text-align: right">Goal</th><th style="text-align: right">Method</th></tr><tr><td style="text-align: right">&quot;Average effect if everyone had X=10&quot;</td><td style="text-align: right"><code>population_margins</code> with <code>scenarios=(X=[10])</code></td></tr><tr><td style="text-align: right">&quot;Effect at X=10 for a typical individual&quot;</td><td style="text-align: right"><code>profile_margins</code> with <code>cartesian_grid(X=[10])</code></td></tr><tr><td style="text-align: right">&quot;Compare predictions across 3 policies&quot;</td><td style="text-align: right"><code>population_margins</code> with <code>scenarios=(policy=[...])</code></td></tr><tr><td style="text-align: right">&quot;Effects at high/med/low values of X&quot;</td><td style="text-align: right"><code>profile_margins</code> with <code>cartesian_grid(X=[...])</code></td></tr></table><p><strong>Remember:</strong> <code>profile_margins()</code> does <strong>not accept</strong> <code>scenarios</code> parameter. Use reference grid builders (<code>cartesian_grid</code>, <code>means_grid</code>, etc.) instead.</p><h2 id="Further-Reading"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></h2><ul><li><a href="../grouping/">Grouping Framework</a> - Combining scenarios with groups</li><li><a href="../reference_grids/">Reference Grids</a> - Profile analysis alternative</li><li><a href="../api/">API Reference</a> - Complete parameter documentation</li></ul><hr/><p><em>Population scenarios enable sophisticated counterfactual analysis while maintaining computational efficiency and statistical rigor. They are a powerful tool for policy evaluation, treatment effect estimation, and &quot;what if&quot; analysis in econometric research.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../profile_margins/">« Profile Analysis</a><a class="docs-footer-nextpage" href="../second_differences/">Second Differences »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 23 October 2025 13:19">Thursday 23 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
