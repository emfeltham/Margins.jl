<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Margins.jl</title><meta name="title" content="Examples · Margins.jl"/><meta property="og:title" content="Examples · Margins.jl"/><meta property="twitter:title" content="Examples · Margins.jl"/><meta name="description" content="Documentation for Margins.jl."/><meta property="og:description" content="Documentation for Margins.jl."/><meta property="twitter:description" content="Documentation for Margins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Margins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Margins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../computational_architecture/">Computational Architecture</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../reference_grids/">Reference Grids</a></li><li><a class="tocitem" href="../profile_margins/">Profile Analysis</a></li><li><a class="tocitem" href="../population_scenarios/">Population Scenarios</a></li><li><a class="tocitem" href="../second_differences/">Second Differences</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../grouping/">Population Grouping</a></li><li><a class="tocitem" href="../backend_selection/">Backend Selection</a></li><li><a class="tocitem" href="../performance/">Performance Guide</a></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><a class="tocitem" href="../stata_migration/">Migration Guide</a></li><li><a class="tocitem" href="../comparison/">Package Comparison</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Conceptual-Overview"><span>Conceptual Overview</span></a></li><li><a class="tocitem" href="#Basic-Implementation"><span>Basic Implementation</span></a></li><li><a class="tocitem" href="#Advanced-Implementation-Patterns"><span>Advanced Implementation Patterns</span></a></li><li><a class="tocitem" href="#Economic-Analysis-Workflow"><span>Economic Analysis Workflow</span></a></li><li><a class="tocitem" href="#Elasticity-Analysis"><span>Elasticity Analysis</span></a></li><li><a class="tocitem" href="#Advanced-Features"><span>Advanced Features</span></a></li><li><a class="tocitem" href="#Stata-Migration-Examples"><span>Stata Migration Examples</span></a></li><li><a class="tocitem" href="#MixedModels.jl-Examples"><span>MixedModels.jl Examples</span></a></li><li><a class="tocitem" href="#Best-Practices"><span>Best Practices</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl/" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p><em>Comprehensive workflow examples and implementation patterns</em></p><h2 id="Conceptual-Overview"><a class="docs-heading-anchor" href="#Conceptual-Overview">Conceptual Overview</a><a id="Conceptual-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Conceptual-Overview" title="Permalink"></a></h2><h3 id="Example-Organization"><a class="docs-heading-anchor" href="#Example-Organization">Example Organization</a><a id="Example-Organization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Organization" title="Permalink"></a></h3><p>This guide demonstrates practical implementation of the two-dimensional analytical framework through concrete examples. Examples progress from basic usage patterns to advanced specification techniques, illustrating both population and profile analysis approaches across diverse econometric applications.</p><h2 id="Basic-Implementation"><a class="docs-heading-anchor" href="#Basic-Implementation">Basic Implementation</a><a id="Basic-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Implementation" title="Permalink"></a></h2><h3 id="Fundamental-Usage-Pattern"><a class="docs-heading-anchor" href="#Fundamental-Usage-Pattern">Fundamental Usage Pattern</a><a id="Fundamental-Usage-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Fundamental-Usage-Pattern" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Random
using Margins, DataFrames, GLM

# Generate sample data
n = 1000
Random.seed!(06515)
df = DataFrame(
    y = randn(n),
    x1 = randn(n), 
    x2 = randn(n),
    group = rand([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], n)
)

# Fit model
model = lm(@formula(y ~ x1 + x2 + group), df)

# Population average marginal effects (AME)
ame_result = population_margins(model, df; type=:effects)
DataFrame(ame_result)

# Marginal effects at sample means (MEM)  
mem_result = profile_margins(model, df, means_grid(df); type=:effects)
DataFrame(mem_result)</code></pre><h2 id="Advanced-Implementation-Patterns"><a class="docs-heading-anchor" href="#Advanced-Implementation-Patterns">Advanced Implementation Patterns</a><a id="Advanced-Implementation-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Implementation-Patterns" title="Permalink"></a></h2><h3 id="Profile-Specification-Methods"><a class="docs-heading-anchor" href="#Profile-Specification-Methods">Profile Specification Methods</a><a id="Profile-Specification-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Profile-Specification-Methods" title="Permalink"></a></h3><p>Margins.jl provides multiple approaches to specify evaluation profiles for <code>profile_margins()</code>, each optimized for different analytical requirements.</p><h3 id="1.-Table-Based-Reference-Grid-(Maximum-Control)"><a class="docs-heading-anchor" href="#1.-Table-Based-Reference-Grid-(Maximum-Control)">1. Table-Based Reference Grid (Maximum Control)</a><a id="1.-Table-Based-Reference-Grid-(Maximum-Control)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Table-Based-Reference-Grid-(Maximum-Control)" title="Permalink"></a></h3><p>For exact control over evaluation points, pass a DataFrame directly:</p><pre><code class="language-julia hljs">using DataFrames

# Custom reference grid
reference_grid = DataFrame(
    x1 = [-1.0, 0.0, 1.0],
    x2 = [10, 15, 20],
    group = [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;]  # Row order preserved as specified
)

# Predictions at specific points
predictions = profile_margins(model, df, reference_grid; type=:predictions)

# Effects at specific points  
effects = profile_margins(model, df, reference_grid; type=:effects, vars=[:x1, :x2])</code></pre><h3 id="2.-Cartesian-Product-Specification"><a class="docs-heading-anchor" href="#2.-Cartesian-Product-Specification">2. Cartesian Product Specification</a><a id="2.-Cartesian-Product-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Cartesian-Product-Specification" title="Permalink"></a></h3><p>For systematic scenario construction, use grid builders to specify value combinations:</p><pre><code class="language-julia hljs"># Systematic scenario grid (Cartesian product)
scenarios = cartesian_grid(x1=[-1.0, 0.0, 1.0], x2=[10, 20], group=[&quot;A&quot;, &quot;B&quot;])  
# Creates 3×2×2 = 12 evaluation points

# Effects across all scenarios
scenario_effects = profile_margins(model, df, scenarios; type=:effects, vars=[:x1])
DataFrame(scenario_effects)</code></pre><h3 id="3.-At-Sample-Means-(Most-Common)"><a class="docs-heading-anchor" href="#3.-At-Sample-Means-(Most-Common)">3. At Sample Means (Most Common)</a><a id="3.-At-Sample-Means-(Most-Common)-1"></a><a class="docs-heading-anchor-permalink" href="#3.-At-Sample-Means-(Most-Common)" title="Permalink"></a></h3><p>For representative case analysis:</p><pre><code class="language-julia hljs"># Effects at sample means - most interpretable approach
means_effects = profile_margins(model, df, means_grid(df); type=:effects)

# Predictions at sample means
means_predictions = profile_margins(model, df, means_grid(df); type=:predictions)</code></pre><h3 id="4.-Explicit-Profile-Tables"><a class="docs-heading-anchor" href="#4.-Explicit-Profile-Tables">4. Explicit Profile Tables</a><a id="4.-Explicit-Profile-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Explicit-Profile-Tables" title="Permalink"></a></h3><p>For irregular or custom evaluation points, pass an explicit DataFrame:</p><pre><code class="language-julia hljs">custom_profiles = DataFrame(
    x1 = [-1.0, 0.0, 1.0],
    x2 = [10, 15, 20],
    group = [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;]
)

results = profile_margins(model, df, custom_profiles; type=:effects)</code></pre><h3 id="5.-Categorical-Mixtures-for-Policy-Analysis"><a class="docs-heading-anchor" href="#5.-Categorical-Mixtures-for-Policy-Analysis">5. Categorical Mixtures for Policy Analysis</a><a id="5.-Categorical-Mixtures-for-Policy-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Categorical-Mixtures-for-Policy-Analysis" title="Permalink"></a></h3><p>For realistic population scenarios using categorical mixtures:</p><pre><code class="language-julia hljs">using CategoricalArrays

# Realistic policy scenarios with population composition
mixture_grid = DataFrame(group=[mix(&quot;A&quot; =&gt; 0.5, &quot;B&quot; =&gt; 0.3, &quot;C&quot; =&gt; 0.2)])
policy_scenario = profile_margins(model, df, mixture_grid; type=:predictions)

# Multiple policy scenarios
policy_grid = DataFrame(
    x1 = [0, 1],  # Policy intervention levels
    group = [mix(&quot;A&quot; =&gt; 0.6, &quot;B&quot; =&gt; 0.4), mix(&quot;A&quot; =&gt; 0.6, &quot;B&quot; =&gt; 0.4)]
)
policy_effects = profile_margins(model, df, policy_grid; type=:effects)</code></pre><h2 id="Economic-Analysis-Workflow"><a class="docs-heading-anchor" href="#Economic-Analysis-Workflow">Economic Analysis Workflow</a><a id="Economic-Analysis-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Economic-Analysis-Workflow" title="Permalink"></a></h2><h3 id="Wage-Determination-Analysis"><a class="docs-heading-anchor" href="#Wage-Determination-Analysis">Wage Determination Analysis</a><a id="Wage-Determination-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Wage-Determination-Analysis" title="Permalink"></a></h3><p>Complete econometric workflow using human capital theory:</p><pre><code class="language-julia hljs">using GLM, CategoricalArrays, Random

# Generate realistic econometric dataset
Random.seed!(06515)
n = 2000

data = DataFrame(
    # Demographics
    age = rand(25:65, n),
    female = rand([0, 1], n),
    education = categorical(rand([&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;], n)),
    
    # Economic variables
    experience = rand(0:40, n),
    urban = rand([0, 1], n),
    unemployment_rate = rand(3.0:0.1:12.0, n)
)

# Generate realistic log wages
education_effects = Dict(&quot;HS&quot; =&gt; 0.0, &quot;College&quot; =&gt; 0.4, &quot;Graduate&quot; =&gt; 0.8)
edu_numeric = [education_effects[string(edu)] for edu in data.education]

data.log_wage = 1.5 .+ 
                0.05 .* data.age .+ 
                edu_numeric .+ 
                0.02 .* data.experience .- 
                0.15 .* data.female .+ 
                0.10 .* data.urban .- 
                0.03 .* data.unemployment_rate .+ 
                0.3 .* randn(n)

# Fit wage equation
wage_model = lm(@formula(log_wage ~ age + education + experience + 
                        female + urban + unemployment_rate), data)</code></pre><h4 id="Population-Analysis"><a class="docs-heading-anchor" href="#Population-Analysis">Population Analysis</a><a id="Population-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Analysis" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Population average marginal effects
ame_results = population_margins(wage_model, data; type=:effects)
println(&quot;Population Average Marginal Effects:&quot;)
println(DataFrame(ame_results))

# Effects by gender subgroups  
gender_effects = population_margins(wage_model, data; 
                                  type=:effects, 
                                  groups=:female)
println(&quot;Effects by gender:&quot;)
println(DataFrame(gender_effects))</code></pre><h4 id="Profile-Analysis"><a class="docs-heading-anchor" href="#Profile-Analysis">Profile Analysis</a><a id="Profile-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Profile-Analysis" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Effects at sample means (representative person)
mem_results = profile_margins(wage_model, data, means_grid(data); type=:effects)
println(&quot;Effects for typical person:&quot;)
println(DataFrame(mem_results))

# Policy scenarios: education and unemployment effects
policy_grid = cartesian_grid(education=[&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;],
                             unemployment_rate=[3.0, 6.0, 9.0])
policy_analysis = profile_margins(wage_model, data, policy_grid; type=:predictions)
println(&quot;Policy scenario predictions:&quot;)
println(DataFrame(policy_analysis))</code></pre><h3 id="Logistic-Regression-Example"><a class="docs-heading-anchor" href="#Logistic-Regression-Example">Logistic Regression Example</a><a id="Logistic-Regression-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic-Regression-Example" title="Permalink"></a></h3><p>Binary outcome analysis with proper probability interpretation:</p><pre><code class="language-julia hljs"># Generate binary outcome data
data.manager = [rand() &lt; (1/(1+exp(-(-1.0 + 0.03*age + 0.5*edu + 0.02*exp - 0.3*fem)))) ? 1 : 0 
                for (age,edu,exp,fem) in zip(data.age, edu_numeric, data.experience, data.female)]

# Fit logistic model
logit_model = glm(@formula(manager ~ age + education + experience + female), 
                  data, Binomial(), LogitLink())

# Effects on probability scale (most interpretable)
prob_effects = population_margins(logit_model, data; 
                                type=:effects, 
                                scale=:response)
println(&quot;Effects on probability of management position:&quot;)
println(DataFrame(prob_effects))

# Gender gap analysis across education levels
gender_grid = cartesian_grid(education=[&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;], female=[0, 1])
gender_gap = profile_margins(logit_model, data, gender_grid;
    type=:predictions, scale=:response)
println(&quot;Gender gap in management probability by education:&quot;)
println(DataFrame(gender_gap))</code></pre><h2 id="Elasticity-Analysis"><a class="docs-heading-anchor" href="#Elasticity-Analysis">Elasticity Analysis</a><a id="Elasticity-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Elasticity-Analysis" title="Permalink"></a></h2><h3 id="Basic-Elasticity-Computation"><a class="docs-heading-anchor" href="#Basic-Elasticity-Computation">Basic Elasticity Computation</a><a id="Basic-Elasticity-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Elasticity-Computation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Population average elasticities
elasticities = population_margins(wage_model, data; 
                                type=:effects, 
                                measure=:elasticity,
                                vars=[:age, :experience])
println(&quot;Population average elasticities:&quot;)
println(DataFrame(elasticities))

# Elasticities at different education levels
edu_grid = cartesian_grid(education=[&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;]) 
edu_elasticities = profile_margins(wage_model, data, edu_grid;
    type=:effects, measure=:elasticity, vars=[:age, :experience])
println(&quot;Elasticities by education level:&quot;)
println(DataFrame(edu_elasticities))</code></pre><h3 id="Semi-Elasticities"><a class="docs-heading-anchor" href="#Semi-Elasticities">Semi-Elasticities</a><a id="Semi-Elasticities-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-Elasticities" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Semi-elasticity: % change in wages per unit change in unemployment
unemployment_semi = population_margins(wage_model, data;
                                     measure=:semielasticity_dyex,
                                     vars=[:unemployment_rate])
println(&quot;Unemployment semi-elasticity (% wage change per point):&quot;)
println(DataFrame(unemployment_semi))</code></pre><h2 id="Advanced-Features"><a class="docs-heading-anchor" href="#Advanced-Features">Advanced Features</a><a id="Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Features" title="Permalink"></a></h2><h3 id="Advanced-Grouping-and-Stratification"><a class="docs-heading-anchor" href="#Advanced-Grouping-and-Stratification">Advanced Grouping and Stratification</a><a id="Advanced-Grouping-and-Stratification-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Grouping-and-Stratification" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Basic categorical grouping
urban_analysis = population_margins(wage_model, data; 
                                  type=:effects, 
                                  groups=:urban)

# Cross-tabulated grouping
education_urban = population_margins(wage_model, data; 
                                   type=:effects, 
                                   groups=[:education, :urban])

# Hierarchical grouping: education → urban within each education level
nested_analysis = population_margins(wage_model, data;
                                   type=:effects,
                                   groups=:education =&gt; :urban)

# Continuous binning: age quartiles
age_quartiles = population_margins(wage_model, data;
                                 type=:effects,
                                 groups=(:age, 4))

# Custom thresholds for policy analysis
income_thresholds = population_margins(wage_model, data;
                                     type=:effects,
                                     groups=(:log_wage, [2.0, 2.5, 3.0]))

# Mixed categorical and continuous
complex_groups = population_margins(wage_model, data;
                                  type=:effects,
                                  groups=[:education, (:age, 4)])</code></pre><h3 id="Counterfactual-Scenario-Analysis"><a class="docs-heading-anchor" href="#Counterfactual-Scenario-Analysis">Counterfactual Scenario Analysis</a><a id="Counterfactual-Scenario-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Counterfactual-Scenario-Analysis" title="Permalink"></a></h3><h4 id="Skip-Rule-Example:-dydx(x)-across-x-strata-using-a-derived-bin-variable"><a class="docs-heading-anchor" href="#Skip-Rule-Example:-dydx(x)-across-x-strata-using-a-derived-bin-variable">Skip Rule Example: dydx(x) across x strata using a derived bin variable</a><a id="Skip-Rule-Example:-dydx(x)-across-x-strata-using-a-derived-bin-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Skip-Rule-Example:-dydx(x)-across-x-strata-using-a-derived-bin-variable" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Statistics
using CategoricalArrays

# Suppose we want dydx(age) across age strata without holding age fixed or using it as the grouping key directly.
# Create an &quot;age_bin&quot; column (quartiles), then group by that derived column:
edges = quantile(data.age, 0:0.25:1.0)
labels = [&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;, &quot;Q4&quot;]
data.age_bin = cut(data.age, edges; labels=labels, extend=true)

age_effects_by_bin = population_margins(wage_model, data;
    type=:effects,
    vars=[:age],
    groups=:age_bin)

DataFrame(age_effects_by_bin)</code></pre><pre><code class="language-julia hljs"># Policy scenarios: unemployment rate effects
recession_scenarios = population_margins(wage_model, data;
                                       type=:effects,
                                       scenarios=(:unemployment_rate =&gt; [3.0, 6.0, 12.0]))

# Combined grouping and scenarios
education_recession = population_margins(wage_model, data;
                                       type=:effects,
                                       groups=:education,
                                       scenarios=(:unemployment_rate =&gt; [3.0, 12.0]))

# Multi-variable scenarios
complex_policy = population_margins(wage_model, data;
                                  type=:effects,
                                  scenarios=(:urban =&gt; [0, 1], 
                                               :unemployment_rate =&gt; [3.0, 9.0]))</code></pre><h3 id="Robust-Standard-Errors"><a class="docs-heading-anchor" href="#Robust-Standard-Errors">Robust Standard Errors</a><a id="Robust-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Standard-Errors" title="Permalink"></a></h3><pre><code class="language-julia hljs">using CovarianceMatrices

# Heteroskedasticity-robust standard errors (HC1)
robust_effects = population_margins(wage_model, data; vcov=CovarianceMatrices.HC1, type=:effects)
println(&quot;Robust standard errors:&quot;)
println(DataFrame(robust_effects))</code></pre><h3 id="Performance-Comparison"><a class="docs-heading-anchor" href="#Performance-Comparison">Performance Comparison</a><a id="Performance-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Comparison" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BenchmarkTools

# Profile margins: O(1) constant time
println(&quot;Profile margins performance (constant time):&quot;)
@btime profile_margins($wage_model, $data, means_grid($data); type=:effects)

# Population margins: O(n) scaling  
println(&quot;Population margins performance (scales with n):&quot;)
@btime population_margins($wage_model, $data; type=:effects)

# Complex scenario analysis (still O(1) for profiles)
complex_scenarios = cartesian_grid(age=[25, 35, 45, 55],
                                   education=[&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;],
                                   urban=[0, 1])
println(&quot;Complex scenario performance (24 profiles, still O(1)):&quot;)
@btime profile_margins($wage_model, $data, $complex_scenarios; type=:effects)</code></pre><h2 id="Stata-Migration-Examples"><a class="docs-heading-anchor" href="#Stata-Migration-Examples">Stata Migration Examples</a><a id="Stata-Migration-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Stata-Migration-Examples" title="Permalink"></a></h2><p>Direct equivalency for economists familiar with Stata:</p><pre><code class="language-julia hljs"># Stata: margins, dydx(*)
stata_ame = population_margins(wage_model, data; type=:effects)

# Stata: margins, at(means) dydx(*)  
stata_mem = profile_margins(wage_model, data, means_grid(data); type=:effects)

# Stata: margins, at(age=(25 35 45) education=(1 2 3))
stata_grid = cartesian_grid(age=[25, 35, 45], education=[&quot;HS&quot;, &quot;College&quot;, &quot;Graduate&quot;]) 
stata_scenarios = profile_margins(wage_model, data, stata_grid; type=:effects)

# Stata: margins, over(female)
stata_subgroups = population_margins(wage_model, data; 
                                   type=:effects, 
                                   groups=:female)</code></pre><h2 id="MixedModels.jl-Examples"><a class="docs-heading-anchor" href="#MixedModels.jl-Examples">MixedModels.jl Examples</a><a id="MixedModels.jl-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#MixedModels.jl-Examples" title="Permalink"></a></h2><p>Minimal linear and generalized linear mixed models with population analysis.</p><pre><code class="language-julia hljs"># Illustrative example (not executed in docs CI): MixedModels integration
using Random
using DataFrames, CategoricalArrays, MixedModels, StatsModels, Margins

# Synthetic random-intercept dataset
Random.seed!(42)
n_groups = 20; n_per = 30; n = n_groups * n_per
group = repeat(1:n_groups, inner=n_per)
x = randn(n)
u = randn(n_groups)  # random intercepts
y = 1.0 .+ 0.5 .* x .+ u[group] .+ 0.2 .* randn(n)
df = DataFrame(y=y, x=x, group=categorical(string.(group)))

# Linear mixed model
lmm = fit(MixedModel, @formula(y ~ 1 + x + (1 | group)), df)

# Population AME for x (averaged across sample distribution)
ame_lmm = population_margins(lmm, df; type=:effects, vars=[:x])

# Generalized linear mixed model (binary outcome)
η = -0.5 .+ 1.2 .* x .+ u[group]
p = 1.0 ./ (1 .+ exp.(-η))
ybin = rand.(Bernoulli.(p))
df_bin = DataFrame(y=ybin, x=x, group=df.group)

glmm = GeneralizedLinearMixedModel(@formula(y ~ 1 + x + (1 | group)), df_bin, Binomial()) |&gt; fit!

# Probability-scale effects
prob_effects_glmm = population_margins(glmm, df_bin; type=:effects, vars=[:x], scale=:response)</code></pre><h2 id="Best-Practices"><a class="docs-heading-anchor" href="#Best-Practices">Best Practices</a><a id="Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices" title="Permalink"></a></h2><h3 id="When-to-Use-Population-vs-Profile"><a class="docs-heading-anchor" href="#When-to-Use-Population-vs-Profile">When to Use Population vs Profile</a><a id="When-to-Use-Population-vs-Profile-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Population-vs-Profile" title="Permalink"></a></h3><p><strong>Choose Population Analysis When</strong>:</p><ul><li>Estimating true average effects across your sample</li><li>Sample heterogeneity is important for policy</li><li>External validity to similar populations is the goal</li><li>Broad policy applications affecting diverse groups</li></ul><p><strong>Choose Profile Analysis When</strong>:</p><ul><li>Understanding specific, concrete scenarios  </li><li>Communicating results to non-technical audiences</li><li>Sample is relatively homogeneous</li><li>Policy targets specific demographic profiles</li></ul><h3 id="Performance-Guidelines"><a class="docs-heading-anchor" href="#Performance-Guidelines">Performance Guidelines</a><a id="Performance-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guidelines" title="Permalink"></a></h3><pre><code class="language-julia hljs"># For large datasets (&gt;100k observations)
# Profile margins remain fast regardless of size
large_data_profiles = profile_margins(model, large_data, means_grid(large_data); type=:effects)

# Population margins scale linearly - use selectively for very large data
key_population_effects = population_margins(model, large_data; 
                                          vars=[:key_variable], 
                                          type=:effects)</code></pre><h3 id="Error-Handling-Best-Practices"><a class="docs-heading-anchor" href="#Error-Handling-Best-Practices">Error Handling Best Practices</a><a id="Error-Handling-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling-Best-Practices" title="Permalink"></a></h3><p><strong>Important:</strong> Margins.jl follows an <strong>error-first philosophy</strong> - when statistical correctness cannot be guaranteed, the package errors explicitly rather than producing potentially invalid results. This ensures users are aware of problems rather than receiving plausible-but-wrong statistical output.</p><pre><code class="language-julia hljs"># GOOD: Let errors propagate to inform users of issues
function analyze_margins(model, data, vars)
    # Errors will propagate with clear messages
    result = population_margins(model, data; type=:effects, vars=vars)
    return DataFrame(result)
end

# GOOD: Validate inputs before computation
function safe_margins_analysis(model, data, vars)
    # Check that variables exist in data
    data_vars = Set(Symbol.(names(data)))
    missing_vars = setdiff(Set(vars), data_vars)

    if !isempty(missing_vars)
        error(&quot;Variables not found in data: $(collect(missing_vars))&quot;)
    end

    # Let computation errors propagate naturally
    return population_margins(model, data; type=:effects, vars=vars)
end

# BAD: Silent fallbacks violate error-first philosophy
# function bad_margins_analysis(model, data)
#     try
#         return population_margins(model, data; backend=:ad)
#     catch e
#         @warn &quot;AD failed, using FD&quot;  # User doesn&#39;t know why AD failed!
#         return population_margins(model, data; backend=:fd)  # May produce different results!
#     end
# end
#
# Why this is bad:
# 1. Silently switches backends without user awareness
# 2. May hide underlying data quality issues
# 3. Results from AD vs FD may differ slightly
# 4. Violates principle: &quot;Error out rather than approximate&quot;</code></pre><p><strong>Guideline:</strong> If you encounter errors during marginal effects computation, investigate and fix the root cause rather than implementing silent fallbacks. Common issues include:</p><ul><li>Domain errors (use variables that stay positive for log/sqrt)</li><li>Missing variables (validate inputs before computation)</li><li>Model convergence issues (check model fit quality)</li><li>Data quality problems (check for NaN/Inf values)</li></ul><hr/><p><em>These examples demonstrate the full range of Margins.jl capabilities. For detailed API documentation, see <a href="../api/">API Reference</a>. For performance optimization, see <a href="../performance/">Performance Guide</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 24 October 2025 22:17">Friday 24 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
