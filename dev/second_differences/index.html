<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Second Differences · Margins.jl</title><meta name="title" content="Second Differences · Margins.jl"/><meta property="og:title" content="Second Differences · Margins.jl"/><meta property="twitter:title" content="Second Differences · Margins.jl"/><meta name="description" content="Documentation for Margins.jl."/><meta property="og:description" content="Documentation for Margins.jl."/><meta property="twitter:description" content="Documentation for Margins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Margins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Margins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../computational_architecture/">Computational Architecture</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../reference_grids/">Reference Grids</a></li><li><a class="tocitem" href="../profile_margins/">Profile Analysis</a></li><li><a class="tocitem" href="../population_scenarios/">Population Scenarios</a></li><li class="is-active"><a class="tocitem" href>Second Differences</a><ul class="internal"><li><a class="tocitem" href="#Conceptual-Foundation"><span>Conceptual Foundation</span></a></li><li><a class="tocitem" href="#Computational-Framework"><span>Computational Framework</span></a></li><li><a class="tocitem" href="#Function-Reference"><span>Function Reference</span></a></li><li><a class="tocitem" href="#Usage-Patterns"><span>Usage Patterns</span></a></li><li><a class="tocitem" href="#Advanced-Analysis-Patterns"><span>Advanced Analysis Patterns</span></a></li><li><a class="tocitem" href="#Methodological-Notes"><span>Methodological Notes</span></a></li><li><a class="tocitem" href="#Integration-Examples"><span>Integration Examples</span></a></li><li><a class="tocitem" href="#Error-Handling"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li><li><a class="tocitem" href="#Literature-and-References"><span>Literature and References</span></a></li></ul></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../grouping/">Population Grouping</a></li><li><a class="tocitem" href="../backend_selection/">Backend Selection</a></li><li><a class="tocitem" href="../performance/">Performance Guide</a></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><a class="tocitem" href="../stata_migration/">Migration Guide</a></li><li><a class="tocitem" href="../comparison/">Package Comparison</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Second Differences</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Second Differences</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl/" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Second-Differences-(Interaction-Effects)"><a class="docs-heading-anchor" href="#Second-Differences-(Interaction-Effects)">Second Differences (Interaction Effects)</a><a id="Second-Differences-(Interaction-Effects)-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Differences-(Interaction-Effects)" title="Permalink"></a></h1><p><em>Quantifying how marginal effects vary across moderator levels</em></p><h2 id="Conceptual-Foundation"><a class="docs-heading-anchor" href="#Conceptual-Foundation">Conceptual Foundation</a><a id="Conceptual-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#Conceptual-Foundation" title="Permalink"></a></h2><h3 id="What-Are-Second-Differences?"><a class="docs-heading-anchor" href="#What-Are-Second-Differences?">What Are Second Differences?</a><a id="What-Are-Second-Differences?-1"></a><a class="docs-heading-anchor-permalink" href="#What-Are-Second-Differences?" title="Permalink"></a></h3><p>Second differences measure whether the marginal effect of one variable differs across levels of another variable. In generalized linear models, where effects are inherently nonlinear, second differences provide the natural way to quantify interaction effects on the predicted outcome scale.</p><p><strong>Definition</strong>: For two variables <span>$X$</span> (focal variable) and <span>$Z$</span> (moderator), the second difference is defined as:</p><p>$</p><p>\Delta^2 = [E(Y|X=1,Z=1) - E(Y|X=0,Z=1)] - [E(Y|X=1,Z=0) - E(Y|X=0,Z=0)] $</p><p>This represents the difference in marginal effects, a &quot;difference of differences&quot;, capturing how the effect of <span>$X$</span> changes when <span>$Z$</span> changes.</p><h3 id="Relationship-to-Interaction-Terms"><a class="docs-heading-anchor" href="#Relationship-to-Interaction-Terms">Relationship to Interaction Terms</a><a id="Relationship-to-Interaction-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship-to-Interaction-Terms" title="Permalink"></a></h3><table><tr><th style="text-align: right">Model Type</th><th style="text-align: right">Linear Model</th><th style="text-align: right">Nonlinear Model (GLM)</th></tr><tr><td style="text-align: right"><strong>Simple effect</strong></td><td style="text-align: right">Coefficient on <span>$X$</span></td><td style="text-align: right">Marginal effect of <span>$X$</span></td></tr><tr><td style="text-align: right"><strong>Interaction</strong></td><td style="text-align: right">Coefficient on <span>$X \times Z$</span></td><td style="text-align: right">Second difference</td></tr><tr><td style="text-align: right"><strong>Scale</strong></td><td style="text-align: right">Coefficient scale = outcome scale</td><td style="text-align: right">Must compute from predicted probabilities/means</td></tr></table><p>In linear models, the interaction coefficient directly represents the second difference. In nonlinear models (logit, probit, Poisson), the interaction coefficient does not directly represent the interaction on the predicted scale, necessitating explicit computation of second differences from marginal effects.</p><h3 id="Methodological-Context"><a class="docs-heading-anchor" href="#Methodological-Context">Methodological Context</a><a id="Methodological-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Methodological-Context" title="Permalink"></a></h3><p>Second differences extend the conceptual framework of Margins.jl by addressing a fundamental question: <strong>&quot;Does the effect of X depend on Z?&quot;</strong> This complements the two core questions of marginal effects analysis:</p><ol><li><strong>Effects</strong>: &quot;How much does Y change when I change X?&quot;</li><li><strong>Predictions</strong>: &quot;What value of Y should I expect?&quot;</li></ol><p>Second differences answer: <strong>&quot;Does the answer to question 1 change depending on Z?&quot;</strong></p><h2 id="Computational-Framework"><a class="docs-heading-anchor" href="#Computational-Framework">Computational Framework</a><a id="Computational-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Framework" title="Permalink"></a></h2><h3 id="Two-Approaches-to-Second-Differences"><a class="docs-heading-anchor" href="#Two-Approaches-to-Second-Differences">Two Approaches to Second Differences</a><a id="Two-Approaches-to-Second-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Approaches-to-Second-Differences" title="Permalink"></a></h3><p>Margins.jl implements second differences through two complementary approaches:</p><h4 id="1.-Discrete-Contrast-Approach-(Population-Based)"><a class="docs-heading-anchor" href="#1.-Discrete-Contrast-Approach-(Population-Based)">1. Discrete Contrast Approach (Population-Based)</a><a id="1.-Discrete-Contrast-Approach-(Population-Based)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Discrete-Contrast-Approach-(Population-Based)" title="Permalink"></a></h4><p>The <strong>discrete contrast approach</strong> uses pre-computed population-level marginal effects (AMEs) via functions like <code>second_differences()</code>, <code>second_differences_pairwise()</code>, and <code>second_differences_all_contrasts()</code>. This approach provides:</p><ul><li><strong>Population representativeness</strong>: Effects averaged over the sample distribution</li><li><strong>Statistical validity</strong>: Proper delta-method standard errors accounting for full covariance structure</li><li><strong>Flexibility</strong>: Works with binary, categorical, and continuous moderators</li><li><strong>Use case</strong>: Comparing AMEs across discrete moderator levels</li></ul><h4 id="2.-Local-Derivative-Approach-(Profile-Based)"><a class="docs-heading-anchor" href="#2.-Local-Derivative-Approach-(Profile-Based)">2. Local Derivative Approach (Profile-Based)</a><a id="2.-Local-Derivative-Approach-(Profile-Based)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Local-Derivative-Approach-(Profile-Based)" title="Permalink"></a></h4><p>The <strong>local derivative approach</strong> uses <code>second_differences_at()</code> to compute derivatives at specific evaluation points via finite differences. This approach provides:</p><ul><li><strong>Profile-specific analysis</strong>: Evaluate how effects vary at representative covariate combinations</li><li><strong>Continuous moderation</strong>: Direct derivative ∂AME/∂modifier at specific points</li><li><strong>Scenario control</strong>: Hold other variables constant while varying only the modifier</li><li><strong>Use case</strong>: Understanding effect heterogeneity at particular policy-relevant profiles</li><li><strong>Requirement</strong>: <strong>Modifier must be continuous/numeric</strong> (focal variable can be continuous or categorical)</li></ul><h3 id="Statistical-Inference"><a class="docs-heading-anchor" href="#Statistical-Inference">Statistical Inference</a><a id="Statistical-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-Inference" title="Permalink"></a></h3><p>Standard errors for second differences employ rigorous delta-method computation. For a second difference comparing two AMEs (<span>$\text{AME}_1$</span> and <span>$\text{AME}_2$</span>) with parameter gradients <span>$g_1$</span> and <span>$g_2$</span>:</p><p>$</p><p>\text{SE}(\Delta^2) = \sqrt{(g<em>2 - g</em>1)&#39; \Sigma (g<em>2 - g</em>1)} $</p><p>where <span>$\Sigma$</span> is the model&#39;s parameter covariance matrix. This approach properly accounts for:</p><ul><li>Covariance between the two AME estimates</li><li>Full uncertainty propagation from model parameters</li><li>Appropriate test statistics and confidence intervals</li></ul><p>The delta-method computation ensures that hypothesis tests maintain appropriate Type I error rates and confidence intervals achieve nominal coverage probabilities, meeting the statistical validity standards required for econometric research.</p><h2 id="Function-Reference"><a class="docs-heading-anchor" href="#Function-Reference">Function Reference</a><a id="Function-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Reference" title="Permalink"></a></h2><h3 id="Main-Interface"><a class="docs-heading-anchor" href="#Main-Interface">Main Interface</a><a id="Main-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Interface" title="Permalink"></a></h3><h4 id="second_differences()"><a class="docs-heading-anchor" href="#second_differences()"><code>second_differences()</code></a><a id="second_differences()-1"></a><a class="docs-heading-anchor-permalink" href="#second_differences()" title="Permalink"></a></h4><p>Unified interface for computing second differences across all modifier types. This is the recommended entry point that automatically handles binary, categorical, and continuous moderators.</p><p><strong>Signature</strong>:</p><pre><code class="language-julia hljs">second_differences(
    ame_result::EffectsResult,
    variables::Union{Symbol, Vector{Symbol}},
    modifier::Symbol,
    vcov::Matrix{Float64};
    contrast::String = &quot;derivative&quot;,
    modifier_type::Symbol = :auto,
    all_contrasts::Bool = true
)</code></pre><p><strong>Arguments</strong>:</p><ul><li><code>ame_result</code>: Result from <code>population_margins()</code> with scenarios over the modifier</li><li><code>variables</code>: Focal variable(s) to analyze (single Symbol or Vector{Symbol})</li><li><code>modifier</code>: The moderating variable</li><li><code>vcov</code>: Parameter covariance matrix from the model (via <code>vcov(model)</code>)</li></ul><p><strong>Keyword Arguments</strong>:</p><ul><li><code>contrast</code>: Focal variable contrast for categorical variables (default: &quot;derivative&quot;)</li><li><code>modifier_type</code>: Modifier classification (:auto, :binary, :categorical, :continuous)</li><li><code>all_contrasts</code>: Compute all focal variable contrasts when applicable (default: true)</li></ul><p><strong>Returns</strong>: DataFrame with columns:</p><ul><li><code>variable</code>: Focal variable name</li><li><code>modifier</code>: Modifier variable name</li><li><code>contrast</code>: Contrast description (for categorical focal variables)</li><li><code>modifier_level1</code>, <code>modifier_level2</code>: Levels being compared</li><li><code>second_diff</code>: Second difference estimate (or slope for continuous)</li><li><code>se</code>: Standard error (delta method)</li><li><code>z_stat</code>: Z-statistic</li><li><code>p_value</code>: P-value for H₀: second difference = 0</li><li><code>ame_at_level1</code>, <code>ame_at_level2</code>: AME values at each level</li><li><code>modifier_type</code>: Detected modifier type</li><li><code>significant</code>: Boolean indicator (p &lt; 0.05)</li></ul><h3 id="Specialized-Functions"><a class="docs-heading-anchor" href="#Specialized-Functions">Specialized Functions</a><a id="Specialized-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-Functions" title="Permalink"></a></h3><h4 id="second_differences_pairwise()"><a class="docs-heading-anchor" href="#second_differences_pairwise()"><code>second_differences_pairwise()</code></a><a id="second_differences_pairwise()-1"></a><a class="docs-heading-anchor-permalink" href="#second_differences_pairwise()" title="Permalink"></a></h4><p>Computes all pairwise modifier comparisons for a single focal variable contrast.</p><p><strong>Use case</strong>: When analyzing a categorical or continuous moderator with multiple levels, and you want all pairwise comparisons for one specific contrast.</p><p><strong>Signature</strong>:</p><pre><code class="language-julia hljs">second_differences_pairwise(
    ame_result::EffectsResult,
    variable::Symbol,
    modifier::Symbol,
    vcov::Matrix{Float64};
    contrast::String = &quot;derivative&quot;,
    modifier_type::Symbol = :auto
)</code></pre><p><strong>Returns</strong>: DataFrame with one row per pairwise modifier comparison.</p><h4 id="second_differences_all_contrasts()"><a class="docs-heading-anchor" href="#second_differences_all_contrasts()"><code>second_differences_all_contrasts()</code></a><a id="second_differences_all_contrasts()-1"></a><a class="docs-heading-anchor-permalink" href="#second_differences_all_contrasts()" title="Permalink"></a></h4><p>Computes second differences for all contrasts of a categorical focal variable.</p><p><strong>Use case</strong>: When your focal variable is categorical with multiple contrasts (e.g., pairwise comparisons across education levels) and you want to see how each contrast varies across modifier levels.</p><p><strong>Signature</strong>:</p><pre><code class="language-julia hljs">second_differences_all_contrasts(
    ame_result::EffectsResult,
    variable::Symbol,
    modifier::Symbol,
    vcov::Matrix{Float64};
    modifier_type::Symbol = :auto
)</code></pre><p><strong>Returns</strong>: DataFrame with one row per (focal contrast × modifier pair) combination.</p><h4 id="second_differences_at()"><a class="docs-heading-anchor" href="#second_differences_at()"><code>second_differences_at()</code></a><a id="second_differences_at()-1"></a><a class="docs-heading-anchor-permalink" href="#second_differences_at()" title="Permalink"></a></h4><p>Computes local derivatives of marginal effects with respect to a <strong>continuous modifier</strong> at specified evaluation points using finite differences.</p><p><strong>Use case</strong>: Profile-based analysis where you want to understand how effects vary at specific covariate combinations, holding other variables constant.</p><p><strong>Important</strong>: The <strong>modifier must be numeric/continuous</strong> because the function uses finite differences (perturbing the modifier by ±δ). For categorical moderators, use <code>second_differences()</code> or <code>second_differences_pairwise()</code> instead.</p><p><strong>Signature</strong>:</p><pre><code class="language-julia hljs">second_differences_at(
    model::RegressionModel,
    data,
    variables::Union{Symbol, Vector{Symbol}},
    modifier::Symbol,
    vcov;
    at::Union{Symbol, Real, Vector, NamedTuple} = :mean,
    profile::NamedTuple = NamedTuple(),
    delta::Union{Symbol, Real} = :auto,
    scale::Symbol = :response
)</code></pre><p><strong>Arguments</strong>:</p><ul><li><code>model</code>: Fitted regression model</li><li><code>data</code>: Data frame used to fit the model</li><li><code>variables</code>: Focal variable(s) to compute derivatives for (can be continuous or categorical)</li><li><code>modifier</code>: <strong>Continuous</strong> modifier variable (differentiate with respect to this - must be numeric)</li><li><code>vcov</code>: Parameter covariance matrix or function</li></ul><p><strong>Keyword Arguments</strong>:</p><ul><li><code>at</code>: Where to evaluate the derivative<ul><li><code>:mean</code>: At mean(modifier) [default]</li><li><code>:median</code>: At median(modifier)</li><li>Numeric value: At specified modifier value</li><li>Vector: Multiple evaluation points</li><li>NamedTuple: Full explicit profile including modifier</li></ul></li><li><code>profile</code>: Additional variables to hold fixed (scalar or vector values)</li><li><code>delta</code>: Step size for finite difference (:auto or numeric value)</li><li><code>scale</code>: Prediction scale (:link or :response)</li></ul><p><strong>Returns</strong>: DataFrame with columns:</p><ul><li><code>variable</code>: Focal variable name</li><li><code>contrast</code>: Contrast description</li><li><code>modifier</code>: Modifier variable name</li><li><code>eval_point</code>: Evaluation point for modifier</li><li><code>derivative</code>: ∂AME/∂modifier (per unit change in modifier)</li><li><code>se</code>: Standard error of derivative</li><li><code>z_stat</code>, <code>p_value</code>: Statistical inference</li><li><code>delta_used</code>: Actual step size used</li><li>Additional columns for profile variables</li></ul><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Continuous focal variable, continuous modifier
sd = second_differences_at(model, data, :income, :age, vcov(model))
# → 1 row: derivative of income effect w.r.t. age

# Categorical focal variable, continuous modifier
# (education is categorical: &quot;hs&quot;, &quot;college&quot;, &quot;grad&quot;)
sd = second_differences_at(model, data, :education, :income, vcov(model))
# → Multiple rows: one per education contrast
# → e.g., &quot;college - hs&quot;, &quot;grad - hs&quot;, &quot;grad - college&quot;
# → Shows how each education gap varies with income

# At specific profile with other variables held constant
sd = second_differences_at(model, data, :education, :income, vcov(model);
                          at=50000,           # Income = $50k
                          profile=(age=40,    # Hold age constant
                                  region=&quot;north&quot;))  # Hold region constant

# Multiple variables across evaluation points
sd = second_differences_at(model, data, [:x1, :x2], :age, vcov(model);
                          at=[30, 45, 60])
# → 2 variables × 3 eval points = 6 rows

# ERROR: Categorical modifier not allowed
sd = second_differences_at(model, data, :income, :region, vcov(model))
# → Error: &quot;Modifier :region must be numeric for second_differences_at()&quot;
# → Use second_differences() instead for categorical moderators</code></pre><p><strong>Variable Type Requirements</strong>:</p><ul><li><strong>Focal variable</strong> (first argument): Can be continuous or categorical<ul><li>Continuous → 1 row per evaluation point</li><li>Categorical → Multiple rows per evaluation point (one per contrast)</li></ul></li><li><strong>Modifier</strong> (second argument): <strong>Must be continuous/numeric</strong><ul><li>Function uses finite differences: modifier ± δ</li><li>For categorical moderators, use <code>second_differences()</code> instead</li></ul></li></ul><p><strong>Statistical Notes</strong>:</p><ul><li>Uses two-point symmetric finite difference: (AME(at + δ) - AME(at - δ)) / (2δ)</li><li>Delta-method SE computed from gradient information</li><li>Choice of δ (via <code>delta</code> parameter) trades off approximation bias vs variance</li></ul><h2 id="Usage-Patterns"><a class="docs-heading-anchor" href="#Usage-Patterns">Usage Patterns</a><a id="Usage-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Patterns" title="Permalink"></a></h2><h3 id="Basic-Workflow"><a class="docs-heading-anchor" href="#Basic-Workflow">Basic Workflow</a><a id="Basic-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Workflow" title="Permalink"></a></h3><p>The standard workflow for computing second differences involves three steps:</p><ol><li>Fit your regression model</li><li>Compute AMEs across modifier levels using <code>population_margins()</code> with scenarios</li><li>Calculate second differences using <code>second_differences()</code></li></ol><pre><code class="language-julia hljs">using Margins, GLM, DataFrames

# Step 1: Fit model with interaction
model = lm(@formula(y ~ x * treated + z), data)

# Step 2: Compute AMEs at both treatment levels
ames = population_margins(model, data;
                         scenarios=(treated=[0, 1],),
                         type=:effects)

# Step 3: Calculate second difference
sd = second_differences(ames, :x, :treated, vcov(model))
DataFrame(sd)</code></pre><p><strong>Output structure</strong>:</p><pre><code class="nohighlight hljs">1×12 DataFrame
 Row │ variable  modifier  contrast    modifier_level1  modifier_level2  second_diff  se        z_stat   p_value   ame_at_level1  ame_at_level2  significant
     │ Symbol    Symbol    String      Int64           Int64            Float64      Float64   Float64  Float64   Float64        Float64        Bool
─────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ x         treated   derivative               0                1       0.152    0.0428    3.55    0.0004          0.298          0.450      true</code></pre><p><strong>Interpretation</strong>: The marginal effect of <code>x</code> is 0.152 units larger when <code>treated=1</code> compared to <code>treated=0</code> (p &lt; 0.001), indicating a significant positive interaction.</p><h3 id="Binary-Moderators"><a class="docs-heading-anchor" href="#Binary-Moderators">Binary Moderators</a><a id="Binary-Moderators-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Moderators" title="Permalink"></a></h3><p>Binary moderators produce a single second difference comparing the two levels.</p><p><strong>Example: Treatment Effect Heterogeneity</strong></p><pre><code class="language-julia hljs"># Does the effect of age vary by treatment status?
model = glm(@formula(outcome ~ age * treated + education),
            data, Binomial(), LogitLink())

ames = population_margins(model, data;
                         scenarios=(treated=[0, 1],),
                         type=:effects)

sd = second_differences(ames, :age, :treated, vcov(model))</code></pre><p><strong>Interpretation contexts</strong>:</p><ul><li><strong>Positive second difference</strong>: Effect is stronger when treated</li><li><strong>Negative second difference</strong>: Effect is weaker when treated</li><li><strong>Near-zero second difference</strong>: Effect is homogeneous across treatment status</li></ul><h3 id="Categorical-Moderators"><a class="docs-heading-anchor" href="#Categorical-Moderators">Categorical Moderators</a><a id="Categorical-Moderators-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Moderators" title="Permalink"></a></h3><p>Categorical moderators with K levels produce K(K-1)/2 pairwise comparisons.</p><p><strong>Example: Education-Specific Effects</strong></p><pre><code class="language-julia hljs"># Does the income effect vary across education levels?
model = lm(@formula(consumption ~ income + education), data)

ames = population_margins(model, data;
                         scenarios=(education=[&quot;hs&quot;, &quot;college&quot;, &quot;grad&quot;],),
                         type=:effects)

sd = second_differences(ames, :income, :education, vcov(model))</code></pre><p><strong>Output structure</strong> (3 education levels → 3 pairwise comparisons):</p><pre><code class="nohighlight hljs">3×12 DataFrame
 Row │ variable  modifier   modifier_level1  modifier_level2  second_diff  se      z_stat  p_value  significant
     │ Symbol    Symbol     String          String           Float64      Float64  Float64  Float64  Bool
─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ income    education  hs              college               0.152    0.042    3.62    0.0003   true
   2 │ income    education  hs              grad                  0.243    0.051    4.76   &lt;1e-5    true
   3 │ income    education  college         grad                  0.091    0.048    1.90    0.058    false</code></pre><p><strong>Interpretation</strong>: The marginal effect of income on consumption is 0.152 units higher for college graduates compared to high school graduates (p &lt; 0.001). The effect continues to increase for graduate degree holders, though the college-to-grad increase (0.091) is not statistically significant.</p><h3 id="Continuous-Moderators"><a class="docs-heading-anchor" href="#Continuous-Moderators">Continuous Moderators</a><a id="Continuous-Moderators-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Moderators" title="Permalink"></a></h3><p>Continuous moderators provide slopes representing the rate of change in marginal effects per unit change in the moderator.</p><p><strong>Example: Age-Varying Treatment Effects</strong></p><pre><code class="language-julia hljs"># How does the treatment effect change with age?
model = lm(@formula(outcome ~ treatment + age), data)

# Evaluate at three age values
ames = population_margins(model, data;
                         scenarios=(age=[30, 45, 60],),
                         type=:effects)

sd = second_differences(ames, :treatment, :age, vcov(model);
                       modifier_type=:continuous)</code></pre><p><strong>Continuous modifier interpretation</strong>:</p><ul><li><code>second_diff</code>: Change in marginal effect per unit increase in moderator</li><li>For age comparison 30→45: slope = (AME₄₅ - AME₃₀) / 15</li><li>Slopes indicate whether effects strengthen (positive) or weaken (negative) with age</li></ul><h3 id="Multiple-Focal-Variables"><a class="docs-heading-anchor" href="#Multiple-Focal-Variables">Multiple Focal Variables</a><a id="Multiple-Focal-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Focal-Variables" title="Permalink"></a></h3><p>Analyze multiple variables simultaneously to compare which effects show strongest moderation.</p><p><strong>Example: Comparative Moderation Analysis</strong></p><pre><code class="language-julia hljs"># Which demographic effects vary most by treatment?
model = lm(@formula(outcome ~ age + education_yrs + experience + treated), data)

ames = population_margins(model, data;
                         scenarios=(treated=[0, 1],),
                         type=:effects,
                         vars=[:age, :education_yrs, :experience])

sd = second_differences(ames, [:age, :education_yrs, :experience],
                       :treated, vcov(model))</code></pre><p><strong>Output structure</strong> (3 variables × 1 binary contrast = 3 rows):</p><pre><code class="nohighlight hljs">3×12 DataFrame
 Row │ variable       modifier  second_diff  se      z_stat  p_value  significant
     │ Symbol         Symbol    Float64      Float64  Float64  Float64  Bool
─────┼────────────────────────────────────────────────────────────────────────
   1 │ age            treated        0.045    0.018    2.50    0.012    true
   2 │ education_yrs  treated        0.123    0.031    3.97   &lt;1e-4    true
   3 │ experience     treated        0.012    0.024    0.50    0.617    false</code></pre><p><strong>Interpretation</strong>: Education effects show the strongest treatment heterogeneity (second diff = 0.123, p &lt; 0.001), followed by age effects (0.045, p = 0.012). Experience effects do not significantly vary by treatment status.</p><h3 id="Categorical-Focal-Variables"><a class="docs-heading-anchor" href="#Categorical-Focal-Variables">Categorical Focal Variables</a><a id="Categorical-Focal-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Focal-Variables" title="Permalink"></a></h3><p>When the focal variable is categorical, second differences can be computed for each contrast.</p><p><strong>Example: Education Contrasts Across Regions</strong></p><pre><code class="language-julia hljs">using CategoricalArrays

# Prepare categorical variable with explicit ordering
data.education = categorical(data.education,
                            levels=[&quot;hs&quot;, &quot;college&quot;, &quot;grad&quot;],
                            ordered=true)

model = lm(@formula(income ~ education + region), data)

# Compute pairwise education contrasts across regions
ames = population_margins(model, data;
                         scenarios=(region=[&quot;north&quot;, &quot;south&quot;, &quot;west&quot;],),
                         type=:effects,
                         vars=[:education])

# Get all education contrasts × all region pairs
sd = second_differences(ames, :education, :region, vcov(model))</code></pre><p><strong>Output dimensions</strong>: If education has 3 levels (→ 3 pairwise contrasts) and region has 3 levels (→ 3 pairwise comparisons), the result contains 3 × 3 = 9 rows representing the full matrix of focal contrasts by modifier comparisons.</p><p><strong>Practical use</strong>: Identify which education gaps (e.g., college - hs) vary most across geographic regions.</p><h3 id="Local-Derivatives-at-Profiles-(second_differences_at())"><a class="docs-heading-anchor" href="#Local-Derivatives-at-Profiles-(second_differences_at())">Local Derivatives at Profiles (<code>second_differences_at()</code>)</a><a id="Local-Derivatives-at-Profiles-(second_differences_at())-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Derivatives-at-Profiles-(second_differences_at())" title="Permalink"></a></h3><p>The profile-based approach computes how marginal effects change continuously with a modifier at specific evaluation points.</p><p><strong>Example: Income Effect Variation Across Age</strong></p><pre><code class="language-julia hljs"># Does the income effect on consumption strengthen or weaken with age?
model = lm(@formula(consumption ~ income * age + education), data)

# Evaluate at mean age
sd = second_differences_at(model, data, :income, :age, vcov(model))
# Interpretation: derivative shows whether income effect increases/decreases per year of age

# Evaluate at multiple age points
sd = second_differences_at(model, data, :income, :age, vcov(model);
                          at=[25, 35, 45, 55, 65])
# → 5 rows showing how income effect changes across life course

# With fixed profile
sd = second_differences_at(model, data, :income, :age, vcov(model);
                          at=40,
                          profile=(education=&quot;college&quot;, region=&quot;urban&quot;))
# → &quot;For urban college graduates, how does income effect vary with age?&quot;</code></pre><p><strong>Key differences from discrete approach</strong>:</p><ul><li><strong>Continuous moderation</strong>: Direct derivative rather than discrete contrasts</li><li><strong>Profile control</strong>: Can hold other variables constant at specific values</li><li><strong>Interpretation</strong>: Per-unit change in moderator rather than level-to-level comparison</li></ul><p><strong>When to use each approach</strong>:</p><table><tr><th style="text-align: right">Approach</th><th style="text-align: right">Use When</th><th style="text-align: right">Modifier Type</th><th style="text-align: right">Example</th></tr><tr><td style="text-align: right"><strong><code>second_differences()</code></strong>&lt;br&gt;(Discrete)</td><td style="text-align: right">Comparing effects across distinct groups</td><td style="text-align: right">Binary or Categorical</td><td style="text-align: right">&quot;Does age effect differ for treated vs control?&quot;</td></tr><tr><td style="text-align: right"><strong><code>second_differences_at()</code></strong>&lt;br&gt;(Local)</td><td style="text-align: right">Understanding continuous variation at specific profiles</td><td style="text-align: right"><strong>Continuous only</strong></td><td style="text-align: right">&quot;At age=40, how does education effect change per 1k income?&quot;</td></tr></table><p><strong>Variable Type Compatibility</strong>:</p><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Focal Variable</th><th style="text-align: right">Modifier Variable</th></tr><tr><td style="text-align: right"><code>second_differences()</code></td><td style="text-align: right">Continuous or Categorical</td><td style="text-align: right">Binary, Categorical, or Continuous</td></tr><tr><td style="text-align: right"><code>second_differences_at()</code></td><td style="text-align: right">Continuous or Categorical</td><td style="text-align: right"><strong>Continuous only</strong></td></tr></table><p><strong>Common error</strong>: Trying to use <code>second_differences_at()</code> with a categorical modifier will produce:</p><pre><code class="nohighlight hljs">Error: Modifier :region must be numeric for second_differences_at()</code></pre><p>Solution: Use <code>second_differences()</code> or <code>second_differences_pairwise()</code> for categorical moderators.</p><h2 id="Advanced-Analysis-Patterns"><a class="docs-heading-anchor" href="#Advanced-Analysis-Patterns">Advanced Analysis Patterns</a><a id="Advanced-Analysis-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Analysis-Patterns" title="Permalink"></a></h2><h3 id="Robust-Standard-Errors"><a class="docs-heading-anchor" href="#Robust-Standard-Errors">Robust Standard Errors</a><a id="Robust-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Standard-Errors" title="Permalink"></a></h3><p>Second differences support robust standard errors through CovarianceMatrices.jl integration.</p><pre><code class="language-julia hljs">using CovarianceMatrices

# Heteroskedasticity-robust second differences
vcov_robust = CovarianceMatrices.HC1(model)
sd = second_differences(ames, :x, :treated, vcov_robust)

# Clustered standard errors
vcov_clustered = CovarianceMatrices.Clustered(model, :firm_id)
sd = second_differences(ames, :x, :treated, vcov_clustered)</code></pre><p>The delta-method computation automatically incorporates the robust covariance structure, ensuring appropriate uncertainty quantification under heteroskedasticity or clustering.</p><h3 id="Multiple-Testing-Considerations"><a class="docs-heading-anchor" href="#Multiple-Testing-Considerations">Multiple Testing Considerations</a><a id="Multiple-Testing-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Testing-Considerations" title="Permalink"></a></h3><p>When computing many pairwise comparisons (categorical moderators with many levels), consider adjusting for multiple testing:</p><pre><code class="language-julia hljs">using MultipleTesting

# Compute all pairwise second differences
sd = second_differences(ames, :x, :education, vcov(model))

# Apply Bonferroni correction
α = 0.05
n_tests = nrow(sd)
sd.significant_bonferroni = sd.p_value .&lt; (α / n_tests)

# Or use false discovery rate control
sd.significant_fdr = adjust(sd.p_value, BenjaminiHochberg()) .&lt; α</code></pre><h3 id="Filtering-to-Specific-Contrasts"><a class="docs-heading-anchor" href="#Filtering-to-Specific-Contrasts">Filtering to Specific Contrasts</a><a id="Filtering-to-Specific-Contrasts-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-to-Specific-Contrasts" title="Permalink"></a></h3><p>For categorical focal variables with many contrasts, focus on specific contrasts of interest:</p><pre><code class="language-julia hljs"># Compute only the &quot;college - hs&quot; contrast across regions
sd = second_differences(ames, :education, :region, vcov(model);
                       contrast=&quot;college - hs&quot;,
                       all_contrasts=false)</code></pre><h3 id="Visualization-Workflows"><a class="docs-heading-anchor" href="#Visualization-Workflows">Visualization Workflows</a><a id="Visualization-Workflows-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-Workflows" title="Permalink"></a></h3><p>Second differences integrate naturally with visualization workflows:</p><pre><code class="language-julia hljs">using StatsPlots

# Plot second differences with confidence intervals
sd_df = DataFrame(sd)
@df sd_df scatter(:modifier_level2, :second_diff,
                  yerr=1.96 .* :se,
                  xlabel=&quot;Modifier Level&quot;,
                  ylabel=&quot;Second Difference&quot;,
                  title=&quot;Effect Heterogeneity Across Moderator&quot;,
                  legend=false)
hline!([0], linestyle=:dash, color=:gray)  # Reference line at zero</code></pre><h2 id="Methodological-Notes"><a class="docs-heading-anchor" href="#Methodological-Notes">Methodological Notes</a><a id="Methodological-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Methodological-Notes" title="Permalink"></a></h2><h3 id="Comparison-to-Coefficient-Based-Interactions"><a class="docs-heading-anchor" href="#Comparison-to-Coefficient-Based-Interactions">Comparison to Coefficient-Based Interactions</a><a id="Comparison-to-Coefficient-Based-Interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-to-Coefficient-Based-Interactions" title="Permalink"></a></h3><p>In linear models, second differences equal interaction coefficients:</p><pre><code class="language-julia hljs"># Linear model: coefficient = second difference
model_linear = lm(@formula(y ~ x * z), data)
interaction_coef = coef(model_linear)[end]  # Coefficient on x:z

ames = population_margins(model_linear, data; scenarios=(z=[0,1],), type=:effects)
sd = second_differences(ames, :x, :z, vcov(model_linear))
# sd.second_diff ≈ interaction_coef (within numerical precision)</code></pre><p>In nonlinear models, they diverge:</p><pre><code class="language-julia hljs"># Logistic model: coefficient ≠ second difference
model_logit = glm(@formula(y ~ x * z), data, Binomial(), LogitLink())
interaction_coef = coef(model_logit)[end]

ames = population_margins(model_logit, data; scenarios=(z=[0,1],), type=:effects)
sd = second_differences(ames, :x, :z, vcov(model_logit))
# sd.second_diff ≠ interaction_coef (second diff is on probability scale)</code></pre><p>This divergence motivates the second differences framework: to express interactions on the interpretable predicted outcome scale rather than the abstract coefficient scale.</p><h3 id="Relationship-to-Ai-and-Norton-(2003)"><a class="docs-heading-anchor" href="#Relationship-to-Ai-and-Norton-(2003)">Relationship to Ai &amp; Norton (2003)</a><a id="Relationship-to-Ai-and-Norton-(2003)-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship-to-Ai-and-Norton-(2003)" title="Permalink"></a></h3><p>Ai &amp; Norton (2003) demonstrated that in nonlinear models (logit, probit), the interaction effect:</p><ol><li>Is not equal to the interaction coefficient</li><li>Varies across observations</li><li>Can have different signs than the coefficient</li></ol><p>Second differences in Margins.jl operationalize the Ai &amp; Norton framework by:</p><ul><li>Computing population-averaged interaction effects (second differences from AMEs)</li><li>Providing proper standard errors via delta method</li><li>Enabling hypothesis tests for interaction significance</li></ul><p><strong>Reference</strong>: Ai, C., &amp; Norton, E. C. (2003). Interaction terms in logit and probit models. <em>Economics Letters</em>, 80(1), 123-129.</p><h3 id="Population-vs-Profile-Interpretation"><a class="docs-heading-anchor" href="#Population-vs-Profile-Interpretation">Population vs Profile Interpretation</a><a id="Population-vs-Profile-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Population-vs-Profile-Interpretation" title="Permalink"></a></h3><p>Current second differences use <strong>population-averaged</strong> marginal effects:</p><ul><li>AMEs computed by averaging over the sample distribution at each modifier level</li><li>Second differences reflect population-level interaction effects</li><li>Appropriate for policy analysis requiring external validity</li></ul><p><strong>Future extension</strong> (<code>second_differences_at()</code>): Profile-based local derivatives</p><ul><li>Evaluate interaction effects at specific covariate combinations</li><li>Useful for scenario-specific analysis or representative case interpretation</li></ul><h3 id="Significance-Testing"><a class="docs-heading-anchor" href="#Significance-Testing">Significance Testing</a><a id="Significance-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Significance-Testing" title="Permalink"></a></h3><p>Hypothesis tests evaluate H₀: second difference = 0 (no interaction on predicted scale).</p><p><strong>Important distinction</strong>:</p><ul><li>Significant second difference → interaction exists on predicted outcome scale</li><li>Significant interaction coefficient → interaction exists on coefficient scale</li></ul><p>In nonlinear models, these are distinct hypotheses. Second differences test the hypothesis most relevant for applied interpretation.</p><h2 id="Integration-Examples"><a class="docs-heading-anchor" href="#Integration-Examples">Integration Examples</a><a id="Integration-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Examples" title="Permalink"></a></h2><h3 id="With-GLM.jl-Ecosystem"><a class="docs-heading-anchor" href="#With-GLM.jl-Ecosystem">With GLM.jl Ecosystem</a><a id="With-GLM.jl-Ecosystem-1"></a><a class="docs-heading-anchor-permalink" href="#With-GLM.jl-Ecosystem" title="Permalink"></a></h3><pre><code class="language-julia hljs">using GLM, CategoricalArrays

# Logistic regression with interaction
model = glm(@formula(employed ~ education * experience + age),
            data, Binomial(), LogitLink())

# Second differences on probability scale
ames = population_margins(model, data;
                         scenarios=(experience=[0, 10, 20],),
                         type=:effects,
                         scale=:response)  # Probability scale

sd = second_differences(ames, :education, :experience, vcov(model);
                       modifier_type=:continuous)
# Interpretation: change in employment effect of education per year of experience</code></pre><h3 id="With-MixedModels.jl"><a class="docs-heading-anchor" href="#With-MixedModels.jl">With MixedModels.jl</a><a id="With-MixedModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#With-MixedModels.jl" title="Permalink"></a></h3><p>Second differences support mixed-effects models for clustered/hierarchical data:</p><pre><code class="language-julia hljs">using MixedModels

# Linear mixed model with interaction
model = fit(MixedModel,
           @formula(outcome ~ treatment * time + (1 + time | subject)),
           data)

ames = population_margins(model, data;
                         scenarios=(time=[0, 6, 12],),
                         type=:effects)

sd = second_differences(ames, :treatment, :time, vcov(model);
                       modifier_type=:continuous)
# Interpretation: change in treatment effect over time (time-varying treatment effect)</code></pre><h3 id="With-DataFrames-Ecosystem"><a class="docs-heading-anchor" href="#With-DataFrames-Ecosystem">With DataFrames Ecosystem</a><a id="With-DataFrames-Ecosystem-1"></a><a class="docs-heading-anchor-permalink" href="#With-DataFrames-Ecosystem" title="Permalink"></a></h3><pre><code class="language-julia hljs">using DataFrames, Chain, CSV

# Complete analysis pipeline
results = @chain begin
    population_margins(model, data; scenarios=(region=[&quot;north&quot;,&quot;south&quot;,&quot;west&quot;],), type=:effects)
    second_differences(_, :income, :region, vcov(model))
    DataFrame(_)
    subset(_, :significant =&gt; x -&gt; x .== true)  # Filter to significant interactions
    sort(_, :second_diff, rev=true)  # Sort by effect size
end

# Export for reporting
CSV.write(&quot;significant_interactions.csv&quot;, results)</code></pre><h2 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h2><h3 id="Common-Error-Patterns"><a class="docs-heading-anchor" href="#Common-Error-Patterns">Common Error Patterns</a><a id="Common-Error-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Error-Patterns" title="Permalink"></a></h3><p><strong>Insufficient modifier levels</strong>:</p><pre><code class="language-julia hljs"># Error: only one modifier level
ames = population_margins(model, data; scenarios=(treated=[1],), type=:effects)
second_differences(ames, :x, :treated, vcov(model))
# → Error: &quot;Need at least 2 modifier levels&quot;</code></pre><p><strong>Solution</strong>: Ensure scenarios include at least 2 modifier levels.</p><p><strong>Missing variable in AME result</strong>:</p><pre><code class="language-julia hljs"># Error: variable not in AME computation
ames = population_margins(model, data; scenarios=(treated=[0,1],),
                         type=:effects, vars=[:x])
second_differences(ames, :z, :treated, vcov(model))
# → Error: No rows found for variable z</code></pre><p><strong>Solution</strong>: Include the focal variable in the original <code>population_margins()</code> call or omit <code>vars</code> parameter to include all continuous variables.</p><p><strong>Dimension mismatch</strong>:</p><pre><code class="language-julia hljs"># Error: vcov dimensions don&#39;t match gradient dimensions
wrong_vcov = vcov(different_model)
second_differences(ames, :x, :treated, wrong_vcov)
# → Error: &quot;Dimension mismatch: vcov has N parameters but gradients has M&quot;</code></pre><p><strong>Solution</strong>: Ensure vcov comes from the same model used to compute AMEs.</p><h3 id="Validation-Workflow"><a class="docs-heading-anchor" href="#Validation-Workflow">Validation Workflow</a><a id="Validation-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Validation-Workflow" title="Permalink"></a></h3><pre><code class="language-julia hljs">function validate_second_differences(sd_result::DataFrame)
    # Check for numerical issues
    if any(isnan.(sd_result.second_diff)) || any(isinf.(sd_result.second_diff))
        @warn &quot;NaN or Inf values detected in second differences&quot;
    end

    # Check for zero standard errors (indicates no interaction)
    zero_se = sum(sd_result.se .≈ 0.0)
    if zero_se &gt; 0
        @info &quot;$zero_se second difference(s) have zero SE (likely no interaction)&quot;
    end

    # Summary statistics
    n_significant = sum(sd_result.significant)
    println(&quot;Significant interactions: $n_significant / $(nrow(sd_result))&quot;)
    println(&quot;Mean absolute second difference: $(mean(abs.(sd_result.second_diff)))&quot;)

    return sd_result
end

# Usage
sd = second_differences(ames, :x, :treated, vcov(model))
validated_sd = validate_second_differences(DataFrame(sd))</code></pre><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><h3 id="Computational-Complexity"><a class="docs-heading-anchor" href="#Computational-Complexity">Computational Complexity</a><a id="Computational-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Complexity" title="Permalink"></a></h3><p>Second differences computation is extremely efficient:</p><ul><li><strong>Primary cost</strong>: Computing the underlying AMEs via <code>population_margins()</code></li><li><strong>Second differences calculation</strong>: Negligible additional cost (vector operations only)</li><li><strong>Scalability</strong>: O(1) with respect to number of pairwise comparisons</li></ul><pre><code class="language-julia hljs"># Performance example
@time ames = population_margins(model, large_data;
                                scenarios=(education=levels,),
                                type=:effects)
# → 95% of total computation time

@time sd = second_differences(ames, :income, :education, vcov(model))
# → &lt;5% of total time, even with many pairwise comparisons</code></pre><h3 id="Memory-Efficiency"><a class="docs-heading-anchor" href="#Memory-Efficiency">Memory Efficiency</a><a id="Memory-Efficiency-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Efficiency" title="Permalink"></a></h3><p>Second differences leverage the gradient information already stored in <code>EffectsResult</code>:</p><ul><li>No additional model evaluations required</li><li>No dataset traversal</li><li>Minimal additional allocations</li></ul><p>For large-scale applications with many moderator levels, the computational bottleneck remains the AME computation, not the second differences calculation.</p><h2 id="Literature-and-References"><a class="docs-heading-anchor" href="#Literature-and-References">Literature and References</a><a id="Literature-and-References-1"></a><a class="docs-heading-anchor-permalink" href="#Literature-and-References" title="Permalink"></a></h2><h3 id="Key-Methodological-Papers"><a class="docs-heading-anchor" href="#Key-Methodological-Papers">Key Methodological Papers</a><a id="Key-Methodological-Papers-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Methodological-Papers" title="Permalink"></a></h3><ol><li><p><strong>Ai, C., &amp; Norton, E. C. (2003)</strong>. Interaction terms in logit and probit models. <em>Economics Letters</em>, 80(1), 123-129.</p><ul><li>Seminal paper demonstrating problems with interpreting interaction coefficients in nonlinear models</li><li>Established need for marginal effects-based interaction analysis</li></ul></li><li><p><strong>Norton, E. C., Wang, H., &amp; Ai, C. (2004)</strong>. Computing interaction effects and standard errors in logit and probit models. <em>The Stata Journal</em>, 4(2), 154-167.</p><ul><li>Practical implementation guidance</li><li>Standard error computation for interaction effects</li></ul></li><li><p><strong>Greene, W. H. (2010)</strong>. Testing hypotheses about interaction terms in nonlinear models. <em>Economics Letters</em>, 107(2), 291-296.</p><ul><li>Hypothesis testing framework for interactions</li><li>Multiple comparison considerations</li></ul></li><li><p><strong>Karaca-Mandic, P., Norton, E. C., &amp; Dowd, B. (2012)</strong>. Interaction terms in nonlinear models. <em>Health Services Research</em>, 47(1pt1), 255-274.</p><ul><li>Applied examples in health economics</li><li>Interpretation guidance for practitioners</li></ul></li></ol><h3 id="Software-Implementation-References"><a class="docs-heading-anchor" href="#Software-Implementation-References">Software Implementation References</a><a id="Software-Implementation-References-1"></a><a class="docs-heading-anchor-permalink" href="#Software-Implementation-References" title="Permalink"></a></h3><ul><li><strong>Stata</strong>: <code>margins</code> command with <code>dydx()</code> operator and <code>at()</code> option</li><li><strong>R</strong>: <code>margins</code> package (Leeper et al.) and <code>interactionTest</code> package</li><li><strong>Python</strong>: <code>statsmodels.discrete.discrete_model.Logit.get_margeff()</code> with <code>at</code> specification</li></ul><p>Margins.jl&#39;s second differences implementation follows this established methodological tradition while leveraging Julia&#39;s high-performance computational capabilities for efficient large-scale analysis.</p><hr/><p><em>This documentation provides comprehensive coverage of second differences functionality in Margins.jl. For the underlying marginal effects framework, see <a href="../mathematical_foundation/">Mathematical Foundation</a>. For population-based analysis that produces the AME inputs, see <a href="../population_scenarios/">Population Scenarios</a>. For integration with robust standard errors, see <a href="../advanced/">Advanced Features</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../population_scenarios/">« Population Scenarios</a><a class="docs-footer-nextpage" href="../weights/">Weights »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 13 November 2025 01:38">Thursday 13 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
