var documenterSearchIndex = {"docs":
[{"location":"mathematical_foundation/#Mathematical-Foundation","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Theoretical exposition of the analytical framework underlying marginal effects analysis","category":"page"},{"location":"mathematical_foundation/#Unified-Framework-for-Marginal-Effects-Analysis","page":"Mathematical Foundation","title":"Unified Framework for Marginal Effects Analysis","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The theoretical foundation of marginal effects analysis rests upon a systematic decomposition of the inferential problem into two fundamental analytical dimensions. This framework addresses the terminological inconsistencies that have historically impeded methodological clarity across econometric and statistical disciplines through the establishment of a unified conceptual structure.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The analytical framework distinguishes between two orthogonal methodological choices that completely characterize the space of marginal effects approaches. The evaluation context determines whether inference targets population-level parameters or profile-specific estimates, while the analytical target specifies whether the quantity of interest represents marginal effects or adjusted predictions.","category":"page"},{"location":"mathematical_foundation/#Complete-Methodological-Taxonomy","page":"Mathematical Foundation","title":"Complete Methodological Taxonomy","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":" Effects Analysis Predictions Analysis\nProfile Context Marginal Effects at Representative Scenarios Adjusted Predictions at Representative Scenarios\nPopulation Context Average Marginal Effects Average Adjusted Predictions","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This taxonomic structure eliminates the ambiguity inherent in discipline-specific terminological conventions while preserving the essential methodological distinctions that govern appropriate analytical application.","category":"page"},{"location":"mathematical_foundation/#Cross-Disciplinary-Terminological-Unification","page":"Mathematical Foundation","title":"Cross-Disciplinary Terminological Unification","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The proposed framework establishes a systematic correspondence between the established terminology employed across econometric, biostatistical, and computational disciplines. This mapping preserves the essential methodological content while eliminating the terminological inconsistencies that have impeded interdisciplinary communication and methodological clarity.","category":"page"},{"location":"mathematical_foundation/#Profile-Context-Methodologies","page":"Mathematical Foundation","title":"Profile Context Methodologies","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The profile evaluation context encompasses analytical approaches that evaluate marginal quantities at representative or theoretically motivated points in the covariate space. Traditional terminological variants include Marginal Effects at the Mean and Adjusted Predictions at the Mean, which are unified under the profile effects and profile predictions categories respectively.","category":"page"},{"location":"mathematical_foundation/#Population-Context-Methodologies","page":"Mathematical Foundation","title":"Population Context Methodologies","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The population evaluation context encompasses approaches that compute marginal quantities averaged across the empirical distribution of observed covariates. This category unifies Average Marginal Effects, Average Partial Effects, and related population-averaged measures under a coherent methodological framework that emphasizes the distributional basis of the inference.","category":"page"},{"location":"mathematical_foundation/#Formal-Mathematical-Specification","page":"Mathematical Foundation","title":"Formal Mathematical Specification","text":"","category":"section"},{"location":"mathematical_foundation/#Marginal-Effects-and-Adjusted-Predictions","page":"Mathematical Foundation","title":"Marginal Effects and Adjusted Predictions","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Conceptual Foundation: Marginal effects quantify the expected change in an outcome variable resulting from a unit change in an explanatory variable, holding all other variables constant. This fundamental concept addresses the analytical question \"How does the dependent variable respond to marginal changes in specific covariates?\" The formal mathematical representation ∂E[Y|X]/∂X captures the instantaneous rate of change in the conditional expectation, providing a rigorous framework for quantifying covariate effects.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Marginal effects analysis concerns the derivative of the conditional expectation function with respect to the covariates of interest. For continuous covariates, this quantity is formally defined as ∂E[Y|X]/∂X, representing the instantaneous rate of change in the expected outcome with respect to marginal changes in the explanatory variable. The interpretation centers on the magnitude of response in the dependent variable per unit increase in the independent variable, with measurement units corresponding to the dependent variable scaled by the units of the explanatory variable.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Adjusted predictions represent the conditional expectation E[Y|X] evaluated at specified covariate configurations. This quantity provides the expected value of the outcome variable conditional on particular covariate realizations, maintaining the same units as the dependent variable. The analytical focus shifts from rates of change to levels of the outcome under specific conditioning scenarios.","category":"page"},{"location":"mathematical_foundation/#Evaluation-Context-Specifications","page":"Mathematical Foundation","title":"Evaluation Context Specifications","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Analytical Perspective: The choice between profile and population approaches reflects two different ways to approach marginal effects analysis. Profile analysis examines effects for representative individuals or scenarios (analogous to asking \"What happens for a typical 35-year-old college graduate?\"), while population analysis characterizes average effects across the entire sample distribution (analogous to asking \"What happens on average across all individuals in our dataset?\"). This distinction determines both the interpretive scope and the computational approach of the marginal effects analysis.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile approaches evaluate marginal quantities at predetermined points in the covariate space, most commonly at sample means X̄ or at theoretically motivated scenario specifications. This approach yields concrete, interpretable estimates for specific covariate combinations, facilitating clear communication of results and policy implications for particular demographic or economic profiles. The limitation lies in the potential lack of representativeness relative to the broader population distribution.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Population approaches compute marginal quantities averaged across the empirical distribution of observed covariates, weighting each observation according to its sample frequency. This methodology yields population-averaged parameters that reflect the heterogeneity present in the data generating process, providing estimates that characterize the broader population represented by the sample. The limitation concerns the potential difficulty in interpreting results that may not correspond to any particular individual or realistic scenario within the population.","category":"page"},{"location":"mathematical_foundation/#Methodological-Inconsistencies-Across-Disciplines","page":"Mathematical Foundation","title":"Methodological Inconsistencies Across Disciplines","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Why This Matters for Users: Different fields use related but slightly different terminology:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Economics: \"Average Marginal Effects\" (AME) - mean of individual-level derivatives\nBiostatistics: \"Average Partial Effects\" (APE) - often equivalent to AME, with some nuance for discrete variables\nMachine Learning: \"Partial Dependence\" - conceptually similar, typically in visualization contexts","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"While these concepts overlap substantially, each field may have specific conventions for handling categorical variables or estimation approaches. This package provides a unified framework that works consistently across disciplines.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The absence of standardized terminological conventions across quantitative disciplines has generated substantial methodological confusion that impedes both theoretical development and practical implementation. This inconsistency manifests through the use of discipline-specific acronyms and conceptual frameworks that obscure the underlying mathematical equivalence of analytical approaches.","category":"page"},{"location":"mathematical_foundation/#Disciplinary-Terminological-Variations","page":"Mathematical Foundation","title":"Disciplinary Terminological Variations","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Economics employs Marginal Effects at the Mean and Average Marginal Effects as primary analytical categories, while biostatistics utilizes Average Partial Effects to denote methodologically identical procedures. Machine learning contexts frequently employ \"partial effects\" as an umbrella term that may conflate distinct analytical approaches including SHAP values and traditional marginal effects. Statistical software packages compound these inconsistencies through accommodation of diverse terminological preferences across user communities.","category":"page"},{"location":"mathematical_foundation/#Fundamental-Methodological-Impediments","page":"Mathematical Foundation","title":"Fundamental Methodological Impediments","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The proliferation of terminological variants generates several significant barriers to methodological advancement. Identical analytical concepts receive different nomenclature across disciplines, while the same terminological constructs may denote different methodological approaches in alternative contexts. The distinction between predictions and effects becomes obscured through inconsistent usage patterns, and the conceptual difference between evaluation at representative points versus population averaging receives inadequate attention.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"These inconsistencies hamper reproducibility across research contexts, create unnecessary learning barriers for practitioners attempting to apply methods across disciplines, and impede productive interdisciplinary collaboration through the introduction of artificial communication barriers.","category":"page"},{"location":"mathematical_foundation/#Statistical-vs-Causal-Interpretation","page":"Mathematical Foundation","title":"Statistical vs Causal Interpretation","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Statistical vs Causal Interpretation: The same marginal effects computation supports both descriptive and causal analysis:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Descriptive: \"In our sample, education is associated with higher wages\" \nCausal: \"Education causes higher wages\" (requires identifying assumptions)","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The package provides statistically valid estimates; interpretation depends on research design and identifying assumptions.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The 2×2 framework applies equally to both descriptive and causal analysis. The mathematical operations are identical, but the interpretation differs:","category":"page"},{"location":"mathematical_foundation/#Descriptive-Interpretation-(Always-Valid)","page":"Mathematical Foundation","title":"Descriptive Interpretation (Always Valid)","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Question: \"How does Y vary with X in the observed data?\"\nRequirements: Only requires correct model specification\nExample: \"In our sample, each additional year of education is associated with 8% higher wages\"","category":"page"},{"location":"mathematical_foundation/#Causal-Interpretation-(Requires-Additional-Assumptions)","page":"Mathematical Foundation","title":"Causal Interpretation (Requires Additional Assumptions)","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Question: \"What would happen to Y if we intervened to change X?\"\nRequirements: Exogeneity, correct functional form, no omitted variables, etc.\nExample: \"Increasing education by one year would cause 8% higher wages\"","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Important: The choice of profile vs population is orthogonal to causal identification. Both MEM and AME can be interpreted causally or descriptively, depending on research design.","category":"page"},{"location":"mathematical_foundation/#When-Profile-Population","page":"Mathematical Foundation","title":"When Profile ≠ Population","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The choice between profile and population approaches matters most when the link function is non-identity:","category":"page"},{"location":"mathematical_foundation/#Linear-Models-with-Identity-Link","page":"Mathematical Foundation","title":"Linear Models with Identity Link","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile = Population: MEM = AME for effects (predictions differ only by constants)\nPractical implication: Choice mainly affects interpretation, not numerical results","category":"page"},{"location":"mathematical_foundation/#GLMs-with-Non-Identity-Links","page":"Mathematical Foundation","title":"GLMs with Non-Identity Links","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile ≠ Population: All quantities can differ substantially\nWith interactions: Profile vs Population can yield opposite conclusions  \nHeterogeneous samples: Larger differences between approaches","category":"page"},{"location":"mathematical_foundation/#Example:-Logistic-Regression","page":"Mathematical Foundation","title":"Example: Logistic Regression","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Consider education effects on probability of employment in a logistic model:","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile (MEM): \"For someone with average characteristics, +1 year education → +0.08 probability of employment\"\nPopulation (AME): \"On average across the sample, +1 year education → +0.05 probability of employment\"","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The difference arises because the logistic function is nonlinear, so the derivative at the mean differs from the mean of derivatives.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For the computational implications of this choice, see Computational Architecture and Performance Guide.","category":"page"},{"location":"mathematical_foundation/#Elasticities-and-Semi-Elasticities","page":"Mathematical Foundation","title":"Elasticities and Semi-Elasticities","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Elasticities are transformations of marginal effects that follow the same 2×2 framework:","category":"page"},{"location":"mathematical_foundation/#Definitions","page":"Mathematical Foundation","title":"Definitions","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Elasticity: % change in Y per % change in X = (∂Y/∂X) × (X/Y)\nSemi-elasticity (X): % change in Y per unit change in X = (∂Y/∂X) × (1/Y)  \nSemi-elasticity (Y): Unit change in Y per % change in X = (∂Y/∂X) × X","category":"page"},{"location":"mathematical_foundation/#Framework-Application","page":"Mathematical Foundation","title":"Framework Application","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile elasticities: Calculate (∂Y/∂X) × (X̄/Ȳ) at representative values\nPopulation elasticities: Average (∂Y/∂X) × (Xᵢ/Yᵢ) across sample observations","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"In GLMs with non-identity links, profile elasticity ≠ average elasticity, following the same logic as marginal effects.","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"For detailed elasticity examples and applications to policy analysis, see Advanced Features.","category":"page"},{"location":"mathematical_foundation/#Implementation-in-Margins.jl","page":"Mathematical Foundation","title":"Implementation in Margins.jl","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"The package implements this framework through two main functions:","category":"page"},{"location":"mathematical_foundation/#population_margins()","page":"Mathematical Foundation","title":"population_margins()","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Computes population-level analysis (AME/AAP equivalent):","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"# Population average marginal effects\npopulation_margins(model, data; type=:effects)\n\n# Population average predictions  \npopulation_margins(model, data; type=:predictions)\n\n# Population average elasticities\npopulation_margins(model, data; type=:effects, measure=:elasticity)","category":"page"},{"location":"mathematical_foundation/#profile_margins()","page":"Mathematical Foundation","title":"profile_margins()","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Computes profile analysis (MEM/APM equivalent):","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"# Effects at sample means\nprofile_margins(model, data, means_grid(data); type=:effects)\n\n# Effects at specific scenarios\nage_grid = cartesian_grid(age=[25, 45, 65])\nprofile_margins(model, data, age_grid; type=:effects)\n\n# Predictions at representative points\nprofile_margins(model, data, means_grid(data); type=:predictions)","category":"page"},{"location":"mathematical_foundation/#Practical-Guidelines","page":"Mathematical Foundation","title":"Practical Guidelines","text":"","category":"section"},{"location":"mathematical_foundation/#Choose-Profile-When:","page":"Mathematical Foundation","title":"Choose Profile When:","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Understanding specific, concrete scenarios\nCommunicating results to non-technical audiences  \nSample is relatively homogeneous\nPolicy targets specific demographic profiles","category":"page"},{"location":"mathematical_foundation/#Choose-Population-When:","page":"Mathematical Foundation","title":"Choose Population When:","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Estimating true population parameters\nHeterogeneity across sample is important\nBroad policy applications affecting diverse groups\nExternal validity to similar populations is goal","category":"page"},{"location":"mathematical_foundation/#The-Trade-off","page":"Mathematical Foundation","title":"The Trade-off","text":"","category":"section"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"Profile approaches: More concrete and interpretable, but may not represent population\nPopulation approaches: True average effects, but may not describe any individual well","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"","category":"page"},{"location":"mathematical_foundation/","page":"Mathematical Foundation","title":"Mathematical Foundation","text":"This mathematical foundation anchors all marginal analysis in Margins.jl. For implementation details, see API Reference. For computational architecture and performance implications, see Computational Architecture and Performance Guide. For advanced applications including elasticities and robust inference, see Advanced Features.","category":"page"},{"location":"backend_selection/#Backend-Selection-Guide","page":"Backend Selection","title":"Backend Selection Guide","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Choosing between AD and FD backends for optimal reliability and performance","category":"page"},{"location":"backend_selection/#Overview","page":"Backend Selection","title":"Overview","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Margins.jl offers two computational backends for derivative calculation, each optimized for different use cases:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":":ad (Automatic Differentiation) - Zero allocation, higher reliability, handles domain-sensitive functions\n:fd (Finite Differences) - Zero allocation, efficient for simple formulas","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"N.B.: For the most part, Finite Differences essentially has legacy status at this point, developed before efficient AD was implemented. The AD backend now provides superior performance, reliability, and maintains zero allocation.","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Summary: Use :ad for most applications. Zero allocation with comprehensive type support and robust domain handling.","category":"page"},{"location":"backend_selection/#Quick-Decision-Tree","page":"Backend Selection","title":"Quick Decision Tree","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"For most applications:\n└── Use backend=:ad (recommended default)\n    ├── Zero allocation performance\n    ├── Machine precision accuracy\n    ├── All numeric types supported\n    └── Robust domain handling\n\nUse backend=:fd for:\n├── Specific compatibility requirements\n└── Simple linear formulas","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"The AD backend supports all integer types (Int8, Int16, UInt32, etc.) with zero allocation performance.","category":"page"},{"location":"backend_selection/#Critical-Reliability-Differences","page":"Backend Selection","title":"Critical Reliability Differences","text":"","category":"section"},{"location":"backend_selection/#**Domain-Sensitive-Functions:-Always-Use-AD**","page":"Backend Selection","title":"Domain-Sensitive Functions: Always Use AD","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Functions that require backend=:ad:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Log transformations - FD can push values below zero\nmodel = lm(@formula(y ~ log(x)), data)\npopulation_margins(model, data; backend=:ad)  # Required\n\n# Square root functions - FD can push values negative  \nmodel = lm(@formula(y ~ sqrt(x)), data)  \npopulation_margins(model, data; backend=:ad)  # Required\n\n# Inverse functions near zero - FD can create division issues\nmodel = lm(@formula(y ~ 1/x), data)\npopulation_margins(model, data; backend=:ad)  # Recommended\n\n# Fractional powers - Similar domain sensitivity as sqrt\nmodel = lm(@formula(y ~ x^(1/3)), data)\npopulation_margins(model, data; backend=:ad)  # Recommended","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Why FD fails: Finite difference computation f(x+h) - f(x) can push arguments outside valid domains:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"log(x+h) where x+h < 0 → DomainError  \nsqrt(x+h) where x+h < 0 → DomainError\n1/(x+h) where x+h ≈ 0 → numerical instability","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Why AD succeeds: Automatic differentiation computes exact derivatives without domain-violating function evaluations.","category":"page"},{"location":"backend_selection/#**Functions-Safe-for-Either-Backend**","page":"Backend Selection","title":"Functions Safe for Either Backend","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Linear relationships - both backends equivalent\nmodel = lm(@formula(y ~ x + z), data)  \npopulation_margins(model, data; backend=:fd)   # Efficient performance\npopulation_margins(model, data; backend=:ad)   # Equivalent results\n\n# Polynomial functions - both work well\nmodel = lm(@formula(y ~ x + x^2), data)\npopulation_margins(model, data; backend=:fd)   # Choose based on performance needs\npopulation_margins(model, data; backend=:ad)   # Same statistical results\n\n# Simple transformations - no domain issues\nmodel = lm(@formula(y ~ x/10 + z*2), data)\npopulation_margins(model, data; backend=:fd)   # Zero allocation","category":"page"},{"location":"backend_selection/#Performance-Characteristics","page":"Backend Selection","title":"Performance Characteristics","text":"","category":"section"},{"location":"backend_selection/#Memory-Usage-Analysis","page":"Backend Selection","title":"Memory Usage Analysis","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Both backends now achieve zero allocation performance:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# FD: Zero allocation after warmup\n@allocated population_margins(model, data_100; backend=:fd)    # 0 bytes\n@allocated population_margins(model, data_1000; backend=:fd)   # 0 bytes  \n@allocated population_margins(model, data_5000; backend=:fd)   # 0 bytes\n\n# AD: Zero allocation after warmup\n@allocated population_margins(model, data_100; backend=:ad)    # 0 bytes\n@allocated population_margins(model, data_1000; backend=:ad)   # 0 bytes\n@allocated population_margins(model, data_5000; backend=:ad)   # 0 bytes","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Memory Usage Decision:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"All dataset sizes: Both backends achieve zero allocation performance\nChoice based on reliability and accuracy: AD provides superior domain handling\nConstruction cost: AD requires slightly more memory during evaluator setup (amortized over many evaluations)","category":"page"},{"location":"backend_selection/#Speed-Performance","page":"Backend Selection","title":"Speed Performance","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Both backends achieve excellent performance, with AD providing 3-5x improvements:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Typical performance ranges (varies by system and model complexity)\n# Small problems (n=100-1000)  \n@btime population_margins($model, $data; backend=:fd)  # 0.1-10ms (baseline)\n@btime population_margins($model, $data; backend=:ad)  # 0.05-5ms (3-5x faster!)\n\n# Large problems (n=10000+)\n@btime population_margins($model, $large_data; backend=:fd)  # Scales linearly with n\n@btime population_margins($model, $large_data; backend=:ad)  # Scales linearly, but with better constant factors","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Key insight: With zero-allocation AD, the performance differences now favor AD in most cases, while maintaining superior numerical properties.","category":"page"},{"location":"backend_selection/#Numerical-Accuracy","page":"Backend Selection","title":"Numerical Accuracy","text":"","category":"section"},{"location":"backend_selection/#Both-Backends-Provide-Equivalent-Accuracy","page":"Backend Selection","title":"Both Backends Provide Equivalent Accuracy","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"For well-conditioned problems, both backends produce statistically equivalent results:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Linear models - identical to machine precision\nfd_result = population_margins(model, data; backend=:fd)\nad_result = population_margins(model, data; backend=:ad)\n\nDataFrame(fd_result).estimate ≈ DataFrame(ad_result).estimate  # rtol=1e-12 PASS\n\n# GLM models - equivalent within appropriate tolerances  \nfd_glm = population_margins(glm_model, data; backend=:fd)\nad_glm = population_margins(glm_model, data; backend=:ad)\n\nDataFrame(fd_glm).estimate ≈ DataFrame(ad_glm).estimate  # rtol=1e-10 PASS","category":"page"},{"location":"backend_selection/#AD-May-Be-More-Accurate-For","page":"Backend Selection","title":"AD May Be More Accurate For","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Complex function compositions\nFunctions with steep gradients  \nNear-boundary evaluations\nModels with numerical conditioning issues","category":"page"},{"location":"backend_selection/#Production-Recommendations","page":"Backend Selection","title":"Production Recommendations","text":"","category":"section"},{"location":"backend_selection/#Backend-Selection-Policy","page":"Backend Selection","title":"Backend Selection Policy","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"No :auto mode is provided.\nNo implicit backend fallbacks are performed.\nSelect backend explicitly. Use :ad by default; use :fd only when explicitly intended and theoretically safe.","category":"page"},{"location":"backend_selection/#Backend-Selection-by-Use-Case","page":"Backend Selection","title":"Backend Selection by Use Case","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Use Case Backend Rationale\nDomain-sensitive functions :ad Required for log(), sqrt(), 1/x\nGeneral production workflows :ad Zero allocation + higher reliability + faster\nLarge datasets (>10k) :ad Zero allocation + superior performance\nMemory-constrained systems Either Both achieve zero allocation\nDevelopment/testing :ad Higher reliability, now zero allocation\nHigh-precision requirements :ad Machine precision + zero allocation\nSimple linear formulas :fd May be slightly faster for basic operations","category":"page"},{"location":"backend_selection/#Production-Configuration-Guidance","page":"Backend Selection","title":"Production Configuration Guidance","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Default to backend=:ad for reliability and accuracy (also zero allocation).\nUse backend=:fd only for simple, well-conditioned formulas and when you explicitly want FD.\nFor domain-sensitive functions (log, sqrt, 1/x near 0), always use :ad.","category":"page"},{"location":"backend_selection/#Troubleshooting-Backend-Issues","page":"Backend Selection","title":"Troubleshooting Backend Issues","text":"","category":"section"},{"location":"backend_selection/#Common-Error-Patterns","page":"Backend Selection","title":"Common Error Patterns","text":"","category":"section"},{"location":"backend_selection/#DomainError-with-FD-Backend","page":"Backend Selection","title":"DomainError with FD Backend","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Error: DomainError with -1.23e-6: log was called with a negative real number\nresult = population_margins(model, data; backend=:fd)  #  Fails\n\n# Solution: Use AD backend for log functions\nresult = population_margins(model, data; backend=:ad)  # Works","category":"page"},{"location":"backend_selection/#Memory-Pressure-with-AD-Backend","page":"Backend Selection","title":"Memory Pressure with AD Backend","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Large dataset causing memory issues with AD\nhuge_result = population_margins(model, huge_data; backend=:ad)  # May run out of memory\n\n# Solution: Use FD backend for memory efficiency\nhuge_result = population_margins(model, huge_data; backend=:fd)  # Constant memory","category":"page"},{"location":"backend_selection/#Backend-Validation-Testing","page":"Backend Selection","title":"Backend Validation Testing","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Test both backends for new functions\nfunction test_backend_compatibility(model, data)\n    try_fd = try population_margins(model, data; backend=:fd) catch nothing end\n    try_ad = try population_margins(model, data; backend=:ad) catch nothing end\n    \n    if try_fd === nothing && try_ad !== nothing\n        @warn \"Function requires AD backend - FD fails with domain error\"\n        return :ad_required\n    elseif try_fd !== nothing && try_ad !== nothing\n        # Compare results for consistency\n        fd_est = DataFrame(try_fd).estimate\n        ad_est = DataFrame(try_ad).estimate\n        \n        if fd_est ≈ ad_est rtol=1e-10\n            @info \"Both backends produce consistent results\"\n            return :either_ok\n        else\n            @warn \"Backends produce different results - investigate numerical issues\"\n            return :inconsistent\n        end\n    else\n        @error \"Both backends failed\"\n        return :both_failed\n    end\nend\n\n# Usage\ncompatibility = test_backend_compatibility(model, data)","category":"page"},{"location":"backend_selection/#Advanced-Topics","page":"Backend Selection","title":"Advanced Topics","text":"","category":"section"},{"location":"backend_selection/#FormulaCompiler-Integration","page":"Backend Selection","title":"FormulaCompiler Integration","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Both backends leverage FormulaCompiler.jl's optimized evaluation:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# FD: Uses finite difference approximation with compiled evaluators\n# - Zero allocation after warmup\n# - Reuses pre-allocated buffers\n# - Scalar operations avoid broadcast allocations\n\n# AD: Uses dual number arithmetic with compiled evaluators (OPTIMIZED)\n# - Zero allocation after warmup via pre-conversion strategy\n# - Exact derivative computation with machine precision\n# - 3-5x performance improvement over previous AD implementation\n# - Composition via chain rule with type homogeneity","category":"page"},{"location":"backend_selection/#Custom-Tolerance-Settings","page":"Backend Selection","title":"Custom Tolerance Settings","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"For functions near domain boundaries, you may need custom tolerances:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"# Custom finite difference step size (advanced)\n# Note: This is a FormulaCompiler.jl setting, not directly exposed in Margins.jl\n# Contact maintainers if you need custom FD step sizes for specific functions","category":"page"},{"location":"backend_selection/#Summary-Guidelines","page":"Backend Selection","title":"Summary Guidelines","text":"","category":"section"},{"location":"backend_selection/#**Default-Strategy-(Recommended):**","page":"Backend Selection","title":"Default Strategy (Recommended):","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"For domain-sensitive functions (log, sqrt, 1/x):\nAlways use AD (:ad) - FD will fail with DomainErrors\nFor all other functions:\nUse AD as default (:ad) - Zero allocation + faster + more reliable\nUse FD only for: Simple linear formulas where marginal speed differences matter\nWhen in doubt: Use :ad - it now provides the best of all worlds (zero allocation, speed, reliability)","category":"page"},{"location":"backend_selection/#**Statistical-Guarantees:**","page":"Backend Selection","title":"Statistical Guarantees:","text":"","category":"section"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Both backends maintain statistical correctness when they succeed:","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"Same delta-method standard errors (when computed successfully)\nSame marginal effect estimates (when numerically stable)  \nSame confidence intervals and hypothesis tests","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"The reliability difference is in computational robustness, not statistical validity.","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"","category":"page"},{"location":"backend_selection/","page":"Backend Selection","title":"Backend Selection","text":"For performance optimization details, see Performance Guide. For mathematical background, see Mathematical Foundation.","category":"page"},{"location":"comparison/#Margins.jl-in-Context:-A-Comparison-with-Other-Marginal-Effects-Packages","page":"Package Comparison","title":"Margins.jl in Context: A Comparison with Other Marginal Effects Packages","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"This document provides a comprehensive assessment of how Margins.jl compares to other marginal effects implementations across languages. It serves as both a technical comparison and a migration guide for researchers familiar with other tools.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Key sections:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata Migration Guide - Direct command translations and examples for Stata users\nFeature Comparisons - Detailed capability comparisons across packages\nPerformance Analysis - Computational approach differences and implications\nTechnical Details - Mathematical rigor and implementation approaches","category":"page"},{"location":"comparison/#Stata-Migration-Guide","page":"Package Comparison","title":"Stata Migration Guide","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"For researchers familiar with Stata's margins command, Margins.jl provides equivalent functionality with a clean conceptual mapping. The key difference is that Margins.jl separates the choice of where to evaluate (population vs profile) from what to compute (effects vs predictions).","category":"page"},{"location":"comparison/#Basic-Command-Translation","page":"Package Comparison","title":"Basic Command Translation","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata Command Margins.jl Equivalent Notes\nmargins, dydx(*) population_margins(model, data; type=:effects) Average marginal effects (AME)\nmargins, at(means) dydx(*) profile_margins(model, data, means_grid(data); type=:effects) Marginal effects at means (MEM)\nmargins population_margins(model, data; type=:predictions) Average adjusted predictions\nmargins, at(means) profile_margins(model, data, means_grid(data); type=:predictions) Adjusted predictions at means","category":"page"},{"location":"comparison/#Advanced-Command-Translation","page":"Package Comparison","title":"Advanced Command Translation","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata Command Margins.jl Equivalent Notes\nmargins, at(x=0 x=1 x=2) profile_margins(model, data, cartesian_grid(x=[0,1,2]); type=:predictions) Multiple evaluation points\nmargins, at(x=0 z=1) at(x=1 z=2) profile_margins(model, data, DataFrame(x=[0,1], z=[1,2]); type=:predictions) Custom scenarios\nmargins, over(group) population_margins(model, data; groups=:group) Subgroup analysis\nmargins, dydx(x) at(z=(0 1)) profile_margins(model, data, cartesian_grid(z=[0,1]); type=:effects, vars=[:x]) Specific variables","category":"page"},{"location":"comparison/#Elasticity-Commands","page":"Package Comparison","title":"Elasticity Commands","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata Command Margins.jl Equivalent Notes\nmargins, eyex(*) population_margins(model, data; type=:effects, measure=:elasticity) Elasticities\nmargins, eydx(*) population_margins(model, data; type=:effects, measure=:semielasticity_eydx) Y semi-elasticity\nmargins, dyex(*) population_margins(model, data; type=:effects, measure=:semielasticity_dyex) X semi-elasticity","category":"page"},{"location":"comparison/#Conceptual-Differences","page":"Package Comparison","title":"Conceptual Differences","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata approach: Single margins command with many options","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Combines evaluation point and computation type in complex syntax\nOptions like at(), dydx(), over() modify behavior","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl approach: Separate functions for different purposes","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"population_margins() for sample-wide averages (AME/AAP)\nprofile_margins() for scenario-specific analysis (MEM/APM)\nClean parameter separation: type (effects/predictions), measure (elasticity type), reference grids for scenarios","category":"page"},{"location":"comparison/#Migration-Example","page":"Package Comparison","title":"Migration Example","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Here's a complete example showing equivalent analysis:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"* Fit logistic model\nlogit employed education age c.age#c.age\n\n* Average marginal effects\nmargins, dydx(*)\n\n* Effects at means\nmargins, at(means) dydx(*)\n\n* Effects at specific ages\nmargins, at(age=(25 35 45 55)) dydx(education)","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"using Margins, GLM, DataFrames\n\n# Fit logistic model  \nmodel = glm(@formula(employed ~ education + age + age^2), data, Binomial(), LogitLink())\n\n# Average marginal effects\name = population_margins(model, data; type=:effects)\nDataFrame(ame)\n\n# Effects at means\nmem = profile_margins(model, data, means_grid(data); type=:effects) \nDataFrame(mem)\n\n# Effects at specific ages\nage_effects = profile_margins(model, data, \n    cartesian_grid(age=[25, 35, 45, 55]); \n    vars=[:education], \n    type=:effects\n)\nDataFrame(age_effects)","category":"page"},{"location":"comparison/#Migration-Considerations","page":"Package Comparison","title":"Migration Considerations","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Performance characteristics: Different computational approaches may affect performance, particularly for:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Large datasets (>10k observations)\nComplex profile specifications\nRepeated analysis workflows","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Conceptual differences: The population vs profile distinction provides an alternative way to think about marginal analysis:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"population_margins() characterizes sample-wide patterns\nprofile_margins() examines specific scenarios","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Ecosystem integration: Julia's statistical ecosystem provides:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Mixed models via MixedModels.jl\nRobust standard errors via CovarianceMatrices.jl\nCustom model types via StatsAPI","category":"page"},{"location":"comparison/#Design-Philosophy","page":"Package Comparison","title":"Design Philosophy","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl was designed with several key principles:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Performance first: Built on FormulaCompiler.jl for zero-allocation computation paths\nConceptual clarity: Population vs Profile framework instead of statistical acronyms\nEcosystem integration: Works seamlessly with Julia's statistical ecosystem via StatsAPI\nMathematical rigor: Proper gradient computation and delta-method standard errors throughout","category":"page"},{"location":"comparison/#Feature-Comparison","page":"Package Comparison","title":"Feature Comparison","text":"","category":"section"},{"location":"comparison/#Core-Marginal-Effects-Functionality","page":"Package Comparison","title":"Core Marginal Effects Functionality","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Feature Margins.jl Effects.jl R margins Stata margins Python statsmodels\nPopulation marginal effects (AME)  ✗   \nProfile marginal effects (MEM/MER)     (at='mean' only)\nElasticities (3 types) ✗ ✗ (basic) ✗\nFlexible profile specification (Dict + table) (kwargs) (at=) (at()) ✗\nCategorical contrasts (baseline/pairwise) (basic) (basic)  (basic)\nGrouping/stratification (over/within/by) ✗ (basic) (over/by) ✗\nObservation weights  ✗   \nRobust standard errors (via CovarianceMatrices) (via vcov) (sandwich) (vce()) (limited)","category":"page"},{"location":"comparison/#Advanced-Features","page":"Package Comparison","title":"Advanced Features","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Feature Margins.jl Effects.jl R margins Stata margins Python statsmodels\nMixed models (automatic)  (manual)  (limited)\nMultiple backends (FD/AD)  ✗ ✗ ✗ ✗\nZero-allocation paths  ✗ ✗ ✗ ✗\nCompiled evaluation  ✗ ✗  ✗\nTable-based profiles  ✗ ✗ ✗ ✗\nMultiple comparison adjustments     (basic)","category":"page"},{"location":"comparison/#Model-Support","page":"Package Comparison","title":"Model Support","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Models Margins.jl Effects.jl R margins Stata margins Python statsmodels\nLinear/GLM     \nMixed effects (via StatsAPI)  (some)  (limited)\nSurvival models Future Future   \nCustom models (via StatsAPI) (via StatsAPI) Varies Limited Varies","category":"page"},{"location":"comparison/#Performance-Characteristics","page":"Package Comparison","title":"Performance Characteristics","text":"","category":"section"},{"location":"comparison/#AME-Performance-Background","page":"Package Comparison","title":"AME Performance Background","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Average marginal effects (AME) have traditionally been slow because most implementations evaluate the fitted model once per observation to compute numerical derivatives. This creates O(n) complexity with substantial per-evaluation overhead. For large datasets, this computational cost often led researchers to use marginal effects at means (MEM) as a faster alternative.","category":"page"},{"location":"comparison/#Computational-Approach","page":"Package Comparison","title":"Computational Approach","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl: Uses compiled formula evaluation with dual FD/AD backends. In indicative benchmark results, achieves approximately 50ns per marginal effect with zero allocations after warmup via FormulaCompiler.jl. Computes derivatives directly from compiled formulas rather than repeated model prediction calls.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Effects.jl: Uses automatic differentiation (ForwardDiff.jl) for gradient computation with standard Julia model prediction. Clean implementation but allocates ~400-500 bytes per gradient computation.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"R margins: Interpretation-based approach requiring repeated predict() calls per observation. Generally slower for large datasets due to evaluation overhead (Leeper, 2017).","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata margins: Compiled implementation with good performance, but still uses interpretation-based approach. Closed-source implementation limits optimization possibilities.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Python statsmodels: Mixed approach with some optimizations, but limited by Python overhead for large-scale AME computation.","category":"page"},{"location":"comparison/#Performance-Differences","page":"Package Comparison","title":"Performance Differences","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"The key difference is computational approach:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Traditional approach: n model evaluations × interpretation overhead  \nMargins.jl approach: Compiled formula evaluation (~7ns) + finite difference (~40ns) + delta-method SE (~10ns) = ~57ns per observation with zero allocations","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"These architectural differences may become more noticeable with larger datasets.","category":"page"},{"location":"comparison/#Benchmarking-Context","page":"Package Comparison","title":"Benchmarking Context","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"While formal cross-language benchmarks are complex due to different implementations and ecosystems, indicative performance characteristics suggest architectural differences:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Small problems (n < 1,000): Most packages perform adequately, overhead differences typically negligible\nMedium problems (n ~ 10,000): Different architectural approaches may show varying performance characteristics\nLarge problems (n > 100,000): Architectural differences become more apparent, with allocation patterns affecting scalability","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Zero-allocation approaches can help AME computation scale with dataset size by avoiding additional memory allocation.","category":"page"},{"location":"comparison/#API-Design-Comparison","page":"Package Comparison","title":"API Design Comparison","text":"","category":"section"},{"location":"comparison/#Conceptual-Framework","page":"Package Comparison","title":"Conceptual Framework","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl: Uses Population vs Profile framework with orthogonal parameters:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"population_margins(model, data; type=:effects, measure=:elasticity)\nprofile_margins(model, data, means_grid(data); type=:effects)","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Effects.jl: Function-based approach with keyword arguments:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"effects(model; x1=0.5, x2=[0, 1])  # At specific values\neffects(model, data)               # Average marginal effects","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"R margins: Function-based approach with extensive options:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"margins(model, data, at = list(x = c(-1, 0, 1)))","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata margins: Command-based with extensive syntax:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"margins, at(x=(-1 0 1)) dydx(x)","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Python statsmodels: Method-based approach:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"marginal_effects = model.get_margeff(at='mean')","category":"page"},{"location":"comparison/#Strengths-and-Tradeoffs","page":"Package Comparison","title":"Strengths and Tradeoffs","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl characteristics:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Conceptual separation of population vs profile approaches\nType-stable, composable design\nInterface consistent across model types\nElasticity support across multiple measures\nFocus on zero-allocation performance","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Effects.jl characteristics:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Simple, focused API\nAutomatic differentiation integration\nLightweight implementation\nActive development","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl limitations:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Newer package with smaller user base\nJulia ecosystem required\nSome Stata-specific syntax conveniences not implemented","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Effects.jl limitations:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"More limited feature set (no observation weights, limited grouping)\nLess performance optimization\nFewer advanced statistical features","category":"page"},{"location":"comparison/#Ecosystem-Integration","page":"Package Comparison","title":"Ecosystem Integration","text":"","category":"section"},{"location":"comparison/#Language-Ecosystems","page":"Package Comparison","title":"Language Ecosystems","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl: Integrates with Julia's statistical ecosystem via StatsAPI. Models that implement the standard interface work with the package, including mixed models and custom models.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Effects.jl: Also uses StatsAPI for integration, works well with standard Julia statistical models. More lightweight approach with fewer dependencies.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"R margins: Good integration with R's modeling ecosystem, though sometimes requires package-specific implementations.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Stata margins: Excellent integration within Stata's ecosystem, but limited extensibility.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Python statsmodels: Part of the statsmodels ecosystem with good integration there, more limited beyond.","category":"page"},{"location":"comparison/#Mathematical-Rigor","page":"Package Comparison","title":"Mathematical Rigor","text":"","category":"section"},{"location":"comparison/#Gradient-Computation","page":"Package Comparison","title":"Gradient Computation","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl: Uses gradient computation with delta-method standard errors. Provides both finite differences and automatic differentiation backends.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Other packages: Use various approaches to derivative computation, with implementation details varying by package and language ecosystem.","category":"page"},{"location":"comparison/#Standard-Error-Computation","page":"Package Comparison","title":"Standard Error Computation","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Most packages implement delta-method standard errors, with different approaches to optimization and numerical accuracy.","category":"page"},{"location":"comparison/#Margins.jl-Approach","page":"Package Comparison","title":"Margins.jl Approach","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl brings several distinctive features to marginal effects analysis:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Computational approach: Uses compiled formula evaluation with zero-allocation performance paths, which in indicative benchmarks can be beneficial for large-scale analysis and repeated computations.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Conceptual framework: Separates the question of where to evaluate (population vs profile) from what to compute (effects vs predictions), providing conceptual clarity in analysis design.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Elasticity support: Provides comprehensive elasticity computation including standard elasticities, x-semi-elasticities, and y-semi-elasticities across both population and profile approaches.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"For population-level counterfactuals, see Population Scenarios. For profile evaluation at specified covariate combinations, see Reference Grids.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Ecosystem integration: Works within Julia's statistical ecosystem, supporting mixed models, robust standard errors, and custom model types through common interfaces.","category":"page"},{"location":"comparison/#Future-Development","page":"Package Comparison","title":"Future Development","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl development benefits from Julia's evolving ecosystem. Relevant factors for future development include:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Language characteristics: Julia's design enables certain types of optimizations\nEcosystem integration: Statistical methods can integrate via common interfaces\nDevelopment activity: Both Margins.jl and FormulaCompiler.jl continue active development","category":"page"},{"location":"comparison/#Ecosystem-Maturity-Considerations","page":"Package Comparison","title":"Ecosystem Maturity Considerations","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"An important factor in package selection is ecosystem maturity and validation in applied settings:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Established packages (Stata margins, R margins): These have extensive validation through years of use in econometric research and applied statistics. Their implementations have been tested across diverse research contexts and publication processes.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Julia ecosystem: While Julia's statistical ecosystem is rapidly maturing, it represents a more experimental environment. Packages like Margins.jl and Effects.jl are newer and have smaller user bases compared to established tools in Stata and R.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Practical implications:","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"For high-stakes research requiring maximum confidence in implementation, established packages may be preferable\nFor research prioritizing computational performance or new methodological approaches, newer Julia packages may offer advantages\nCross-validation of results across packages can provide additional confidence when using newer implementations","category":"page"},{"location":"comparison/#Conclusion","page":"Package Comparison","title":"Conclusion","text":"","category":"section"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Margins.jl provides an alternative approach with different performance characteristics and API design. Being newer than established packages, it represents a different set of tradeoffs in the marginal effects landscape.","category":"page"},{"location":"comparison/","page":"Package Comparison","title":"Package Comparison","text":"Package selection depends on specific requirements, use cases, and tolerance for ecosystem maturity differences. Margins.jl offers a different approach to marginal effects computation that may be beneficial in certain contexts, while established packages provide proven reliability in applied research settings.","category":"page"},{"location":"reference_grids/#Reference-Grid-Methodology-and-Implementation","page":"Reference Grids","title":"Reference Grid Methodology and Implementation","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Reference Grids  A reference grid is simply a table that says \"compute effects for people with these specific characteristics.\" For example:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Age: 30, Education: College → \"What's the effect for 30-year-old college graduates?\"\nAge: 40, Education: High School → \"What's the effect for 40-year-old high school graduates?\"","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"The package provides helper functions to create these tables automatically.","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Reference grid specification constitutes the methodological foundation for covariate scenario definition in profile-based marginal effects analysis. The implementation provides a systematic framework for scenario specification through structured builder functions and direct tabular specification interfaces.","category":"page"},{"location":"reference_grids/#Methodological-Foundation","page":"Reference Grids","title":"Methodological Foundation","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"The analytical framework employs explicit reference grid specification to ensure transparency and computational precision:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"profile_margins(model, data, reference_grid; type=:effects, ...)","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"The reference_grid parameter accepts DataFrame specifications that enumerate the covariate combinations where marginal effects are computed.","category":"page"},{"location":"reference_grids/#Reference-Grid-Builders","page":"Reference Grids","title":"Reference Grid Builders","text":"","category":"section"},{"location":"reference_grids/#1.-Sample-Means-means_grid(data)","page":"Reference Grids","title":"1. Sample Means - means_grid(data)","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Creates reference grid with sample means for continuous variables and frequency-weighted mixtures for categorical variables:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Build grid with realistic defaults\ngrid = means_grid(data)\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Custom typical value function (default is mean)\ngrid = means_grid(data; typical=median)\nresult = profile_margins(model, data, grid; type=:effects)","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Output structure:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Continuous variables: Sample mean (or custom typical function)\nCategorical variables: Frequency-weighted mixture based on actual data distribution\nBool variables: Probability of true (proportion of true values)","category":"page"},{"location":"reference_grids/#2.-Cartesian-Product-cartesian_grid(vars...)","page":"Reference Grids","title":"2. Cartesian Product - cartesian_grid(vars...)","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Creates all combinations of specified values across variables:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# 3×2 = 6 scenarios: all combinations of x and education values\ngrid = cartesian_grid(x=[-1, 0, 1], education=[\"High School\", \"College\"])\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Single variable varying, others at typical values\ngrid = cartesian_grid(age=20:10:70)\nresult = profile_margins(model, data, grid; type=:predictions)\n\n# Complex scenarios with multiple variables\ngrid = cartesian_grid(\n    income=[25000, 50000, 75000],\n    education=[\"HS\", \"College\"],\n    region=[\"North\", \"South\"]\n)  # Creates 3×2×2 = 12 scenarios\nresult = profile_margins(model, data, grid; type=:effects)","category":"page"},{"location":"reference_grids/#3.-Balanced-Factorial-balanced_grid(data;-vars...)","page":"Reference Grids","title":"3. Balanced Factorial - balanced_grid(data; vars...)","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Creates balanced (equal-weight) mixtures for categorical variables, useful for orthogonal factorial designs:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Balanced factorial for categorical variables\ngrid = balanced_grid(data; education=:all, region=:all)\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Mixed specification\ngrid = balanced_grid(data; \n    education=:all,           # All levels with equal weight\n    income=mean(data.income)  # Fixed at mean\n)\nresult = profile_margins(model, data, grid; type=:effects)","category":"page"},{"location":"reference_grids/#4.-Quantile-Based-quantile_grid(data;-vars...)","page":"Reference Grids","title":"4. Quantile-Based - quantile_grid(data; vars...)","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Uses quantiles of continuous variables:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Effects at income quartiles\ngrid = quantile_grid(data; income=[0.25, 0.5, 0.75])\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Multiple quantile specifications\ngrid = quantile_grid(data; \n    income=[0.1, 0.5, 0.9],\n    age=[0.25, 0.75]\n)  # Creates 3×2 = 6 scenarios\nresult = profile_margins(model, data, grid; type=:effects)","category":"page"},{"location":"reference_grids/#5.-Hierarchical-Grammar-hierarchical_grid(data,-spec)","page":"Reference Grids","title":"5. Hierarchical Grammar - hierarchical_grid(data, spec)","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Creates systematic reference grids using the group nesting grammar (=> operator) for complex multi-dimensional covariate scenario construction:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Simple hierarchical: region-specific education representatives\nspec = :region => :education\ngrid = hierarchical_grid(data, spec)\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Complex hierarchy with multiple representative types\nspec = :region => [\n    (:income, :quartiles),  # Income quartiles within each region\n    (:age, :mean),          # Mean age within each region  \n    :education              # All education levels within each region\n]\ngrid = hierarchical_grid(data, spec)\nresult = profile_margins(model, data, grid; type=:effects)\n\n# Deep nesting (3+ levels) with automatic safety validation\nspec = :country => (\n    :region => (\n        :education => [(:income, :quartiles), (:age, :mean)]\n    )\n)\ngrid = hierarchical_grid(data, spec; max_depth=4, warn_large=true)\nresult = profile_margins(model, data, grid; type=:effects)","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Advanced Representative Types:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Statistical representatives within hierarchical groups\nspec = :region => [\n    (:income, :mean),           # Mean income per region\n    (:income, :median),         # Median income per region\n    (:income, :quartiles),      # Q1, Q2, Q3, Q4 per region\n    (:income, :quintiles),      # Quintiles per region\n    (:income, :deciles),        # Deciles per region\n    (:income, [0.1, 0.5, 0.9]), # Custom percentiles per region\n    (:age, [25, 45, 65]),       # Fixed representative ages\n    (:score, (:range, 5))       # 5 evenly spaced points from min to max\n]\ngrid = hierarchical_grid(data, spec)","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Mixture Integration:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Population-proportion mixtures for realistic scenarios\nspec = :region => [\n    (:education, :mix_proportional),  # Use actual data proportions\n    (:income, :quartiles),\n    (:age, :mean)\n]\ngrid = hierarchical_grid(data, spec)\n\n# Custom mixtures for policy analysis\nusing Margins: mix\nspec = :region => [\n    (:education, mix(\"HS\" => 0.3, \"College\" => 0.7)),  # Policy scenario\n    (:income, :median)\n]\ngrid = hierarchical_grid(data, spec)","category":"page"},{"location":"reference_grids/#Direct-DataFrame-Specification","page":"Reference Grids","title":"Direct DataFrame Specification","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"For maximum control, create reference grids directly:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Simple custom grid\nreference_grid = DataFrame(\n    age=[25, 35, 45], \n    education=[\"High School\", \"College\", \"Graduate\"],\n    experience=[2, 8, 15],\n    treated=[true, false, true]\n)\nresult = profile_margins(model, data, reference_grid; type=:effects)\n\n# Grid with categorical mixtures\nusing Margins: mix\n\npolicy_grid = DataFrame(\n    age=[35, 45, 55],\n    education=[\n        mix(\"HS\" => 0.4, \"College\" => 0.6),        # Current composition\n        mix(\"HS\" => 0.2, \"College\" => 0.8),        # Policy scenario 1\n        mix(\"HS\" => 0.1, \"College\" => 0.9)         # Policy scenario 2\n    ]\n)\nresult = profile_margins(model, data, policy_grid; type=:predictions)","category":"page"},{"location":"reference_grids/#Advanced-Patterns","page":"Reference Grids","title":"Advanced Patterns","text":"","category":"section"},{"location":"reference_grids/#Frequency-Weighted-Defaults","page":"Reference Grids","title":"Frequency-Weighted Defaults","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"When variables are unspecified in builder functions, they use actual data composition:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Your data composition:\n# - education: 40% HS, 45% College, 15% Graduate  \n# - region: 75% Urban, 25% Rural\n# - treated: 60% true, 40% false\n\n# Builder uses realistic defaults\ngrid = cartesian_grid(income=[30000, 50000, 70000])\n# → income varies as specified\n# → education: mix(\"HS\" => 0.4, \"College\" => 0.45, \"Graduate\" => 0.15)\n# → region: mix(\"Urban\" => 0.75, \"Rural\" => 0.25)  \n# → treated: 0.6 (probability of true)","category":"page"},{"location":"reference_grids/#Hierarchical-Policy-Analysis","page":"Reference Grids","title":"Hierarchical Policy Analysis","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Systematic multi-dimensional policy evaluation using hierarchical grids:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Complex policy analysis across administrative levels\npolicy_spec = :state => (\n    :county => [\n        (:education, :mix_proportional),     # Actual education composition per county\n        (:income, :quintiles),               # Income distribution per county\n        (:age, [25, 45, 65]),               # Key demographic groups\n        (:employment_status, :all)           # All employment categories\n    ]\n)\ngrid = hierarchical_grid(data, policy_spec)\nresult = profile_margins(policy_model, data, grid; vars=[:policy_treatment])\n\n# Comparative scenario analysis\nbaseline_spec = :region => [(:education, :mix_proportional), (:income, :mean)]\nintervention_spec = :region => [(:education, mix(\"HS\" => 0.2, \"College\" => 0.8)), (:income, :mean)]\n\nbaseline_grid = hierarchical_grid(data, baseline_spec)\nintervention_grid = hierarchical_grid(data, intervention_spec)\n\nbaseline_results = profile_margins(model, data, baseline_grid; type=:predictions)\nintervention_results = profile_margins(model, data, intervention_grid; type=:predictions)\n\n# Calculate policy impact\nbaseline_df = DataFrame(baseline_results)\nintervention_df = DataFrame(intervention_results)\npolicy_impact = intervention_df.estimate .- baseline_df.estimate","category":"page"},{"location":"reference_grids/#Scenario-Comparison","page":"Reference Grids","title":"Scenario Comparison","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Compare different policy scenarios:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Current scenario (status quo)\ncurrent_grid = means_grid(data)\ncurrent = profile_margins(model, data, current_grid; type=:predictions)\n\n# Policy scenario (increased education)\npolicy_grid = DataFrame(\n    age=mean(data.age),\n    income=mean(data.income),\n    education=mix(\"HS\" => 0.2, \"College\" => 0.5, \"Graduate\" => 0.3)  # Policy target\n)\nfuture = profile_margins(model, data, policy_grid; type=:predictions)\n\n# Compare outcomes\ncurrent_pred = DataFrame(current).estimate[1]\nfuture_pred = DataFrame(future).estimate[1]\npolicy_impact = future_pred - current_pred","category":"page"},{"location":"reference_grids/#Sequential-Analysis","page":"Reference Grids","title":"Sequential Analysis","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Analyze effects along ranges of key variables:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Effects across age ranges\nage_grid = cartesian_grid(age=25:5:65)\nage_effects = profile_margins(model, data, age_grid; type=:effects, vars=[:education])\n\n# Plot age-varying effects\nusing Plots\nplot(25:5:65, DataFrame(age_effects).estimate, \n     xlabel=\"Age\", ylabel=\"Education Effect\", \n     title=\"Age-Varying Education Effects\")","category":"page"},{"location":"reference_grids/#Performance-Considerations","page":"Reference Grids","title":"Performance Considerations","text":"","category":"section"},{"location":"reference_grids/#Grid-Size-and-Efficiency","page":"Reference Grids","title":"Grid Size and Efficiency","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Reference grid size affects performance linearly, but is independent of dataset size:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Small grid: 3 scenarios\nsmall_grid = cartesian_grid(x=[0, 1, 2])\n@time profile_margins(model, huge_data, small_grid)  # ~150μs\n\n# Large grid: 27 scenarios  \nlarge_grid = cartesian_grid(x=[0,1,2], y=[0,1,2], z=[0,1,2])\n@time profile_margins(model, huge_data, large_grid)  # ~400μs\n\n# Dataset size doesn't matter\n@time profile_margins(model, small_data, large_grid)  # Still ~400μs","category":"page"},{"location":"reference_grids/#Hierarchical-Grid-Performance","page":"Reference Grids","title":"Hierarchical Grid Performance","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Hierarchical grids provide automatic size estimation and safety validation:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Automatic grid size warnings for large combinations\nlarge_spec = :country => (:region => (:education => (:income, :deciles)))\n# Warning: Estimated grid size ~50,000 combinations may impact performance\ngrid = hierarchical_grid(data, large_spec; warn_large=true)\n\n# Depth protection prevents excessive nesting\ndeep_spec = :a => (:b => (:c => (:d => (:e => (:f => :g)))))\n# Error: Nesting depth 7 exceeds maximum allowed depth 5\ngrid = hierarchical_grid(data, deep_spec; max_depth=5)\n\n# Efficient construction through systematic generation\ncomplex_spec = :region => [(:income, :quartiles), (:age, :mean), :education]\n@time hierarchical_grid(data, complex_spec)  # ~50μs regardless of data size","category":"page"},{"location":"reference_grids/#Memory-Management","page":"Reference Grids","title":"Memory Management","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Builder functions are optimized for memory efficiency:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Efficient: builders avoid unnecessary allocations\ngrid = means_grid(large_data)  # O(1) memory for typical values\n\n# Less efficient: explicit grids require full materialization  \nexplicit_grid = DataFrame(\n    x1=fill(mean(large_data.x1), 1000),  # O(n) memory\n    x2=fill(mean(large_data.x2), 1000)\n)","category":"page"},{"location":"reference_grids/#Validation-and-Error-Handling","page":"Reference Grids","title":"Validation and Error Handling","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Reference grids are validated automatically:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Error: Missing model variables\nincomplete_grid = DataFrame(x1=[0, 1])  # Missing x2 from model\nprofile_margins(model, data, incomplete_grid)  \n# → ArgumentError: Missing model variables: x2\n\n# Error: Invalid categorical levels\ninvalid_grid = DataFrame(\n    x1=[0, 1], \n    group=[\"InvalidLevel\", \"AnotherInvalid\"]  # Not in original data\n)\nprofile_margins(model, data, invalid_grid)\n# → ArgumentError: Invalid levels for categorical variable 'group'\n\n# Warning: Large grid size\nhuge_grid = cartesian_grid(x=1:100, y=1:100)  # 10,000 scenarios\nprofile_margins(model, data, huge_grid)\n# → Warning: Large reference grid (10000 scenarios) may impact performance","category":"page"},{"location":"reference_grids/#Statistical-Properties","page":"Reference Grids","title":"Statistical Properties","text":"","category":"section"},{"location":"reference_grids/#Delta-Method-Standard-Errors","page":"Reference Grids","title":"Delta-Method Standard Errors","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Standard errors are computed consistently across all reference grid types:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Same statistical rigor regardless of grid construction method\ngrid1 = means_grid(data)\ngrid2 = DataFrame(age=mean(data.age), education=mode(data.education))\ngrid3 = cartesian_grid(age=[mean(data.age)])\n\n# All use identical delta-method computation\nresult1 = profile_margins(model, data, grid1; type=:effects)\nresult2 = profile_margins(model, data, grid2; type=:effects)  \nresult3 = profile_margins(model, data, grid3; type=:effects)\n\n# Standard errors are mathematically equivalent\nall(DataFrame(result1).se .≈ DataFrame(result2).se .≈ DataFrame(result3).se)  # true","category":"page"},{"location":"reference_grids/#Categorical-Mixture-Handling","page":"Reference Grids","title":"Categorical Mixture Handling","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Categorical mixtures are handled natively throughout the system:","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# Fractional specifications work seamlessly\nmixed_grid = DataFrame(\n    age=[35, 45],\n    treated=[0.3, mix(0 => 0.6, 1 => 0.4)]  # Mix of scalar and mixture\n)\nresult = profile_margins(model, data, mixed_grid; type=:predictions)\n\n# Standard errors account for mixture uncertainty automatically\nDataFrame(result)  # Includes proper SEs for mixed scenarios","category":"page"},{"location":"reference_grids/#Migration-Guide","page":"Reference Grids","title":"Migration Guide","text":"","category":"section"},{"location":"reference_grids/#From-Old-at-Parameter-Syntax","page":"Reference Grids","title":"From Old at Parameter Syntax","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# OLD (deprecated):\nprofile_margins(model, data; at=:means)\nprofile_margins(model, data; at=Dict(:x => [0,1,2]))\nprofile_margins(model, data; at=[Dict(:x => 0), Dict(:x => 1)])\n\n# NEW (current):\nprofile_margins(model, data, means_grid(data))\nprofile_margins(model, data, cartesian_grid(x=[0,1,2]))\n\nexplicit_grid = DataFrame(x=[0, 1])\nprofile_margins(model, data, explicit_grid)","category":"page"},{"location":"reference_grids/#Builder-Function-Evolution","page":"Reference Grids","title":"Builder Function Evolution","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"# OLD (deprecated internal names):\nrefgrid_means(data)\nrefgrid_cartesian(specs, data)\n\n# NEW (exported public API):\nmeans_grid(data)\ncartesian_grid(vars...)\nbalanced_grid(data; vars...)\nquantile_grid(data; vars...)","category":"page"},{"location":"reference_grids/#Best-Practices","page":"Reference Grids","title":"Best Practices","text":"","category":"section"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"Start with means_grid() for basic analysis\nUse cartesian_grid() for systematic exploration\nUse balanced_grid() for orthogonal factorial designs\nUse quantile_grid() for distributional analysis\nUse hierarchical_grid() for complex multi-dimensional policy analysis\nUse explicit DataFrame for maximum custom control\nValidate grids with small examples before scaling up\nConsider grid size vs computational requirements\nLeverage frequency weighting for realistic defaults\nUse mixture specifications for policy counterfactual analysis","category":"page"},{"location":"reference_grids/","page":"Reference Grids","title":"Reference Grids","text":"See also: profile_margins for the main function interface.","category":"page"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Computational characteristics and optimization strategies","category":"page"},{"location":"performance/#Conceptual-Framework","page":"Performance Guide","title":"Conceptual Framework","text":"","category":"section"},{"location":"performance/#Performance-Design-Principles","page":"Performance Guide","title":"Performance Design Principles","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Margins.jl achieves computational efficiency through architectural design that respects the fundamental mathematical structure of marginal effects analysis. Performance optimization preserves statistical correctness while exploiting the distinct computational requirements of population versus profile analysis.","category":"page"},{"location":"performance/#Algorithmic-Complexity-Characteristics","page":"Performance Guide","title":"Algorithmic Complexity Characteristics","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Profile Analysis: O(1) constant-time complexity independent of dataset size\nPopulation Analysis: O(n) linear scaling with optimized per-observation computational cost\nStatistical Integrity: All performance optimizations maintain mathematical validity","category":"page"},{"location":"performance/#Implementation-Performance","page":"Performance Guide","title":"Implementation Performance","text":"","category":"section"},{"location":"performance/#Performance-Characteristics","page":"Performance Guide","title":"Performance Characteristics","text":"","category":"section"},{"location":"performance/#Profile-Analysis:-O(1)-Constant-Time","page":"Performance Guide","title":"Profile Analysis: O(1) Constant Time","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Profile margins achieve constant-time performance regardless of dataset size:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using BenchmarkTools, Margins\n\n# Performance is independent of dataset size\n@btime profile_margins($model, $data_1k, means_grid($data_1k); type=:effects)     # constant time\n@btime profile_margins($model, $data_100k, means_grid($data_100k); type=:effects) # same complexity\n@btime profile_margins($model, data_1M, means_grid(data_1M); type=:effects)       # same complexity\n\n# Complex scenarios also O(1)\nscenarios = cartesian_grid(x1=[0,1,2], x2=[10,20,30], group=[\"A\",\"B\"])  # 18 profiles\n@btime profile_margins($model, $huge_data, scenarios)                       # still constant time","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Why this matters: Profile analysis cost is independent of sample size, making it efficient for large-scale econometric analysis.","category":"page"},{"location":"performance/#Population-Analysis:-Optimized-O(n)-Scaling","page":"Performance Guide","title":"Population Analysis: Optimized O(n) Scaling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Population margins scale linearly with optimized per-row costs:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Linear scaling with low per-row computational cost\n@btime population_margins($model, $data_1k)    # scales with dataset size\n@btime population_margins($model, $data_10k)   # with efficient per-row processing  \n@btime population_margins($model, $data_100k)  # minimal allocation overhead\n\n# Memory footprint remains zero (both backends)\n@allocated population_margins(model, data_1k; backend=:fd)    # 0 bytes\n@allocated population_margins(model, data_10k; backend=:fd)   # 0 bytes\n@allocated population_margins(model, data_100k; backend=:fd)  # 0 bytes\n\n@allocated population_margins(model, data_1k; backend=:ad)    # 0 bytes\n@allocated population_margins(model, data_10k; backend=:ad)   # 0 bytes\n@allocated population_margins(model, data_100k; backend=:ad)  # 0 bytes","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Why this matters: Population analysis maintains constant allocation footprint while delivering consistent per-row performance.","category":"page"},{"location":"performance/#Dataset-Size-Guidelines","page":"Performance Guide","title":"Dataset Size Guidelines","text":"","category":"section"},{"location":"performance/#Performance-Expectations-by-Scale","page":"Performance Guide","title":"Performance Expectations by Scale","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Dataset Size Population Margins Profile Margins Recommended Workflow\n< 1k Fast Constant time Use either approach freely\n1k-10k Fast Constant time Profile preferred for scenarios\n10k-100k Scales linearly Constant time Profile for exploration, population for final analysis\n100k-1M Scales appropriately Constant time Profile strongly preferred\n> 1M Scales with dataset size Constant time Profile analysis, selective population","category":"page"},{"location":"performance/#Backend-Selection-by-Use-Case","page":"Performance Guide","title":"Backend Selection by Use Case","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"For detailed backend selection guidance including domain-sensitive functions and reliability considerations, see Backend Selection Guide.","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Quick summary:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":":ad - Required for log(), sqrt(), 1/x functions; higher reliability\n:fd - Zero allocation, optimal for production and large datasets","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Production configuration (memory-optimized)\npopulation_margins(model, data; backend=:fd, scale=:link)\n\n# Development/high-reliability configuration  \nprofile_margins(model, data, means_grid(data); backend=:ad, scale=:response)\n\n# Domain-sensitive functions (log, sqrt) - AD required\npopulation_margins(model, data; backend=:ad)  # Required for log(x), sqrt(x)","category":"page"},{"location":"performance/#Optimization-Principles","page":"Performance Guide","title":"Optimization Principles","text":"","category":"section"},{"location":"performance/#Core-Performance-Philosophy","page":"Performance Guide","title":"Core Performance Philosophy","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Statistical Correctness First: Performance optimizations maintain statistical validity","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Delta-method standard errors use full covariance matrix\nAll gradient computations maintain mathematical precision\nBootstrap validation ensures statistical accuracy\nNever change estimators, gradients, or SE math to \"optimize\"","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Zero-Allocation Patterns: Eliminate unnecessary memory allocations","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Pre-allocated buffers reused across computations\nFormulaCompiler.jl provides zero-allocation evaluation primitives\nConstant memory footprint regardless of dataset size\nO(1) allocations in production paths: constant allocation count w.r.t. sample size","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Computational Efficiency: Optimize hot paths without changing methodology","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Compiled formula evaluation with caching\nEfficient gradient accumulation patterns\nScalar operations over broadcast temporaries\nZero dynamic growth: avoid push! in hot paths; size outputs up-front","category":"page"},{"location":"performance/#Backend-Performance-Characteristics","page":"Performance Guide","title":"Backend Performance Characteristics","text":"","category":"section"},{"location":"performance/#Automatic-Differentiation-(:ad)-**RECOMMENDED-DEFAULT**","page":"Performance Guide","title":"Automatic Differentiation (:ad) - RECOMMENDED DEFAULT","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Zero allocation after warmup\npopulation_margins(model, data; backend=:ad)  # 0 bytes allocated","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Advantages:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Zero allocation after warmup\nMachine precision accuracy (exact derivatives)\nRobust domain handling (handles log, sqrt, 1/x safely)\nSuitable for complex formulas","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Use cases: Most applications - provides good performance and reliability","category":"page"},{"location":"performance/#Finite-Differences-(:fd)","page":"Performance Guide","title":"Finite Differences (:fd)","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Zero allocation after warmup\npopulation_margins(model, data; backend=:fd)  # 0 bytes allocated","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Advantages:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Zero allocation in production paths\nSimple numerical implementation\nGood accuracy for well-conditioned functions","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Use cases: Simple linear formulas where marginal speed differences matter","category":"page"},{"location":"performance/#Memory-Management","page":"Performance Guide","title":"Memory Management","text":"","category":"section"},{"location":"performance/#Allocation-Patterns","page":"Performance Guide","title":"Allocation Patterns","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Margins.jl achieves zero-allocation performance for computational workflows:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Profile margins: constant allocation regardless of data size\n@allocated profile_margins(model, small_data, means_grid(small_data))  # small constant allocation\n@allocated profile_margins(model, large_data, means_grid(large_data))  # same allocation pattern\n\n# Population margins: zero allocation after warmup (both backends)\n@allocated population_margins(model, data_1k; backend=:fd)   # 0 bytes\n@allocated population_margins(model, data_10k; backend=:fd)  # 0 bytes\n@allocated population_margins(model, data_1k; backend=:ad)   # 0 bytes\n@allocated population_margins(model, data_10k; backend=:ad)  # 0 bytes","category":"page"},{"location":"performance/#Memory-Efficiency-Best-Practices","page":"Performance Guide","title":"Memory Efficiency Best Practices","text":"","category":"section"},{"location":"performance/#For-Large-Datasets","page":"Performance Guide","title":"For Large Datasets","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Use profile analysis for exploration (O(1) memory)\nscenarios = cartesian_grid(x1=[-1, 0, 1], treatment=[0, 1])\nresults = profile_margins(model, large_data, scenarios)\n\n# Use population analysis with zero-allocation backends\nkey_effects = population_margins(model, large_data; vars=[:treatment], backend=:ad)  # Recommended\n# OR\nkey_effects = population_margins(model, large_data; vars=[:treatment], backend=:fd)  # Also zero allocation","category":"page"},{"location":"performance/#For-Batch-Processing","page":"Performance Guide","title":"For Batch Processing","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Process multiple models with zero allocation\nmodels = [model1, model2, model3]\nresults = []\n\nfor model in models\n    # Each call has zero allocation (either backend)\n    result = population_margins(model, data; backend=:ad)  # Recommended: zero allocation\n    push!(results, DataFrame(result))\nend","category":"page"},{"location":"performance/#Performance-Best-Practices","page":"Performance Guide","title":"Performance Best Practices","text":"","category":"section"},{"location":"performance/#High-Performance-Usage-Patterns","page":"Performance Guide","title":"High-Performance Usage Patterns","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"For optimal performance in production environments, follow these proven patterns:","category":"page"},{"location":"performance/#Compilation-and-Caching","page":"Performance Guide","title":"Compilation and Caching","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Good: Compile once, use multiple times\ncompiled = FormulaCompiler.compile_formula(model, data)  # Expensive, do once\nde = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=vars)  # Do once\n\n# Multiple analysis calls reuse compiled objects automatically\nresult1 = population_margins(model, data; type=:effects)     \nresult2 = profile_margins(model, data, means_grid(data); type=:effects)\n\n# Avoid: Forcing recompilation in loops\nfor subset in data_subsets\n    # Each call may recompile unnecessarily\n    result = population_margins(fit_model(subset), subset)  \nend","category":"page"},{"location":"performance/#Memory-Efficient-Data-Processing","page":"Performance Guide","title":"Memory-Efficient Data Processing","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Good: Pre-allocate result structures for known sizes\nn_effects = length(vars) * length(scenarios)\nresult_buffer = DataFrame(\n    term = Vector{String}(undef, n_effects),\n    estimate = Vector{Float64}(undef, n_effects),\n    se = Vector{Float64}(undef, n_effects)\n)\n\n# Good: Use scalar operations in hot paths\nfor i in eachindex(estimates)\n    μ = GLM.linkinv(link, η[i])      # Scalar operation\n    se[i] = sqrt(gradients[i]' * Σ * gradients[i])\nend\n\n# Avoid: Growing DataFrames with push! in loops\nresults = DataFrame()\nfor scenario in scenarios\n    result = population_margins(model, scenario_data)\n    push!(results, DataFrame(result))  # Expensive growth\nend","category":"page"},{"location":"performance/#FormulaCompiler-Integration-Patterns","page":"Performance Guide","title":"FormulaCompiler Integration Patterns","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Good: Let FormulaCompiler handle the optimization\n# Use built-in primitives for zero-allocation paths\npopulation_margins(model, data; backend=:fd)  # Uses optimized accumulation\n\n# Good: Cache compiled objects for batch processing\nmodels = [model1, model2, model3]\ncached_compilations = Dict()\n\nfor model in models\n    # Compilation is cached automatically by model signature\n    result = population_margins(model, data; backend=:ad)\nend","category":"page"},{"location":"performance/#Performance-Validation","page":"Performance Guide","title":"Performance Validation","text":"","category":"section"},{"location":"performance/#Checking-Allocation-Patterns","page":"Performance Guide","title":"Checking Allocation Patterns","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Verify zero-allocation performance\nusing BenchmarkTools\n\n# Both backends should show 0 allocation after warmup\n@allocated population_margins(model, data; backend=:ad)  # Expected: 0 bytes  \n@allocated population_margins(model, data; backend=:fd)  # Expected: 0 bytes\n\n# Profile margins should have constant allocation regardless of data size\n@allocated profile_margins(model, small_data, means_grid(small_data))  # Small constant\n@allocated profile_margins(model, large_data, means_grid(large_data))  # Same constant","category":"page"},{"location":"performance/#Performance-Monitoring","page":"Performance Guide","title":"Performance Monitoring","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Production monitoring pattern\nfunction monitored_margins(model, data; max_alloc_kb=10, kwargs...)\n    alloc_before = Base.gc_num().poolalloc\n    \n    result = population_margins(model, data; kwargs...)\n    \n    alloc_after = Base.gc_num().poolalloc\n    alloc_kb = (alloc_after - alloc_before) / 1024\n    \n    if alloc_kb > max_alloc_kb\n        @warn \"Excessive allocation detected: $(alloc_kb)KB\"\n    end\n    \n    return result\nend","category":"page"},{"location":"performance/#Troubleshooting-Performance-Issues","page":"Performance Guide","title":"Troubleshooting Performance Issues","text":"","category":"section"},{"location":"performance/#Diagnostic-Tools","page":"Performance Guide","title":"Diagnostic Tools","text":"","category":"section"},{"location":"performance/#Memory-Allocation-Checking","page":"Performance Guide","title":"Memory Allocation Checking","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using BenchmarkTools\n\n# Check allocation patterns\n@allocated population_margins(model, data)  # Should be constant across dataset sizes\n\n# Benchmark performance\n@btime population_margins($model, $data)     # Timing analysis","category":"page"},{"location":"performance/#Performance-Profiling","page":"Performance Guide","title":"Performance Profiling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Profile hot paths (advanced)\nusing Profile\n\n@profile for i in 1:100\n    population_margins(model, data; backend=:fd)\nend\nProfile.print()","category":"page"},{"location":"performance/#Common-Issues-and-Solutions","page":"Performance Guide","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"performance/#Issue:-Profile-margins-slower-than-expected","page":"Performance Guide","title":"Issue: Profile margins slower than expected","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagnosis: Reference grid specification or DataFrame dispatch issues Solution: Use proper reference grid builders","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Correct: O(1) performance with reference grids\nprofile_margins(model, data, means_grid(data); type=:effects)\nprofile_margins(model, data, cartesian_grid(x=[0,1,2]); type=:effects)\n\n# Avoid: Improper reference grid specification\n# Always use reference grid builders or explicit DataFrames","category":"page"},{"location":"performance/#Issue:-Population-margins-allocating-excessively","page":"Performance Guide","title":"Issue: Population margins allocating excessively","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagnosis: Hot loop allocation patterns or data format issues Solution: Check backend and use efficient data formats","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Efficient: Both backends should be zero allocation\nresult = population_margins(model, data; backend=:ad)  # Recommended\nresult = population_margins(model, data; backend=:fd)  # Also zero allocation\n\n# Efficient data format\ndata_nt = Tables.columntable(data)  # Convert once for multiple analyses\nresult = population_margins(model, data_nt; backend=:ad)","category":"page"},{"location":"performance/#Issue:-Inconsistent-performance-across-runs","page":"Performance Guide","title":"Issue: Inconsistent performance across runs","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagnosis: Compilation effects, memory pressure, or GC interference Solution: Proper warmup and consistent configuration","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Proper benchmarking protocol\n# 1. Warmup run\npopulation_margins(model, small_sample)  \n\n# 2. Clear compilation effects  \nGC.gc()\n\n# 3. Consistent benchmark\n@btime population_margins($model, $data; backend=:ad)  ","category":"page"},{"location":"performance/#Issue:-Memory-allocation-growing-with-dataset-size","page":"Performance Guide","title":"Issue: Memory allocation growing with dataset size","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagnosis: O(n) allocation pattern indicating performance regression Solution: Verify zero-allocation backends and check for loops","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Expected: constant allocation across dataset sizes\n@allocated population_margins(model, data_1k; backend=:ad)    # Should be 0 bytes\n@allocated population_margins(model, data_10k; backend=:ad)   # Should be 0 bytes  \n@allocated population_margins(model, data_100k; backend=:ad)  # Should be 0 bytes\n\n# If allocations grow with n:\n# 1. Check backend selection (:ad and :fd both should be zero allocation)  \n# 2. Verify data format (Tables.jl-compatible)\n# 3. Check for custom vcov functions that may allocate","category":"page"},{"location":"performance/#Issue:-Slow-compilation-on-first-run","page":"Performance Guide","title":"Issue: Slow compilation on first run","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Diagnosis: Normal FormulaCompiler compilation overhead Solution: Accept first-run cost, subsequent runs benefit from caching","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Expected pattern:\n@time population_margins(model, data)        # Slower (compilation)\n@time population_margins(model, data)        # Faster (cached)\n\n# For production: accept compilation cost or precompile key models","category":"page"},{"location":"performance/#FormulaCompiler.jl-Integration","page":"Performance Guide","title":"FormulaCompiler.jl Integration","text":"","category":"section"},{"location":"performance/#Zero-Allocation-Foundations","page":"Performance Guide","title":"Zero-Allocation Foundations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Margins.jl achieves performance through tight integration with FormulaCompiler.jl:","category":"page"},{"location":"performance/#Compiled-Formula-Evaluation","page":"Performance Guide","title":"Compiled Formula Evaluation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Single compilation, multiple evaluations\ncompiled = FormulaCompiler.compile_formula(model, data)  # Once\n# Reused across all margin computations - zero allocation per evaluation","category":"page"},{"location":"performance/#Derivative-Computation","page":"Performance Guide","title":"Derivative Computation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Pre-built derivative evaluators\nde = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=vars)  # Once  \n# Reused for all marginal effects - zero allocation per derivative","category":"page"},{"location":"performance/#Buffer-Management","page":"Performance Guide","title":"Buffer Management","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Pre-allocated buffers prevent runtime allocation\nη_buf = Vector{Float64}(undef, n_profiles)      # Linear predictor buffer\ng_buf = Vector{Float64}(undef, n_vars)          # Gradient buffer  \ngβ_accumulator = Vector{Float64}(undef, n_coef) # Parameter gradient buffer","category":"page"},{"location":"performance/#Advanced-Performance-Patterns","page":"Performance Guide","title":"Advanced Performance Patterns","text":"","category":"section"},{"location":"performance/#Caching-Strategies","page":"Performance Guide","title":"Caching Strategies","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# FormulaCompiler artifacts are cached automatically\n# Multiple margin calls on same model/data reuse compilation\nresult1 = population_margins(model, data; type=:effects)      # Compiles\nresult2 = profile_margins(model, data, means_grid(data); type=:effects)  # Reuses compilation","category":"page"},{"location":"performance/#Batch-Processing-Optimization","page":"Performance Guide","title":"Batch Processing Optimization","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Process multiple scenarios efficiently\nscenarios = cartesian_grid(x1=[0,1,2], group=[\"A\",\"B\",\"C\"])  # 9 profiles\n\n# Single compilation, multiple scenario evaluations\nresults = profile_margins(model, data, scenarios; type=:effects)  # Efficient","category":"page"},{"location":"performance/#Production-Deployment-Guidelines","page":"Performance Guide","title":"Production Deployment Guidelines","text":"","category":"section"},{"location":"performance/#Recommended-Configuration","page":"Performance Guide","title":"Recommended Configuration","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# High-performance production settings\nresult = population_margins(\n    model, data;\n    backend = :fd,           # Zero allocation (explicitly requested)\n    scale = :link,           # Link scale\n    type = :effects          # Core functionality\n)","category":"page"},{"location":"performance/#Monitoring-and-Validation","page":"Performance Guide","title":"Monitoring and Validation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Performance monitoring in production\nfunction production_margins(model, data; kwargs...)\n    # Allocation monitoring\n    alloc_before = Base.gc_num().poolalloc\n    \n    result = population_margins(model, data; backend=:fd, kwargs...)\n    \n    alloc_after = Base.gc_num().poolalloc\n    alloc_diff = alloc_after - alloc_before\n    \n    # Log excessive allocations\n    if alloc_diff > 10000  # 10KB threshold\n        @warn \"Excessive allocation detected\" alloc_diff\n    end\n    \n    return result\nend","category":"page"},{"location":"performance/#Error-Handling","page":"Performance Guide","title":"Error Handling","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Robust production wrapper\n# Note: No implicit backend fallbacks. Select `backend` explicitly.","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"This performance guide ensures you can leverage Margins.jl's full computational potential while maintaining statistical rigor in production environments. For conceptual background on why Population vs Profile matters for performance, see Mathematical Foundation. For comprehensive API usage, see API Reference.","category":"page"},{"location":"weights/#Weights-in-Population-Analysis","page":"Weights","title":"Weights in Population Analysis","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"This guide explains how to use observation weights in population_margins, how weighted averaging and delta‑method standard errors are computed, and how weights interact with groups and scenarios.","category":"page"},{"location":"weights/#Scope-and-Policy","page":"Weights","title":"Scope and Policy","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"Weights are supported in population_margins via the weights keyword.\nprofile_margins does not accept weights — profiles evaluate scenarios at reference points without averaging over the sample.\nStatistical correctness: Weighted quantities use proper normalization and delta‑method SEs use the averaged gradient with the model’s full covariance matrix Σ.","category":"page"},{"location":"weights/#Supported-Forms","page":"Weights","title":"Supported Forms","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"weights = nothing (default): Unweighted analysis.\nweights = :colname (Symbol): Column in data with weights (sampling or frequency).\nweights = vector::AbstractVector{<:Real}: Vector of weights with length == nrow(data).","category":"page"},{"location":"weights/#Weighted-Computation","page":"Weights","title":"Weighted Computation","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"Let w_i ≥ 0 be weights for observation i in the current context (after grouping filters). Then:","category":"page"},{"location":"weights/","page":"Weights","title":"Weights","text":"Weighted mean effect: AME = (∑ w_i · Δ_i) / (∑ w_i)\nWeighted averaged gradient: ḡ = (∑ w_i · g_i) / (∑ w_i)\nStandard error (delta method): se = sqrt(ḡ' · Σ · ḡ)","category":"page"},{"location":"weights/","page":"Weights","title":"Weights","text":"Where Δ_i is the per‑row effect (continuous derivative or categorical contrast) and g_i is the corresponding per‑row parameter gradient; Σ is the model covariance matrix.","category":"page"},{"location":"weights/","page":"Weights","title":"Weights","text":"These formulas are used consistently in:","category":"page"},{"location":"weights/","page":"Weights","title":"Weights","text":"Ungrouped population effects and predictions\nGrouped analyses (applied within each subgroup)\nScenario analyses (applied within each scenario × subgroup context)","category":"page"},{"location":"weights/#Examples","page":"Weights","title":"Examples","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"using Random\nusing DataFrames, CategoricalArrays, GLM, Margins\n\nRandom.seed!(123)\nn = 200\ndf = DataFrame(\n    y = randn(n),\n    x = randn(n),\n    z = randn(n),\n    group = categorical(rand([\"A\",\"B\"], n)),\n    samp_w = rand(0.5:0.1:2.0, n),             # sampling weights\n    freq_w = rand([1,2,3,4], n)                 # frequency weights\n)\n\nmodel = lm(@formula(y ~ x + z + group), df)\n\n# 1) Unweighted population AME\name_unw = population_margins(model, df; type=:effects, vars=[:x, :z])\n\n# 2) Sampling weights via column name\name_samp = population_margins(model, df; type=:effects, vars=[:x, :z], weights=:samp_w)\n\n# 3) Frequency weights via column name\name_freq = population_margins(model, df; type=:effects, vars=[:x, :z], weights=:freq_w)\n\n# 4) Explicit weight vector\nwvec = Float64.(df.samp_w)\name_vec = population_margins(model, df; type=:effects, vars=[:x, :z], weights=wvec)\n\n# 5) Grouped weighted analysis\ngrp_samp = population_margins(model, df; type=:effects, vars=[:x], groups=:group, weights=:samp_w)\n\n# 6) Scenarios with weights (counterfactual z values)\nscen_w = population_margins(model, df; type=:effects, vars=[:x], scenarios=(z=[-1.0, 0.0, 1.0]), weights=:samp_w)","category":"page"},{"location":"weights/","page":"Weights","title":"Weights","text":"All results use weighted averaging with proper normalization by the total weight in each context and delta‑method SEs computed from the averaged gradient and full covariance Σ.","category":"page"},{"location":"weights/#Best-Practices","page":"Weights","title":"Best Practices","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"Provide non‑negative weights; zero weights effectively drop observations.\nFor grouped analyses, ensure the weight column/vector aligns with the original data (the implementation indexes weights by original row indices).\nConfirm units/interpretation: sampling vs frequency weights may yield different magnitudes depending on the empirical distribution they imply.\nUse stable data types (Float64 for weight vectors) to avoid implicit conversions.","category":"page"},{"location":"weights/#Error-Handling","page":"Weights","title":"Error Handling","text":"","category":"section"},{"location":"weights/","page":"Weights","title":"Weights","text":"Length mismatch for weights::Vector vs nrow(data) → error.\nInvalid weight column name → error.\nUsing a variable as both a weight and a simultaneous effect variable or grouping key may error if it creates an internal contradiction; prefer distinct columns.","category":"page"},{"location":"profile_margins/#Profile-Specific-Marginal-Effects-Analysis","page":"Profile Analysis","title":"Profile-Specific Marginal Effects Analysis","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Profile-specific marginal effects analysis evaluates marginal quantities at predetermined points within the covariate space, providing inference for representative scenarios and policy counterfactuals. This methodological approach facilitates concrete interpretation of marginal effects through evaluation at theoretically motivated or practically relevant covariate combinations.","category":"page"},{"location":"profile_margins/#Reference-Grid-Methodology","page":"Profile Analysis","title":"Reference Grid Methodology","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"The implementation employs an explicit reference grid specification to ensure methodological transparency and computational flexibility. The core analytical function utilizes the following signature specification:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"profile_margins(model, data, reference_grid; type=:effects, vars=nothing, ...)","category":"page"},{"location":"profile_margins/#Reference-Grid-Construction-Framework","page":"Profile Analysis","title":"Reference Grid Construction Framework","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"The package implements systematic reference grid construction through specialized builder functions that accommodate diverse analytical requirements:","category":"page"},{"location":"profile_margins/#1.-Sample-Means-means_grid()","page":"Profile Analysis","title":"1. Sample Means - means_grid()","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"The canonical approach evaluates marginal quantities at empirical sample means for continuous variables while incorporating frequency-weighted probability mixtures for categorical variables.","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Marginal effects at sample means (MEM)\nresult = profile_margins(model, data, means_grid(data); type=:effects)\n\n# Adjusted predictions at sample means (APM)\nresult = profile_margins(model, data, means_grid(data); type=:predictions)","category":"page"},{"location":"profile_margins/#2.-Cartesian-Product-cartesian_grid()","page":"Profile Analysis","title":"2. Cartesian Product - cartesian_grid()","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Systematic construction of reference grids through Cartesian product enumeration of specified covariate values across multiple dimensions:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Complete factorial design: 3×2 = 6 scenarios\nresult = profile_margins(model, data, \n    cartesian_grid(x=[-1, 0, 1], education=[\"High School\", \"College\"]); \n    type=:effects)\n\n# Single-variable sensitivity analysis with typical values for remaining covariates\nresult = profile_margins(model, data,\n    cartesian_grid(age=20:10:70); \n    type=:predictions)","category":"page"},{"location":"profile_margins/#3.-Balanced-Factorial-balanced_grid()","page":"Profile Analysis","title":"3. Balanced Factorial - balanced_grid()","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Construction of balanced factorial designs utilizing equal-weight probability mixtures for categorical variable specifications:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Balanced factorial design for comprehensive categorical analysis\nresult = profile_margins(model, data,\n    balanced_grid(data; education=:all, region=:all); \n    type=:effects)","category":"page"},{"location":"profile_margins/#4.-Quantile-Based-quantile_grid()","page":"Profile Analysis","title":"4. Quantile-Based - quantile_grid()","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Reference grid construction based on empirical quantiles of continuous variable distributions:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Marginal effects evaluated at income distribution quartiles\nresult = profile_margins(model, data,\n    quantile_grid(data; income=[0.25, 0.5, 0.75]); \n    type=:effects)","category":"page"},{"location":"profile_margins/#5.-Hierarchical-Grammar-hierarchical_grid()","page":"Profile Analysis","title":"5. Hierarchical Grammar - hierarchical_grid()","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Systematic reference grid construction using the group nesting grammar (=> operator) for complex multi-dimensional covariate scenario analysis:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Complex hierarchical specification with multiple representative types\nreference_spec = :region => [\n    (:income, :quartiles),  # Income quartiles within each region\n    (:age, :mean),          # Mean age within each region\n    :education              # All education levels within each region\n]\nresult = profile_margins(model, data, \n    hierarchical_grid(data, reference_spec); \n    type=:effects)\n\n# Deep hierarchical nesting for comprehensive policy analysis\npolicy_spec = :country => (:region => (:education => [(:income, :quintiles), (:age, :mean)]))\nresult = profile_margins(model, data,\n    hierarchical_grid(data, policy_spec; max_depth=4); \n    type=:predictions)","category":"page"},{"location":"profile_margins/#Direct-DataFrame-Specification-(Complete-Analytical-Control)","page":"Profile Analysis","title":"Direct DataFrame Specification (Complete Analytical Control)","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Maximum analytical flexibility is achieved through direct DataFrame specification of reference grid points:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Custom reference grid with explicit covariate specifications\nreference_grid = DataFrame(\n    age=[25, 35, 45], \n    education=[\"High School\", \"College\", \"Graduate\"],\n    experience=[2, 8, 15]\n)\nresult = profile_margins(model, data, reference_grid; type=:effects)","category":"page"},{"location":"profile_margins/#Advanced-Methodological-Features","page":"Profile Analysis","title":"Advanced Methodological Features","text":"","category":"section"},{"location":"profile_margins/#Population-Representative-Categorical-Composition","page":"Profile Analysis","title":"Population-Representative Categorical Composition","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"The implementation addresses the methodological limitation of arbitrary baseline category selection through empirical frequency-weighted categorical mixtures that reflect actual population composition:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Data characteristics: education = 40% HS, 45% College, 15% Graduate\n#                      region = 75% Urban, 25% Rural\n\n# Sample means incorporating realistic categorical composition\nresult = profile_margins(model, data, means_grid(data); type=:effects)\n# → age: empirical sample mean\n# → education: frequency-weighted mixture (40% HS, 45% College, 15% Graduate)  \n# → region: frequency-weighted mixture (75% Urban, 25% Rural)","category":"page"},{"location":"profile_margins/#Fractional-Categorical-Specifications","page":"Profile Analysis","title":"Fractional Categorical Specifications","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Policy counterfactual analysis utilizes fractional categorical specifications through the categorical mixture interface:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"using Margins: mix\n\n# Policy scenario incorporating specific treatment probability distributions\nreference_grid = DataFrame(\n    age=[35, 45, 55],\n    treated=[mix(0 => 0.3, 1 => 0.7)]  # 70% treatment probability\n)\nresult = profile_margins(model, data, reference_grid; type=:predictions)","category":"page"},{"location":"profile_margins/#Profile-Specific-Elasticity-Analysis","page":"Profile Analysis","title":"Profile-Specific Elasticity Analysis","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Elasticity computation at predetermined covariate profiles enables sensitivity analysis across representative scenarios:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Elasticities evaluated at sample means\nresult = profile_margins(model, data, means_grid(data); \n    type=:effects, measure=:elasticity)\n\n# Semi-elasticities across income distribution quantiles\nresult = profile_margins(model, data,\n    cartesian_grid(income=[25000, 50000, 75000]); \n    type=:effects, measure=:semielasticity_dyex)","category":"page"},{"location":"profile_margins/#Computational-Performance-Analysis","page":"Profile Analysis","title":"Computational Performance Analysis","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Profile-specific marginal effects analysis exhibits constant-time computational complexity with execution time independent of dataset dimensionality:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Computational cost remains invariant to dataset size\n@time profile_margins(model, small_data, means_grid(small_data))   # ~100μs\n@time profile_margins(model, large_data, means_grid(large_data))   # ~100μs\n\n# Complex factorial designs maintain constant-time scaling properties\nscenarios = cartesian_grid(x1=[0,1,2], x2=[10,20,30], group=[\"A\",\"B\"])  # 18 profiles\n@time profile_margins(model, huge_data, scenarios)  # Maintains ~100μs complexity","category":"page"},{"location":"profile_margins/#Migration-from-Old-API","page":"Profile Analysis","title":"Migration from Old API","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"If you have code using the deprecated at parameter:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# OLD (deprecated):\nprofile_margins(model, data; at=:means, type=:effects)\nprofile_margins(model, data; at=Dict(:x => [0,1,2]), type=:effects)\n\n# NEW (current):\nprofile_margins(model, data, means_grid(data); type=:effects)  \nprofile_margins(model, data, cartesian_grid(x=[0,1,2]); type=:effects)","category":"page"},{"location":"profile_margins/#Statistical-Notes","page":"Profile Analysis","title":"Statistical Notes","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Standard errors: Computed via delta method using full model covariance matrix\nCategorical effects: Use baseline contrasts vs reference levels at each profile\nProfile interpretation: More concrete than population averages, ideal for policy communication\nComputational efficiency: Single compilation per analysis, reused across all profiles","category":"page"},{"location":"profile_margins/#Output-Structure-and-Result-Multiplicity","page":"Profile Analysis","title":"Output Structure and Result Multiplicity","text":"","category":"section"},{"location":"profile_margins/#Result-Row-Generation-Pattern","page":"Profile Analysis","title":"Result Row Generation Pattern","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"The number of output rows depends on variable types and categorical levels:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"Continuous variables: 1 reference grid row → 1 output row (derivative)\nCategorical variables: 1 reference grid row → Multiple output rows (baseline contrasts)","category":"page"},{"location":"profile_margins/#Example-Output-Multiplicity","page":"Profile Analysis","title":"Example Output Multiplicity","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Reference grid with 2 profiles\ngrid = DataFrame(\n    age = [30, 40],                    # Continuous variable\n    education = [\"A\", \"B\", \"C\"]        # Categorical with 3 levels\n)\n\n# Results: 2 profiles × (1 continuous + 2 categorical contrasts) = 6 total rows:\nresult = profile_margins(model, data, grid; type=:effects, vars=[:age, :education])\n\n# Output structure:\n# Row 1: age at (age=30, education=\"A,B,C\")\n# Row 2: education: B vs A at (age=30, education=\"A,B,C\")  \n# Row 3: education: C vs A at (age=30, education=\"A,B,C\")\n# Row 4: age at (age=40, education=\"A,B,C\")\n# Row 5: education: B vs A at (age=40, education=\"A,B,C\")\n# Row 6: education: C vs A at (age=40, education=\"A,B,C\")","category":"page"},{"location":"profile_margins/#Categorical-Baseline-Contrasts","page":"Profile Analysis","title":"Categorical Baseline Contrasts","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"For a categorical variable with K levels, each reference grid row generates:","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"K-1 contrast rows comparing each non-baseline level to the baseline\nTerm names follow pattern: \"variable: level vs baseline\"\nExample: 4-level categorical produces 3 contrasts (B vs A, C vs A, D vs A)","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"This multiplicative pattern means that reference grids with multiple categorical variables can generate substantial numbers of result rows, enabling comprehensive categorical effect analysis at each profile.","category":"page"},{"location":"profile_margins/#Examples","page":"Profile Analysis","title":"Examples","text":"","category":"section"},{"location":"profile_margins/#Basic-Workflow","page":"Profile Analysis","title":"Basic Workflow","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"using DataFrames, GLM, Margins\n\n# Fit model\nmodel = lm(@formula(y ~ x1 + x2 + group), data)\n\n# Effects at sample means\nmem_results = profile_margins(model, data, means_grid(data); type=:effects)\nDataFrame(mem_results)\n\n# Predictions at specific scenarios\nscenarios = cartesian_grid(x1=[0, 1, 2], group=[\"A\", \"B\"])\npredictions = profile_margins(model, data, scenarios; type=:predictions)\nDataFrame(predictions)","category":"page"},{"location":"profile_margins/#Policy-Analysis","page":"Profile Analysis","title":"Policy Analysis","text":"","category":"section"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"# Current scenario: actual data composition\ncurrent = profile_margins(model, data, means_grid(data); type=:predictions)\n\n# Policy scenario: increased education levels\npolicy_grid = DataFrame(\n    x1=mean(data.x1),\n    education=mix(\"High School\" => 0.2, \"College\" => 0.5, \"Graduate\" => 0.3)\n)\nfuture = profile_margins(model, data, policy_grid; type=:predictions)\n\n# Compare scenarios\npolicy_effect = DataFrame(future).estimate[1] - DataFrame(current).estimate[1]","category":"page"},{"location":"profile_margins/","page":"Profile Analysis","title":"Profile Analysis","text":"See also: population_margins for population-averaged analysis.","category":"page"},{"location":"advanced/#Advanced-Features","page":"Advanced Features","title":"Advanced Features","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Elasticities, robust standard errors, and specialized analysis techniques","category":"page"},{"location":"advanced/#Elasticities-and-Semi-Elasticities","page":"Advanced Features","title":"Elasticities and Semi-Elasticities","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Margins.jl provides comprehensive elasticity support through the measure parameter, following the same Population vs Profile framework as standard marginal effects. For conceptual background on the 2×2 framework, see Mathematical Foundation.","category":"page"},{"location":"advanced/#Types-of-Elasticity-Measures","page":"Advanced Features","title":"Types of Elasticity Measures","text":"","category":"section"},{"location":"advanced/#Standard-Elasticity","page":"Advanced Features","title":"Standard Elasticity","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Definition: Percent change in Y per percent change in X Formula: (∂Y/∂X) × (X/Y) Interpretation: \"A 1% increase in X leads to an ε% change in Y\"","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Population average elasticities\npopulation_margins(model, data; type=:effects, measure=:elasticity)\n\n# Elasticities at sample means\nprofile_margins(model, data, means_grid(data); type=:effects, measure=:elasticity)","category":"page"},{"location":"advanced/#Semi-Elasticity-with-respect-to-X","page":"Advanced Features","title":"Semi-Elasticity with respect to X","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Definition: Percent change in Y per unit change in X Formula: (∂Y/∂X) × (1/Y) Interpretation: \"A 1-unit increase in X leads to a (100×ε)% change in Y\"","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Population average semi-elasticities (X)\npopulation_margins(model, data; measure=:semielasticity_dyex)\n\n# Semi-elasticities at specific scenarios\nprofile_margins(model, data, cartesian_grid(x1=[0,1,2]); measure=:semielasticity_dyex)","category":"page"},{"location":"advanced/#Semi-Elasticity-with-respect-to-Y","page":"Advanced Features","title":"Semi-Elasticity with respect to Y","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Definition: Unit change in Y per percent change in X   Formula: (∂Y/∂X) × X Interpretation: \"A 1% increase in X leads to an ε-unit change in Y\"","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Population average semi-elasticities (Y)\npopulation_margins(model, data; measure=:semielasticity_eydx)","category":"page"},{"location":"advanced/#Elasticity-Framework-Application","page":"Advanced Features","title":"Elasticity Framework Application","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Elasticities follow the same Population vs Profile distinction as marginal effects (see Mathematical Foundation for detailed framework explanation):","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Measure Population Approach Profile Approach\nElasticity Average of (∂Y/∂X) × (Xᵢ/Yᵢ) across sample (∂Y/∂X) × (X̄/Ȳ) at representative values\nSemi-elasticity (X) Average of (∂Y/∂X) × (1/Yᵢ) across sample (∂Y/∂X) × (1/Ȳ) at representative values\nSemi-elasticity (Y) Average of (∂Y/∂X) × Xᵢ across sample (∂Y/∂X) × X̄ at representative values","category":"page"},{"location":"advanced/#Practical-Example:-Wage-Elasticities","page":"Advanced Features","title":"Practical Example: Wage Elasticities","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"using Margins, DataFrames, GLM\n\n# Economic data: wages, education, experience\ndf = DataFrame(\n    log_wage = randn(1000) .+ 2.5,  # Log wages\n    education = rand(12:20, 1000),   # Years of education  \n    experience = rand(0:30, 1000),   # Years of experience\n    age = rand(25:55, 1000)\n)\n\nmodel = lm(@formula(log_wage ~ education + experience + age), df)\n\n# Education elasticity of wages (population average)\nedu_elasticity = population_margins(model, df; \n                                   vars=[:education], \n                                   measure=:elasticity)\nprintln(\"Population average education elasticity: \", DataFrame(edu_elasticity))\n\n# Education elasticity at different experience levels (profile analysis)  \nexp_scenarios = profile_margins(model, df,\n                               cartesian_grid(experience=[0, 10, 20, 30]);\n                               vars=[:education],\n                               measure=:elasticity)\nprintln(\"Education elasticity by experience level:\")\nprintln(DataFrame(exp_scenarios))\n\n# Semi-elasticity: percent wage change per year of education\nedu_semielast = population_margins(model, df;\n                                  vars=[:education],\n                                  measure=:semielasticity_dyex)\nprintln(\"Education semi-elasticity: \", DataFrame(edu_semielast))","category":"page"},{"location":"advanced/#When-Profile-Population-for-Elasticities","page":"Advanced Features","title":"When Profile ≠ Population for Elasticities","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"In GLMs with non-identity links, population and profile elasticities can differ substantially:","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Logistic model example\nlogit_model = glm(@formula(employed ~ education + experience), df, Binomial(), LogitLink())\n\n# Population average employment elasticity w.r.t. education\npop_elastic = population_margins(logit_model, df; vars=[:education], measure=:elasticity)\n\n# Employment elasticity at sample means\nprof_elastic = profile_margins(logit_model, df, means_grid(df); vars=[:education], measure=:elasticity)\n\n# These will differ because logistic function is nonlinear\nprintln(\"Population elasticity: \", DataFrame(pop_elastic).estimate[1])\nprintln(\"Profile elasticity: \", DataFrame(prof_elastic).estimate[1])","category":"page"},{"location":"advanced/#Robust-Standard-Errors","page":"Advanced Features","title":"Robust Standard Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Margins.jl integrates seamlessly with Julia's robust standard error ecosystem, particularly CovarianceMatrices.jl.","category":"page"},{"location":"advanced/#Integration-Philosophy","page":"Advanced Features","title":"Integration Philosophy","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Responsibility separation: Margins.jl computes marginal effects; CovarianceMatrices.jl computes robust covariances\nDelta-method interface: Margins only needs a parameter covariance matrix Σ for standard error computation\nModel ecosystem compatibility: Uses same covariance sources as GLM.jl/StatsModels.jl","category":"page"},{"location":"advanced/#Basic-Robust-Standard-Errors","page":"Advanced Features","title":"Basic Robust Standard Errors","text":"","category":"section"},{"location":"advanced/#Heteroskedasticity-Robust-(White/Huber-White)","page":"Advanced Features","title":"Heteroskedasticity-Robust (White/Huber-White)","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"using CovarianceMatrices\n\n# Apply robust covariance via vcov parameter\nrobust_effects = population_margins(model, data; vcov=CovarianceMatrices.HC1, type=:effects)","category":"page"},{"location":"advanced/#Available-Robust-Estimators","page":"Advanced Features","title":"Available Robust Estimators","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Different heteroskedasticity-robust variants\nHC0()  # Basic White estimator\nHC1()  # Degrees-of-freedom adjusted (most common)\nHC2()  # Leverage-adjusted  \nHC3()  # Jackknife-type\nHC4()  # High-leverage robust\nHC5()  # Outlier-robust\n\n# Example with HC3\nresult = population_margins(model, data; vcov=CovarianceMatrices.HC3)","category":"page"},{"location":"advanced/#Clustered-Standard-Errors","page":"Advanced Features","title":"Clustered Standard Errors","text":"","category":"section"},{"location":"advanced/#Single-Level-Clustering","page":"Advanced Features","title":"Single-Level Clustering","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Cluster by firm ID\nclustered_effects = population_margins(model, data; \n    vcov=CovarianceMatrices.Clustered(:firm_id), type=:effects)","category":"page"},{"location":"advanced/#Multi-Level-Clustering","page":"Advanced Features","title":"Multi-Level Clustering","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Two-way clustering (firm and year)\nresult = population_margins(model, data; vcov=CovarianceMatrices.Clustered([:firm_id, :year]))","category":"page"},{"location":"advanced/#HAC-(Heteroskedasticity-and-Autocorrelation-Consistent)-Standard-Errors","page":"Advanced Features","title":"HAC (Heteroskedasticity and Autocorrelation Consistent) Standard Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Newey-West HAC estimator\neffects_hac = population_margins(model, data; \n    vcov=CovarianceMatrices.HAC(kernel=:bartlett, bandwidth=4), type=:effects)","category":"page"},{"location":"advanced/#Custom-Covariance-Providers","page":"Advanced Features","title":"Custom Covariance Providers","text":"","category":"section"},{"location":"advanced/#Function-Based-Covariance","page":"Advanced Features","title":"Function-Based Covariance","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Custom covariance function (must return an AbstractMatrix)\nfunction my_robust_vcov(model)\n    # ... compute covariance from model ...\n    return Σ::AbstractMatrix\nend\n\n# Use custom function directly\nresult = population_margins(model, data; vcov=my_robust_vcov)","category":"page"},{"location":"advanced/#Robust-Standard-Errors-with-Elasticities","page":"Advanced Features","title":"Robust Standard Errors with Elasticities","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Robust standard errors work seamlessly with all elasticity measures:","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Robust elasticity estimates\nrobust_elasticities = population_margins(model, data; \n    vcov=CovarianceMatrices.HC1,\n    measure=:elasticity, type=:effects)\n\n# Profile elasticities with clustered SEs  \nprofile_elasticities = profile_margins(model, data,\n    means_grid(data); vcov=CovarianceMatrices.Clustered(:cluster_var),\n    measure=:elasticity)","category":"page"},{"location":"advanced/#Categorical-Mixtures-for-Policy-Analysis","page":"Advanced Features","title":"Categorical Mixtures for Policy Analysis","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Margins.jl supports categorical mixtures for realistic policy scenario analysis, allowing specification of population compositions rather than arbitrary category levels.","category":"page"},{"location":"advanced/#Motivation:-Realistic-Population-Scenarios","page":"Advanced Features","title":"Motivation: Realistic Population Scenarios","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Traditional marginal effects often use arbitrary categorical values (e.g., \"set all observations to treatment=1\"). Categorical mixtures enable realistic population compositions:","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"using CategoricalArrays, Margins\n\n# Instead of: \"All treated\" (unrealistic)\nunrealistic = profile_margins(model, data, cartesian_grid(treatment=[1]); type=:predictions)\n\n# Use: Realistic treatment rate  \nrealistic = profile_margins(model, data, \n                           DataFrame(treatment=[mix(0 => 0.3, 1 => 0.7)]))  # 70% treatment rate","category":"page"},{"location":"advanced/#Frequency-Weighted-Categorical-Defaults","page":"Advanced Features","title":"Frequency-Weighted Categorical Defaults","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"When categorical variables are unspecified in profiles, Margins.jl uses actual sample frequencies rather than arbitrary first levels:","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Data composition: education = 40% HS, 45% College, 15% Graduate\n#                   region = 60% Urban, 40% Rural\n\n# Effects \"at means\" uses realistic composition\nresult = profile_margins(model, data, means_grid(data); type=:effects)\n# → Continuous vars: sample means\n# → education: mix(\"HS\" => 0.40, \"College\" => 0.45, \"Graduate\" => 0.15)  \n# → region: mix(\"Urban\" => 0.60, \"Rural\" => 0.40)","category":"page"},{"location":"advanced/#Policy-Scenario-Analysis","page":"Advanced Features","title":"Policy Scenario Analysis","text":"","category":"section"},{"location":"advanced/#Demographic-Transition-Scenarios","page":"Advanced Features","title":"Demographic Transition Scenarios","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Current population composition\ncurrent_scenario = profile_margins(model, data,\n    DataFrame(education=[mix(\"HS\" => 0.40, \"College\" => 0.45, \"Graduate\" => 0.15)]);\n    type=:predictions)\n\n# Future scenario: increased college graduation\nfuture_scenario = profile_margins(model, data,\n    DataFrame(education=[mix(\"HS\" => 0.25, \"College\" => 0.60, \"Graduate\" => 0.15)]);\n    type=:predictions)\n\n# Policy impact\nimpact = DataFrame(future_scenario).estimate[1] - DataFrame(current_scenario).estimate[1]","category":"page"},{"location":"advanced/#Treatment-Effect-Heterogeneity","page":"Advanced Features","title":"Treatment Effect Heterogeneity","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Treatment effects across population compositions\ntreatment_scenarios = DataFrame([\n    (treatment=0, education=mix(\"HS\" => 0.5, \"College\" => 0.5)),\n    (treatment=1, education=mix(\"HS\" => 0.5, \"College\" => 0.5)),\n    (treatment=0, education=mix(\"HS\" => 0.2, \"College\" => 0.8)),  \n    (treatment=1, education=mix(\"HS\" => 0.2, \"College\" => 0.8))\n])\n\nresults = profile_margins(model, data, treatment_scenarios; type=:predictions)\ntreatment_effects_df = DataFrame(results)","category":"page"},{"location":"advanced/#Advanced-Grouping-and-Stratification","page":"Advanced Features","title":"Advanced Grouping and Stratification","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"Margins.jl provides a comprehensive grouping framework for population-based marginal effects analysis, supporting hierarchical stratification patterns that extend far beyond traditional approaches.","category":"page"},{"location":"advanced/#Hierarchical-Grouping-Framework","page":"Advanced Features","title":"Hierarchical Grouping Framework","text":"","category":"section"},{"location":"advanced/#Basic-Grouping-Patterns","page":"Advanced Features","title":"Basic Grouping Patterns","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Simple categorical grouping\ndemographic_effects = population_margins(model, data;\n                                        type=:effects,\n                                        vars=[:income],\n                                        groups=:education)\n\n# Cross-tabulated grouping\ncross_effects = population_margins(model, data;\n                                 type=:effects,\n                                 vars=[:income], \n                                 groups=[:education, :region])","category":"page"},{"location":"advanced/#Nested-Hierarchical-Grouping","page":"Advanced Features","title":"Nested Hierarchical Grouping","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Hierarchical nesting: region → education within each region\nnested_effects = population_margins(model, data;\n                                  type=:effects,\n                                  vars=[:income],\n                                  groups=:region => :education)\n\n# Deep nesting: region → urban → education\ndeep_nested = population_margins(model, data;\n                               type=:effects,\n                               groups=:region => (:urban => :education))","category":"page"},{"location":"advanced/#Continuous-Variable-Binning","page":"Advanced Features","title":"Continuous Variable Binning","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Quartile analysis\nincome_quartiles = population_margins(model, data;\n                                    type=:effects,\n                                    groups=(:income, 4))  # Q1, Q2, Q3, Q4\n\n# Custom policy-relevant thresholds\npolicy_thresholds = population_margins(model, data;\n                                     type=:effects,\n                                     groups=(:income, [25000, 50000, 75000]))\n\n# Mixed categorical and continuous\nmixed_groups = population_margins(model, data;\n                                type=:effects,\n                                groups=[:education, (:income, 4)])","category":"page"},{"location":"advanced/#Counterfactual-Scenario-Analysis","page":"Advanced Features","title":"Counterfactual Scenario Analysis","text":"","category":"section"},{"location":"advanced/#Policy-Scenarios-with-Population-Override","page":"Advanced Features","title":"Policy Scenarios with Population Override","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Binary policy scenarios\npolicy_analysis = population_margins(model, data;\n                                   type=:effects,\n                                   vars=[:outcome],\n                                   scenarios=(:policy => [0, 1]))\n\n# Multi-variable scenarios\ncomplex_scenarios = population_margins(model, data;\n                                     type=:effects,\n                                     scenarios=(:treatment => [0, 1], \n                                                   :policy => [\"current\", \"reform\"]))","category":"page"},{"location":"advanced/#Combined-Grouping-and-Scenarios","page":"Advanced Features","title":"Combined Grouping and Scenarios","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Comprehensive policy analysis: demographics × policy scenarios\nfull_analysis = population_margins(model, data;\n                                 type=:effects,\n                                 vars=[:outcome],\n                                 groups=[:education, :region],\n                                 scenarios=(:treatment => [0, 1]))","category":"page"},{"location":"advanced/#Complex-Nested-Patterns","page":"Advanced Features","title":"Complex Nested Patterns","text":"","category":"section"},{"location":"advanced/#Parallel-Grouping-Within-Hierarchy","page":"Advanced Features","title":"Parallel Grouping Within Hierarchy","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Region → (education levels + income quartiles separately)\nparallel_groups = population_margins(model, data;\n                                   type=:effects,\n                                   groups=:region => [:education, (:income, 4)])","category":"page"},{"location":"advanced/#Advanced-Policy-Applications","page":"Advanced Features","title":"Advanced Policy Applications","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Healthcare policy analysis\nhealthcare_analysis = population_margins(health_model, health_data;\n    type=:effects,\n    groups=:state => (:urban => [:insurance_type, (:income, 3)]),\n    scenarios=(:policy_reform => [0, 1], :funding_level => [0.8, 1.2])\n)\n\n# Results: State × Urban/Rural × (Insurance×Income-Tertiles) × Policy×Funding scenarios","category":"page"},{"location":"advanced/#Error-Handling-and-Diagnostics","page":"Advanced Features","title":"Error Handling and Diagnostics","text":"","category":"section"},{"location":"advanced/#Robust-Error-Detection","page":"Advanced Features","title":"Robust Error Detection","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Check for statistical validity issues\nfunction validate_margins_result(result::MarginsResult)\n    df = DataFrame(result)\n    \n    # Check for excessive standard errors (potential issues)\n    large_se = df[df.se .> 10 * abs.(df.estimate), :]\n    if nrow(large_se) > 0\n        @warn \"Large standard errors detected - potential statistical issues\"\n        println(large_se)\n    end\n    \n    # Check for missing values\n    missing_results = df[ismissing.(df.estimate) .| ismissing.(df.se), :]\n    if nrow(missing_results) > 0\n        @warn \"Missing values in results - check model specification\"\n    end\n    \n    return df\nend\n\n# Usage\nresult = population_margins(model, data)\nvalidated_df = validate_margins_result(result)","category":"page"},{"location":"advanced/#Covariance-Matrix-Diagnostics","page":"Advanced Features","title":"Covariance Matrix Diagnostics","text":"","category":"section"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"# Check covariance matrix properties\nfunction diagnose_vcov(model)\n    Σ = vcov(model)\n    \n    # Check positive definiteness\n    eigenvals = eigvals(Σ)\n    if any(eigenvals .< 1e-12)\n        @warn \"Covariance matrix near-singular - standard errors may be unreliable\"\n    end\n    \n    # Check condition number\n    cond_num = cond(Σ)\n    if cond_num > 1e12\n        @warn \"Poorly conditioned covariance matrix - numerical issues possible\"\n    end\n    \n    return (eigenvals=eigenvals, condition_number=cond_num)\nend","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"","category":"page"},{"location":"advanced/","page":"Advanced Features","title":"Advanced Features","text":"These advanced features enable sophisticated econometric analysis while maintaining Margins.jl's core principles of statistical correctness and computational efficiency. For conceptual foundation on when to use elasticities vs marginal effects, see Mathematical Foundation. For elasticity performance characteristics, see Performance Guide.","category":"page"},{"location":"dev/performance/#Developer-Performance-Guide","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"","category":"section"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"This page summarizes best practices to ensure O(1) allocations in production paths without compromising statistical correctness. It mirrors PERFORMANCEBESTPRACTICES.md at the repo root for convenient browsing.","category":"page"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"See also: ../../PERFORMANCEBESTPRACTICES.md (same content).","category":"page"},{"location":"dev/performance/#Core-Principles","page":"Developer Performance Guide","title":"Core Principles","text":"","category":"section"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"Preserve statistical validity (delta-method, full Σ) at all times\nAim for constant allocations w.r.t. sample size in production code\nPreallocate once; reuse buffers and result tables\nAvoid dynamic growth in hot paths","category":"page"},{"location":"dev/performance/#Patterns-That-Work","page":"Developer Performance Guide","title":"Patterns That Work","text":"","category":"section"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"Compile/cache FormulaCompiler artifacts outside loops\nMove hot loops into helpers that take concrete arguments (compiled, row_buf, β, link, de)\nReuse row_buf, η_buf, g_buf, gβ_accumulator; avoid temporary vectors\nPrefer scalar loops over broadcasts that allocate\nPreallocate DataFrame columns and assign by index","category":"page"},{"location":"dev/performance/#Validation","page":"Developer Performance Guide","title":"Validation","text":"","category":"section"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"Use validate_allocations.jl; rely on tags:\n[PROD]: production code paths — must be O(1)\n[TEST]: diagnostic loops — may allocate by design for isolation","category":"page"},{"location":"dev/performance/","page":"Developer Performance Guide","title":"Developer Performance Guide","text":"Expected (validated): _population_predictions, population_margins (pred/effects) show constant allocations.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Comprehensive technical specification for Margins.jl functions and types","category":"page"},{"location":"api/#Conceptual-Foundation","page":"API Reference","title":"Conceptual Foundation","text":"","category":"section"},{"location":"api/#Two-Function-Architecture","page":"API Reference","title":"Two-Function Architecture","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package implements a systematic two-function API that operationalizes the unified analytical framework through distinct computational pathways for population-level and profile-specific marginal effects analysis.","category":"page"},{"location":"api/#Analysis-Type-Distinction","page":"API Reference","title":"Analysis Type Distinction","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Population Analysis: Integration over empirical covariate distributions\nProfile Analysis: Evaluation at specified covariate combinations","category":"page"},{"location":"api/#Function-Specifications","page":"API Reference","title":"Function Specifications","text":"","category":"section"},{"location":"api/#Population-Analysis","page":"API Reference","title":"Population Analysis","text":"","category":"section"},{"location":"api/#population_margins","page":"API Reference","title":"population_margins","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Computes population-level marginal effects or adjusted predictions through integration over the empirical distribution of observed covariates.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The function implements population-averaged inference by computing marginal quantities for each observation in the sample and subsequently averaging these quantities according to the empirical distribution. This approach yields population parameters that reflect the heterogeneity present in the data generating process while providing appropriate standard errors through delta-method computation with full covariance matrix integration.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Methodological Applications: Population analysis provides unbiased estimates of population parameters suitable for policy evaluation requiring external validity to similar populations. The approach proves particularly valuable when sample heterogeneity represents important features of the underlying population, and when analytical applications affect diverse demographic or economic groups requiring representative inference.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Computational Characteristics: Linear scaling with respect to sample size while maintaining minimal per-observation computational overhead through optimized implementations. Detailed performance analysis and computational complexity comparisons are provided in the Performance Guide","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"See also: Population Scenarios for counterfactual analysis and Weights for sampling/frequency weights.","category":"page"},{"location":"api/#Profile-Analysis","page":"API Reference","title":"Profile Analysis","text":"","category":"section"},{"location":"api/#profile_margins","page":"API Reference","title":"profile_margins","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Computes marginal effects or adjusted predictions evaluated at specified covariate combinations within the covariate space.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The function implements profile-specific inference through evaluation of marginal quantities at predetermined points in the covariate space, typically at sample means or theoretically motivated scenario specifications. This approach yields concrete, interpretable estimates for specific covariate combinations while maintaining appropriate uncertainty quantification through delta-method standard error computation.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Methodological Applications:   Profile analysis provides representative case inference suitable for policy targeting specific demographic or economic profiles. The approach facilitates clear communication of quantitative results through concrete scenario interpretation, making it particularly valuable for stakeholder communication and policy applications requiring specific target group analysis.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Computational Characteristics: Constant-time complexity independent of dataset size through optimized evaluation algorithms that avoid full dataset traversal. Comprehensive performance benchmarking and memory allocation analysis are detailed in the Performance Guide","category":"page"},{"location":"api/#Result-Type-Specifications","page":"API Reference","title":"Result Type Specifications","text":"","category":"section"},{"location":"api/#Type-Safe-Result-System-(v2.0)","page":"API Reference","title":"Type-Safe Result System (v2.0)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Margins.jl implements a specialized type system that provides type safety and optimized DataFrame formatting through distinct result containers for different analysis types.","category":"page"},{"location":"api/#EffectsResult","page":"API Reference","title":"EffectsResult","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Structured container for marginal effects analysis (AME, MEM, MER) implementing the Tables.jl interface protocol.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The EffectsResult type encapsulates computed marginal effects along with associated statistical inference quantities including standard errors, confidence intervals, and hypothesis test statistics. The type contains variable identification fields (variables, terms) essential for effects interpretation and supports multiple DataFrame formatting options.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Key Features:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Contains variables field (the \"x\" in dy/dx identification)  \nContains terms field (contrast descriptions like \"derivative\", \"treated vs control\")\nMultiple DataFrame formats: :standard, :compact, :confidence, :profile, :stata\nAuto-detects appropriate format based on analysis type","category":"page"},{"location":"api/#PredictionsResult","page":"API Reference","title":"PredictionsResult","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Streamlined container for predictions analysis (AAP, APM, APR) implementing the Tables.jl interface protocol.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The PredictionsResult type focuses specifically on predicted values without variable/contrast concepts, providing a clean interface optimized for predictions analysis. The streamlined design reflects that predictions represent \"fitted values at scenarios\" rather than \"effects of variables.\"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Key Features:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Omits variable/contrast fields (not applicable to predictions)\nSingle optimized DataFrame format for predictions display  \nClean tabular output focused on prediction values and statistics","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Data Integration Framework:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Type-specific result containers with Tables.jl protocol\neffects_result = population_margins(model, data; type=:effects)  # Returns EffectsResult\npredictions_result = population_margins(model, data; type=:predictions)  # Returns PredictionsResult\n\n# Type-specific DataFrame conversion\neffects_df = DataFrame(effects_result)  # Includes variable/contrast columns\npredictions_df = DataFrame(predictions_result)  # Streamlined predictions format\n\n# Multiple format options for effects\nDataFrame(effects_result; format=:compact)  # Minimal columns\nDataFrame(effects_result; format=:stata)    # Stata-style column names\n\n# Compatible with all Tables.jl-compliant output formats  \nCSV.write(\"effects.csv\", effects_result)\nCSV.write(\"predictions.csv\", predictions_result)","category":"page"},{"location":"api/#Extended-Analytical-Capabilities","page":"API Reference","title":"Extended Analytical Capabilities","text":"","category":"section"},{"location":"api/#Categorical-Mixture-Specifications","page":"API Reference","title":"Categorical Mixture Specifications","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The package implements sophisticated categorical mixture functionality to enable realistic policy scenario analysis through fractional category specifications. The CategoricalMixture type facilitates the specification of probability-weighted categorical distributions that reflect realistic population compositions rather than arbitrary baseline categories.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Policy Counterfactual Analysis:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Current population educational composition (predictions at a mixture)\nbaseline_grid = DataFrame(education=[mix(\"HS\" => 0.4, \"College\" => 0.4, \"Graduate\" => 0.2)])\nbaseline = profile_margins(model, data, baseline_grid; type=:predictions)\n\n# Policy counterfactual: educational attainment improvement (new mixture)\nintervention_grid = DataFrame(education=[mix(\"HS\" => 0.2, \"College\" => 0.5, \"Graduate\" => 0.3)])\nintervention = profile_margins(model, data, intervention_grid; type=:predictions)","category":"page"},{"location":"api/#Parameter-Reference","page":"API Reference","title":"Parameter Reference","text":"","category":"section"},{"location":"api/#Common-Parameters","page":"API Reference","title":"Common Parameters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Quick Start Examples:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"type=:effects → \"How much does the outcome change?\" (most common)  \ntype=:predictions → \"What outcome value should I expect?\"\nmeasure=:elasticity → \"What's the percentage effect?\" (useful for proportional changes)\nbackend=:ad → Use default (most accurate, zero allocation)\nbackend=:fd → Alternative backend (legacy compatibility)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"All main functions support these core parameters:","category":"page"},{"location":"api/#Analysis-Type-(type)","page":"API Reference","title":"Analysis Type (type)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":":effects - Marginal effects (derivatives for continuous, contrasts for categorical)\n:predictions - Adjusted predictions (fitted values)","category":"page"},{"location":"api/#Variable-Selection-(vars)","page":"API Reference","title":"Variable Selection (vars)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"nothing - Auto-detect continuous variables (default for effects)\n:all_continuous - Explicit selection of all continuous variables\n:variable_name - Single variable\n[:var1, :var2] - Multiple specific variables","category":"page"},{"location":"api/#Target-Scale-(scale)","page":"API Reference","title":"Target Scale (scale)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":":response - Response scale (default, applies inverse link function)\n:link - Linear predictor scale (link scale)","category":"page"},{"location":"api/#Computational-Backend-(backend)","page":"API Reference","title":"Computational Backend (backend)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":":ad - Automatic differentiation (default; higher accuracy, zero allocation after warmup)\n:fd - Finite differences (zero allocation, production-ready)","category":"page"},{"location":"api/#Effect-Measures-(measure)","page":"API Reference","title":"Effect Measures (measure)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":":effect - Standard marginal effects (default)\n:elasticity - Elasticities (% change in Y per % change in X)\n:semielasticity_dyex - Semielasticity d(y)/d(ln x) (change in Y per % change in X)\n:semielasticity_eydx - Semielasticity d(ln y)/dx (% change in Y per unit change in X)","category":"page"},{"location":"api/#Profile-Specific-Parameters","page":"API Reference","title":"Profile-Specific Parameters","text":"","category":"section"},{"location":"api/#Profile-Specification-(at)","page":"API Reference","title":"Profile Specification (at)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":":means - Effects/predictions at sample means\nDict(:var => [val1, val2]) - Cartesian product specification\n[Dict(:var => val1), Dict(:var => val2)] - Explicit profile list\nDataFrame - Pre-built reference grid (maximum control)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Examples:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# At sample means (most common)\nprofile_margins(model, data, means_grid(data))\n\n# Cartesian product: 6 scenarios (3×2)\nprofile_margins(model, data, cartesian_grid(x=[0,1,2], group=[\"A\",\"B\"]))\n\n# Hierarchical grid construction using group grammar\nreference_spec = :region => [(:income, :quartiles), (:age, :mean)]\nprofile_margins(model, data, hierarchical_grid(data, reference_spec))\n\n# Deep hierarchical nesting for complex policy analysis\npolicy_spec = :country => (:region => (:education => [(:income, :quintiles), (:age, :mean)]))\nprofile_margins(model, data, hierarchical_grid(data, policy_spec; max_depth=4))\n\n# DataFrame grid (full control)\ngrid = DataFrame(x=[0,1,2], group=[\"A\",\"A\",\"B\"])\nprofile_margins(model, data, grid)","category":"page"},{"location":"api/#Population-Specific-Parameters","page":"API Reference","title":"Population-Specific Parameters","text":"","category":"section"},{"location":"api/#Grouping-(over)","page":"API Reference","title":"Grouping (over)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Symbol - Single grouping variable\nVector{Symbol} - Multiple grouping variables  \nNamedTuple - Advanced grouping with value specifications","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Examples:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# By single categorical variable\npopulation_margins(model, data; groups=:region)\n\n# Multiple grouping\npopulation_margins(model, data; groups=[:region, :year])\n\n# Advanced grouping (unified syntax)\npopulation_margins(model, data; groups=(:income, [20000, 50000, 80000]))","category":"page"},{"location":"api/#Counterfactual-Analysis-(scenarios)","page":"API Reference","title":"Counterfactual Analysis (scenarios)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Effects when treatment is set to 1 vs 0 for entire population\npopulation_margins(model, data; scenarios=(treatment=[0, 1]), type=:effects)","category":"page"},{"location":"api/#Usage-Patterns","page":"API Reference","title":"Usage Patterns","text":"","category":"section"},{"location":"api/#Basic-Workflow","page":"API Reference","title":"Basic Workflow","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# 1. Fit model\nmodel = lm(@formula(y ~ x1 + x2 + group), data)\n\n# 2. Population analysis (most common starting point)\name = population_margins(model, data)\naap = population_margins(model, data; type=:predictions)\n\n# 3. Profile analysis for specific scenarios\nmem = profile_margins(model, data, means_grid(data))\nscenarios = profile_margins(model, data, cartesian_grid(x1=[0,1,2]))\n\n# 4. Convert to DataFrame for analysis\nDataFrame(ame)","category":"page"},{"location":"api/#Performance-Optimization","page":"API Reference","title":"Performance Optimization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Maximum performance configuration\nfast_result = population_margins(model, data; backend=:fd, scale=:link)\n\n# Profile analysis is O(1) - efficient regardless of data size\nscenarios = (var1=[-2,-1,0,1,2], var2=[\"A\",\"B\",\"C\"])  # 15 scenarios\nscenarios = cartesian_grid(x1=[0,1,2])\nprofile_result = profile_margins(model, huge_data, scenarios)  # ~300μs regardless of data size","category":"page"},{"location":"api/#Advanced-Analysis-Patterns","page":"API Reference","title":"Advanced Analysis Patterns","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Elasticity analysis across scenarios (profile)\nscenarios = cartesian_grid(x1=[0, 1, 2])\nelasticities = profile_margins(model, data, scenarios; \n    measure=:elasticity, vars=[:x2])\n\n# Robust standard errors (with CovarianceMatrices.jl)\nusing CovarianceMatrices\nrobust_effects = population_margins(model, data; vcov=CovarianceMatrices.HC1)\n\n# Complex categorical scenarios via reference grid\npolicy_grid = DataFrame(\n    treatment=[mix(0 => 0.3, 1 => 0.7)],           # 70% treatment rate\n    education=[mix(\"HS\" => 0.3, \"College\" => 0.7)] # Education composition\n)\npolicy_scenario = profile_margins(model, data, policy_grid; type=:predictions)","category":"page"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/#Common-Error-Patterns","page":"API Reference","title":"Common Error Patterns","text":"","category":"section"},{"location":"api/#Variable-Specification-Errors","page":"API Reference","title":"Variable Specification Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Error: Variable not found\npopulation_margins(model, data; vars=[:nonexistent_var])\n# → Clear error message with available variables\n\n# Error: Wrong variable type for effects  \npopulation_margins(model, data; vars=[:categorical_var], type=:effects)\n# → Suggests using categorical contrasts or predictions","category":"page"},{"location":"api/#Profile-Specification-Errors","page":"API Reference","title":"Profile Specification Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Error: Invalid reference grid argument (must be DataFrame or a grid builder output)\nprofile_margins(model, data, \"invalid\")\n# → Clear guidance on valid reference grid specifications\n\n# Error: Reference grid missing model variables\nincomplete_grid = DataFrame(x1=[0,1])  # Missing x2, group from model\nprofile_margins(model, data, incomplete_grid)\n# → Error with list of missing variables","category":"page"},{"location":"api/#Statistical-Validity-Errors","page":"API Reference","title":"Statistical Validity Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Error: Insufficient data for robust estimation\ntiny_data = data[1:5, :]\npopulation_margins(model, tiny_data)\n# → Warning about statistical reliability with small samples","category":"page"},{"location":"api/#Error-Recovery-Patterns","page":"API Reference","title":"Error Recovery Patterns","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Input validation\nfunction validated_margins(model, data; vars=nothing, kwargs...)\n    # Validate variable existence\n    if vars !== nothing\n        data_vars = names(data)\n        missing_vars = setdiff(vars, Symbol.(data_vars))\n        if !isempty(missing_vars)\n            throw(ArgumentError(\"Variables not found in data: $missing_vars\"))\n        end\n    end\n    \n    return population_margins(model, data; vars=vars, kwargs...)\nend","category":"page"},{"location":"api/#Integration-Examples","page":"API Reference","title":"Integration Examples","text":"","category":"section"},{"location":"api/#With-GLM.jl-Ecosystem","page":"API Reference","title":"With GLM.jl Ecosystem","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using GLM, CategoricalArrays\n\n# Logistic regression\nmodel = glm(@formula(outcome ~ x1 + x2 + group), data, Binomial(), LogitLink())\n\n# Effects on probability scale\nprob_effects = population_margins(model, data; scale=:response, type=:effects)\n\n# Effects on log-odds scale  \nlogodds_effects = population_margins(model, data; scale=:link, type=:effects)","category":"page"},{"location":"api/#With-CovarianceMatrices.jl","page":"API Reference","title":"With CovarianceMatrices.jl","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using CovarianceMatrices\n\n# Apply different estimators via vcov parameter\name_hc1 = population_margins(model, data; vcov=CovarianceMatrices.HC1)\name_hc3 = population_margins(model, data; vcov=CovarianceMatrices.HC3)\name_clustered = population_margins(model, data; vcov=CovarianceMatrices.Clustered(:cluster_var))\name_hac = population_margins(model, data; vcov=CovarianceMatrices.HAC(kernel=:bartlett))","category":"page"},{"location":"api/#With-DataFrames-Ecosystem","page":"API Reference","title":"With DataFrames Ecosystem","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using DataFrames, CSV, Chain\n\n# Complete analysis pipeline\nresults_df = @chain begin\n    population_margins(model, data; type=:effects)\n    DataFrame(_)\n    select(_, :term, :estimate, :se, :p_value)\n    filter(row -> row.p_value < 0.05, _)  # Significant effects only\nend\n\n# Export results\nCSV.write(\"significant_effects.csv\", results_df)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This API reference provides complete documentation for all Margins.jl functionality. For conceptual background on the 2×2 framework, see Mathematical Foundation. For performance optimization guidance, see Performance Guide. For advanced features including elasticities and robust inference, see Advanced Features.","category":"page"},{"location":"computational_architecture/#Computational-Architecture","page":"Computational Architecture","title":"Computational Architecture","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"The foundational computational engine powering Margins.jl","category":"page"},{"location":"computational_architecture/#FormulaCompiler.jl:-The-Foundation","page":"Computational Architecture","title":"FormulaCompiler.jl: The Foundation","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Margins.jl is built on FormulaCompiler.jl, a high-performance formula evaluation and differentiation engine specifically designed for econometric analysis. This architectural foundation helps explain how Margins.jl achieves both statistical correctness and exceptional performance.","category":"page"},{"location":"computational_architecture/#Why-FormulaCompiler.jl-Matters","page":"Computational Architecture","title":"Why FormulaCompiler.jl Matters","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl provides the zero-allocation computational core that enables Margins.jl to:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Process large econometric datasets efficiently: O(1) profile margins regardless of dataset size\nMaintain statistical rigor: Exact derivatives for delta-method standard errors  \nSupport complex formulas: Nested functions like log(1 + income) with proper differentiation\nHandle mixed data types: Automatic Float64 conversion for derivatives without runtime cost\nEnsure numerical stability: Machine-precision accuracy for gradient computations","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Without FormulaCompiler.jl, marginal effects computation would require either:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Slow symbolic differentiation (intractable for large datasets)\nUnreliable numerical approximations (compromising statistical validity)\nMassive memory allocations (preventing large-scale analysis)","category":"page"},{"location":"computational_architecture/#The-Compilation-Strategy","page":"Computational Architecture","title":"The Compilation Strategy","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl transforms regression formulas into highly optimized computational kernels:","category":"page"},{"location":"computational_architecture/#Formula-Compilation","page":"Computational Architecture","title":"Formula Compilation","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# From StatsModels.jl formula...\n@formula(y ~ log(income) + age + education)\n\n# ...to zero-allocation evaluator\ncompiled = FormulaCompiler.compile_formula(model, data)\n# Single compilation, reused across all margin computations","category":"page"},{"location":"computational_architecture/#Derivative-System","page":"Computational Architecture","title":"Derivative System","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Automatic derivative evaluators for marginal effects\nde = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=[:income, :age])\n# Zero allocation per derivative computation","category":"page"},{"location":"computational_architecture/#Type-Safe-Overrides","page":"Computational Architecture","title":"Type-Safe Overrides","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Efficient scenario analysis with fractional specifications\noverrides = Dict(:income => 50000, :treatment => 0.5)  # 50% treatment probability\nresult = FormulaCompiler.evaluate_scenario(compiled, overrides)\n# Supports categorical mixtures and continuous overrides seamlessly","category":"page"},{"location":"computational_architecture/#Computational-Kernels","page":"Computational Architecture","title":"Computational Kernels","text":"","category":"section"},{"location":"computational_architecture/#Zero-Allocation-Formula-Evaluation","page":"Computational Architecture","title":"Zero-Allocation Formula Evaluation","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"The core of all marginal effects computation is formula evaluation. FormulaCompiler.jl achieves ~7 nanoseconds per evaluation with zero allocations:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Population margins: evaluate formula n times (once per observation)\nfor i in 1:n_observations\n    η[i] = compiled_evaluator(data_row[i])  # 7ns, 0 bytes\nend\n\n# Profile margins: evaluate formula k times (once per scenario)  \nfor j in 1:n_scenarios\n    η[j] = compiled_evaluator(scenario[j])   # 7ns, 0 bytes, independent of n_observations\nend","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Key insight: Profile margins achieve O(1) scaling because they evaluate formulas only at specified scenarios, not across the entire dataset.","category":"page"},{"location":"computational_architecture/#Derivative-Computation","page":"Computational Architecture","title":"Derivative Computation","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Marginal effects require computing ∂η/∂x for each variable. FormulaCompiler.jl provides two backends:","category":"page"},{"location":"computational_architecture/#Automatic-Differentiation-(:ad)-**RECOMMENDED**","page":"Computational Architecture","title":"Automatic Differentiation (:ad) - RECOMMENDED","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Accuracy: Machine precision (exact derivatives)\nAllocation: Zero bytes after warmup\nDomain safety: Handles log(), sqrt(), 1/x functions correctly\nUse case: Default choice for reliability and accuracy","category":"page"},{"location":"computational_architecture/#Finite-Differences-(:fd)","page":"Computational Architecture","title":"Finite Differences (:fd)","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Accuracy: Numerical approximation (typically sufficient)\nAllocation: Zero bytes in all cases\nPerformance: Slightly faster for simple formulas\nUse case: Production optimization when domain is well-behaved","category":"page"},{"location":"computational_architecture/#Buffer-Management-System","page":"Computational Architecture","title":"Buffer Management System","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Margins.jl pre-allocates computational buffers to achieve zero-allocation performance:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Pre-allocated in MarginsEngine struct\nstruct MarginsEngine\n    η_buf::Vector{Float64}          # Linear predictor evaluations\n    g_buf::Vector{Float64}          # Gradient computations  \n    gβ_accumulator::Vector{Float64} # Parameter gradient accumulation\n    # ... other buffers\nend","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"These buffers are reused across all computations, eliminating runtime allocations while maintaining thread safety.","category":"page"},{"location":"computational_architecture/#Data-Type-Architecture","page":"Computational Architecture","title":"Data Type Architecture","text":"","category":"section"},{"location":"computational_architecture/#Mixed-Type-Handling","page":"Computational Architecture","title":"Mixed Type Handling","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl automatically handles the mixed data types common in econometric analysis:","category":"page"},{"location":"computational_architecture/#Integer-Variables","page":"Computational Architecture","title":"Integer Variables","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Runtime behavior: Automatic Float64 conversion during derivative computation\nPerformance impact: Zero (conversion happens during compilation, not evaluation)\nMathematical correctness: Preserves exact derivative computation\nExample: age::Int64 treated as continuous for marginal effects","category":"page"},{"location":"computational_architecture/#Categorical-Variables","page":"Computational Architecture","title":"Categorical Variables","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Bool variables: Treated as categorical with fractional override support\nCategoricalArray: Supports both baseline and pairwise contrasts\nFrequency weighting: Unspecified categoricals use sample composition\nExample: treatment::Bool supports 0.7 for 70% treatment probability","category":"page"},{"location":"computational_architecture/#Continuous-Variables","page":"Computational Architecture","title":"Continuous Variables","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Float64: Native support with full arithmetic operations\nComplex expressions: log(1 + income), sqrt(age) handled correctly\nChain rule: Automatic differentiation through nested functions","category":"page"},{"location":"computational_architecture/#Type-Safe-Scenario-System","page":"Computational Architecture","title":"Type-Safe Scenario System","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl enables sophisticated scenario analysis while maintaining type safety:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Representative scenarios with mixed types\nscenarios = (\n    :income => [30000, 50000, 80000],        # Continuous override\n    :education => [\"High School\", \"College\"], # Categorical override  \n    :treatment => [0.2, 0.8]                 # Fractional Bool override\n)\n\n# Automatic Cartesian product: 3×2×2 = 12 scenarios\n# Each scenario maintains type consistency and statistical validity","category":"page"},{"location":"computational_architecture/#Statistical-Computation-Architecture","page":"Computational Architecture","title":"Statistical Computation Architecture","text":"","category":"section"},{"location":"computational_architecture/#Delta-Method-Standard-Errors","page":"Computational Architecture","title":"Delta-Method Standard Errors","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"The statistical rigor of Margins.jl depends on proper delta-method computation:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Delta-method formula: Var(g(β)) = g'(β) Σ g'(β)ᵀ\n# Where g'(β) = ∂(marginal_effect)/∂β and Σ = vcov(model)\n\n# FormulaCompiler.jl computes g'(β) with zero allocation:\ngradient = FormulaCompiler.compute_parameter_gradient(compiled, β, data_point)\nvariance = gradient' * vcov_matrix * gradient\nstandard_error = sqrt(variance)","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Critical: This computation requires exact derivatives to ensure statistical validity. Approximate gradients would compromise the mathematical foundation of inference.","category":"page"},{"location":"computational_architecture/#Covariance-Matrix-Integration","page":"Computational Architecture","title":"Covariance Matrix Integration","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl integrates seamlessly with Julia's covariance matrix ecosystem:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"GLM.jl: Uses vcov(model) automatically\nCovarianceMatrices.jl: Supports robust/clustered standard errors\nMixedModels.jl: Compatible with mixed model covariance structures\nCustom matrices: Accepts user-provided covariance matrices","category":"page"},{"location":"computational_architecture/#Performance-Implications-of-Architecture","page":"Computational Architecture","title":"Performance Implications of Architecture","text":"","category":"section"},{"location":"computational_architecture/#Why-Profile-Margins-Are-O(1)","page":"Computational Architecture","title":"Why Profile Margins Are O(1)","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Profile margins evaluate k scenarios (typically 1-50)\nn_scenarios = length(expand_scenarios(at_specification))\ncomputational_cost = n_scenarios * 7ns  # Independent of dataset size\n\n# Population margins evaluate n observations  \ncomputational_cost = n_observations * 7ns  # Scales with data","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Architectural insight: Profile margins achieve constant-time performance because FormulaCompiler.jl decouples formula evaluation from data size.","category":"page"},{"location":"computational_architecture/#Memory-Architecture","page":"Computational Architecture","title":"Memory Architecture","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Constant memory footprint regardless of dataset size:\nmemory_usage = sizeof(η_buf) + sizeof(g_buf) + sizeof(gβ_accumulator) + compilation_cache\n# Total: ~few KB, independent of whether you have 1k or 1M observations","category":"page"},{"location":"computational_architecture/#Compilation-Caching","page":"Computational Architecture","title":"Compilation Caching","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl automatically caches compiled evaluators:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# First call: compilation cost\nresult1 = population_margins(model, data)  # ~milliseconds (compile + compute)\n\n# Subsequent calls: pure computation  \nresult2 = profile_margins(model, data, means_grid(data))  # ~microseconds (reuse compilation)","category":"page"},{"location":"computational_architecture/#Integration-with-JuliaStats-Ecosystem","page":"Computational Architecture","title":"Integration with JuliaStats Ecosystem","text":"","category":"section"},{"location":"computational_architecture/#StatsModels.jl-Integration","page":"Computational Architecture","title":"StatsModels.jl Integration","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl directly processes StatsModels.jl formulas:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# From StatsModels formula specification...\nformula = @formula(log_wage ~ education + experience + education&experience)\n\n# ...to compiled computational kernel with proper derivatives\ncompiled = FormulaCompiler.compile_formula(formula, model, data)\n# Handles interaction terms, transformations, and categorical expansions","category":"page"},{"location":"computational_architecture/#GLM.jl-Integration","page":"Computational Architecture","title":"GLM.jl Integration","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Link functions are handled transparently:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# For GLMs, chain rule automatically applied:\n# ∂μ/∂x = (∂μ/∂η) × (∂η/∂x)\n# Where μ = linkinv(η) and ∂μ/∂η computed by FormulaCompiler.jl\n\n# Both link scale (:eta) and response scale (:mu) supported\nmargin_eta = compute_margin(compiled, :eta)  # Direct derivative  \nmargin_mu = compute_margin(compiled, :mu)    # Chain rule applied","category":"page"},{"location":"computational_architecture/#MixedModels.jl-Integration","page":"Computational Architecture","title":"MixedModels.jl Integration","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Mixed models require special covariance matrix handling:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# FormulaCompiler.jl extracts fixed effects for differentiation:\nβ_fixed = fixef(mixed_model)\nV_fixed = vcov(mixed_model)  # Fixed effects covariance only\n\n# Marginal effects computed relative to fixed effects:\n# Random effects treated as integrated out (conditional on data)","category":"page"},{"location":"computational_architecture/#Extensibility-Architecture","page":"Computational Architecture","title":"Extensibility Architecture","text":"","category":"section"},{"location":"computational_architecture/#Custom-Function-Support","page":"Computational Architecture","title":"Custom Function Support","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl supports user-defined functions with automatic differentiation:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Custom transformations with exact derivatives\nmy_transform(x) = log(1 + exp(x))  # Softplus function\n\n# Automatic differentiation handles custom functions:\n@formula(y ~ my_transform(income) + age)  # Works seamlessly","category":"page"},{"location":"computational_architecture/#Backend-Extensibility","page":"Computational Architecture","title":"Backend Extensibility","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"The architecture supports additional computational backends:","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"# Current backends\npopulation_margins(model, data; backend=:ad)  # Automatic differentiation\npopulation_margins(model, data; backend=:fd)  # Finite differences\n\n# Future extensibility:  \n# population_margins(model, data; backend=:symbolic)  # Symbolic differentiation\n# population_margins(model, data; backend=:gpu)      # GPU acceleration","category":"page"},{"location":"computational_architecture/#Architectural-Principles","page":"Computational Architecture","title":"Architectural Principles","text":"","category":"section"},{"location":"computational_architecture/#1.-Separation-of-Concerns","page":"Computational Architecture","title":"1. Separation of Concerns","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"FormulaCompiler.jl: Low-level computational primitives\nMargins.jl: High-level statistical interface and methodology\nResult: Clean abstraction boundaries and maintainable code","category":"page"},{"location":"computational_architecture/#2.-Performance-Without-Compromise","page":"Computational Architecture","title":"2. Performance Without Compromise","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Statistical integrity: Performance optimizations maintain statistical validity\nExact computation: Delta-method standard errors use exact derivatives\nMemory efficiency: Zero-allocation core with pre-allocated buffers","category":"page"},{"location":"computational_architecture/#3.-Type-Safety-and-Correctness","page":"Computational Architecture","title":"3. Type Safety and Correctness","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Compile-time checks: Type errors caught during formula compilation\nRuntime safety: Automatic type conversions preserve mathematical properties  \nStatistical validity: Architecture enforces proper delta-method computation","category":"page"},{"location":"computational_architecture/#4.-JuliaStats-Ecosystem-Compatibility","page":"Computational Architecture","title":"4. JuliaStats Ecosystem Compatibility","text":"","category":"section"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"Protocol adherence: Follows established conventions (vcov, predict, etc.)\nSeamless integration: Works with existing model types and data formats\nFuture compatibility: Architecture supports ecosystem evolution","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"","category":"page"},{"location":"computational_architecture/","page":"Computational Architecture","title":"Computational Architecture","text":"This computational architecture enables Margins.jl to deliver both statistical rigor and exceptional performance for econometric analysis. For performance-specific guidance, see Performance Guide. For the mathematical foundation, see Mathematical Foundation.","category":"page"},{"location":"grouping/#Population-Grouping-Framework","page":"Population Grouping","title":"Population Grouping Framework","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Comprehensive hierarchical analysis for stratified marginal effects","category":"page"},{"location":"grouping/#Conceptual-Foundation","page":"Population Grouping","title":"Conceptual Foundation","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Margins.jl implements a population-based grouping framework that computes average marginal effects (AME) and average adjusted predictions (AAP) within stratified subgroups of the observed data.","category":"page"},{"location":"grouping/#Core-Design-Principles","page":"Population Grouping","title":"Core Design Principles","text":"","category":"section"},{"location":"grouping/#Population-Based-Analysis","page":"Population Grouping","title":"Population-Based Analysis","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"All operations maintain population averaging semantics - computing effects by averaging across actual or modified populations, not evaluating at synthetic representative points.","category":"page"},{"location":"grouping/#Orthogonal-Parameters","page":"Population Grouping","title":"Orthogonal Parameters","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Three independent dimensions combine multiplicatively:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"vars: Which variables to compute marginal effects for\ngroups: How to stratify the analysis (data structure) \nscenarios: What counterfactual scenarios to consider (data modification)","category":"page"},{"location":"grouping/#Single-Fundamental-Operation","page":"Population Grouping","title":"Single Fundamental Operation","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"All grouping reduces to: stratify data into subgroups, compute population margins within each subgroup.","category":"page"},{"location":"grouping/#Basic-Grouping-Patterns","page":"Population Grouping","title":"Basic Grouping Patterns","text":"","category":"section"},{"location":"grouping/#Simple-Categorical-Grouping","page":"Population Grouping","title":"Simple Categorical Grouping","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Compute effects separately within each category of a grouping variable:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"using Margins, DataFrames, GLM\n\n# Effects by education level\neducation_effects = population_margins(model, data; \n                                     type=:effects, \n                                     groups=:education)\n\n# Results: separate effects for each education category\nDataFrame(education_effects)","category":"page"},{"location":"grouping/#Cross-Tabulated-Grouping","page":"Population Grouping","title":"Cross-Tabulated Grouping","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Analyze effects across combinations of multiple categorical variables:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Effects by education × gender combinations\ndemographic_effects = population_margins(model, data;\n                                        type=:effects,\n                                        groups=[:education, :gender])\n\n# Results: effects for (HS,Male), (HS,Female), (College,Male), (College,Female), etc.","category":"page"},{"location":"grouping/#Advanced-Hierarchical-Grouping","page":"Population Grouping","title":"Advanced Hierarchical Grouping","text":"","category":"section"},{"location":"grouping/#Nested-Grouping-with-Operator","page":"Population Grouping","title":"Nested Grouping with => Operator","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"The => operator creates hierarchical nesting where the right side is computed within each level of the left side:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Region first, then education within each region\nnested_effects = population_margins(model, data;\n                                  type=:effects,\n                                  groups=:region => :education)\n\n# Results: (North,HS), (North,College), (South,HS), (South,College)","category":"page"},{"location":"grouping/#Deep-Hierarchical-Nesting","page":"Population Grouping","title":"Deep Hierarchical Nesting","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Multiple levels of nesting support complex organizational structures:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Three-level hierarchy: country → region → education\ndeep_hierarchy = population_margins(model, data;\n                                  type=:effects,\n                                  groups=:country => (:region => :education))\n\n# Four-level hierarchy: sector → company → department → position\norganizational = population_margins(model, data;\n                                  type=:effects, \n                                  groups=:sector => (:company => (:department => :position)))","category":"page"},{"location":"grouping/#Parallel-Grouping-Within-Hierarchy","page":"Population Grouping","title":"Parallel Grouping Within Hierarchy","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Complex patterns combining hierarchical and cross-tabulated structures:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Region first, then education×gender cross-tab within each region\nparallel_nested = population_margins(model, data;\n                                   type=:effects,\n                                   groups=:region = [:education, :gender])\n\n# Region first, then separate analyses for education levels AND income quartiles\nmixed_parallel = population_margins(model, data;\n                                  type=:effects,\n                                  groups=:region = [:education, (:income, 4)])","category":"page"},{"location":"grouping/#Continuous-Variable-Binning","page":"Population Grouping","title":"Continuous Variable Binning","text":"","category":"section"},{"location":"grouping/#Quantile-Based-Binning","page":"Population Grouping","title":"Quantile-Based Binning","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Automatic binning using quantiles with professional statistical terminology:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Quartile analysis (Q1, Q2, Q3, Q4)\nincome_quartiles = population_margins(model, data;\n                                    type=:effects,\n                                    groups=(:income, 4))\n\n# Tertile analysis (T1, T2, T3) \nscore_tertiles = population_margins(model, data;\n                                  type=:effects,\n                                  groups=(:test_score, 3))\n\n# Quintile analysis (P1, P2, P3, P4, P5)\nwealth_quintiles = population_margins(model, data;\n                                    type=:effects,\n                                    groups=(:wealth, 5))","category":"page"},{"location":"grouping/#Custom-Threshold-Binning","page":"Population Grouping","title":"Custom Threshold Binning","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Policy-relevant thresholds using mathematical interval notation:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Income brackets for tax policy analysis\ntax_brackets = population_margins(model, data;\n                                type=:effects,\n                                groups=(:income, [25000, 50000, 75000]))\n\n# Results: [\"< 25000\", \"[25000, 50000)\", \"[50000, 75000)\", \">= 75000\"]\n\n# Poverty line analysis\npoverty_analysis = population_margins(model, data;\n                                    type=:effects,\n                                    groups=(:income, [federal_poverty_line]))\n\n# Results: [\"< 12880\", \">= 12880\"] (using 2023 federal poverty guideline)","category":"page"},{"location":"grouping/#Mixed-Categorical-and-Continuous-Grouping","page":"Population Grouping","title":"Mixed Categorical and Continuous Grouping","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Combine categorical variables with binned continuous variables:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Education levels × income quartiles\neducation_income = population_margins(model, data;\n                                    type=:effects,\n                                    groups=[:education, (:income, 4)])\n\n# Results: (HS,Q1), (HS,Q2), (HS,Q3), (HS,Q4), (College,Q1), etc.\n\n# Geographic region × age quintiles × gender\ncomplex_demographics = population_margins(model, data;\n                                        type=:effects,\n                                        groups=[:region, (:age, 5), :gender])","category":"page"},{"location":"grouping/#Counterfactual-Scenario-Analysis","page":"Population Grouping","title":"Counterfactual Scenario Analysis","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"See Population Scenarios for detailed semantics and implementation notes on scenarios in population analysis.","category":"page"},{"location":"grouping/#Policy-Scenario-Framework","page":"Population Grouping","title":"Policy Scenario Framework","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"The scenarios parameter modifies variable values for the entire population, creating counterfactual analyses:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Binary treatment analysis\ntreatment_effects = population_margins(model, data;\n                                     type=:effects,\n                                     scenarios=(:treatment = [0, 1]))\n\n# Multi-level policy scenarios\npolicy_scenarios = population_margins(model, data;\n                                    type=:effects,\n                                    scenarios=(:policy_level = [\"none\", \"moderate\", \"aggressive\"]))","category":"page"},{"location":"grouping/#Multi-Variable-Scenarios","page":"Population Grouping","title":"Multi-Variable Scenarios","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Cartesian product expansion for complex policy analysis:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Treatment × policy combinations\ncomprehensive_policy = population_margins(model, data;\n                                        type=:effects,\n                                        scenarios=(:treatment = [0, 1], \n                                                      :policy = [\"current\", \"reform\"]))\n\n# Results: 4 scenarios (2×2 combinations)\n\n# Three-dimensional policy space\ncomplex_scenarios = population_margins(model, data;\n                                     type=:effects,\n                                     scenarios=(:treatment = [0, 1],\n                                                   :funding = [0.8, 1.0, 1.2],\n                                                   :regulation = [\"light\", \"standard\", \"strict\"]))\n\n# Results: 18 scenarios (2×3×3 combinations)","category":"page"},{"location":"grouping/#Combined-Groups-and-Scenarios","page":"Population Grouping","title":"Combined Groups and Scenarios","text":"","category":"section"},{"location":"grouping/#Comprehensive-Policy-Analysis","page":"Population Grouping","title":"Comprehensive Policy Analysis","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Groups and scenarios combine multiplicatively for complete analytical coverage:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Demographics × policy scenarios\nfull_analysis = population_margins(model, data;\n                                 type=:effects,\n                                 groups=[:education, :region],\n                                 scenarios=(:treatment = [0, 1]))\n\n# Results: Each education×region combination under both treatment scenarios","category":"page"},{"location":"grouping/#Advanced-Applications","page":"Population Grouping","title":"Advanced Applications","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Healthcare policy evaluation\nhealthcare_comprehensive = population_margins(health_model, health_data;\n    type=:effects,\n    groups=:state = (:urban_rural = [:insurance_type, (:income, 3)]),\n    scenarios=(:aca_expansion = [0, 1], :medicaid_funding = [0.8, 1.2])\n)\n\n# Results: State × Urban/Rural × (Insurance×Income-Tertiles) × ACA×Medicaid scenarios\n# Total combinations: 4 states × 2 urban/rural × 12 insurance×income × 4 policy scenarios = 384 results","category":"page"},{"location":"grouping/#Real-World-Applications","page":"Population Grouping","title":"Real-World Applications","text":"","category":"section"},{"location":"grouping/#Economic-Policy-Analysis","page":"Population Grouping","title":"Economic Policy Analysis","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Tax policy impact across income distribution\ntax_analysis = population_margins(tax_model, tax_data;\n    type=:effects,\n    vars=[:after_tax_income],\n    groups=(:pre_tax_income, 5),  # Income quintiles\n    scenarios=(:tax_rate = [0.15, 0.25, 0.35], :deduction_cap = [10000, 25000])\n)\n\n# Labor market analysis with unemployment scenarios  \nlabor_analysis = population_margins(employment_model, labor_data;\n    type=:effects,\n    groups=[:education, (:experience, 4)],  # Education × experience quartiles\n    scenarios=(:unemployment_rate = [3.0, 6.0, 9.0])  # Economic conditions\n)","category":"page"},{"location":"grouping/#Healthcare-Research","page":"Population Grouping","title":"Healthcare Research","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Treatment effectiveness across patient subgroups\nclinical_analysis = population_margins(treatment_model, patient_data;\n    type=:effects,\n    groups=:hospital = [:condition_severity, (:age, 4)],\n    scenarios=(:treatment_protocol = [\"standard\", \"intensive\"],\n                   :resource_level = [\"constrained\", \"adequate\"])\n)","category":"page"},{"location":"grouping/#Educational-Policy","page":"Population Grouping","title":"Educational Policy","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Educational intervention analysis\neducation_policy = population_margins(achievement_model, student_data;\n    type=:effects,\n    groups=:district = (:school_type = [:socioeconomic_status, (:baseline_score, 3)]),\n    scenarios=(:intervention = [0, 1], :funding_increase = [0.0, 0.1, 0.2])\n)","category":"page"},{"location":"grouping/#Performance-Characteristics","page":"Population Grouping","title":"Performance Characteristics","text":"","category":"section"},{"location":"grouping/#Computational-Complexity","page":"Population Grouping","title":"Computational Complexity","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Population grouping maintains efficient O(n) scaling within each subgroup:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"using BenchmarkTools\n\n# Simple grouping: O(n/k) per group for k groups\n@btime population_margins($model, $data; groups=:education)\n\n# Complex hierarchical grouping: O(n/k) per final subgroup\n@btime population_margins($model, $data; groups=:region = (:education = :gender))\n\n# With scenarios: same O(n/k) complexity repeated for each scenario\n@btime population_margins($model, $data; groups=:education, scenarios=(:treatment = [0, 1]))","category":"page"},{"location":"grouping/#Memory-Efficiency","page":"Population Grouping","title":"Memory Efficiency","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"The grouping framework avoids data duplication through efficient indexing:","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Subgroup filtering: Uses DataFrame indexing, not data copying\nScenario modification: Temporary overrides without permanent data changes  \nResult aggregation: Minimal memory footprint for result compilation","category":"page"},{"location":"grouping/#Large-Dataset-Considerations","page":"Population Grouping","title":"Large Dataset Considerations","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# For datasets >100k observations with many groups\n# Consider selective analysis of key variables\nkey_analysis = population_margins(model, large_data;\n                                type=:effects,\n                                vars=[:primary_outcome],  # Limit variables\n                                groups=(:income, 4))      # Manageable grouping\n\n# Complex patterns still feasible for large n\ncomplex_large = population_margins(model, large_data;\n                                 type=:effects,\n                                 groups=:region = [:education, (:income, 4)])","category":"page"},{"location":"grouping/#Best-Practices","page":"Population Grouping","title":"Best Practices","text":"","category":"section"},{"location":"grouping/#When-to-Use-Different-Grouping-Patterns","page":"Population Grouping","title":"When to Use Different Grouping Patterns","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Simple Grouping (groups=:var):","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Single dimension analysis\nClear categorical divisions\nStraightforward interpretation needs","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Cross-Tabulation (groups=[:var1, :var2]):","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Interaction effects important\nPolicy targets multiple demographics simultaneously\nComprehensive coverage needed","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Hierarchical Grouping (groups=:var1 => :var2):","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Natural organizational structure exists\nContext matters (e.g., regions have different education systems)\nNested decision-making processes","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Continuous Binning (groups=(:var, n)):","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"Policy-relevant thresholds exist\nDistribution-based analysis needed\nQuantile-based interpretation valuable","category":"page"},{"location":"grouping/#Avoiding-Common-Pitfalls","page":"Population Grouping","title":"Avoiding Common Pitfalls","text":"","category":"section"},{"location":"grouping/#Combination-Explosion","page":"Population Grouping","title":"Combination Explosion","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# Dangerous: could create 1000s of combinations\n# groups=[:var1, :var2, :var3, (:var4, 10), (:var5, 5)]\n\n# Better: use hierarchical structure\ngroups=:var1 => [:var2, (:var4, 4)]","category":"page"},{"location":"grouping/#Empty-Subgroups","page":"Population Grouping","title":"Empty Subgroups","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# The framework automatically detects and errors on empty subgroups\n# to maintain statistical validity","category":"page"},{"location":"grouping/#Skip-Rule:-vars-also-in-groups-or-scenarios","page":"Population Grouping","title":"Skip Rule: vars also in groups or scenarios","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"For population analysis, computing the effect of a variable while simultaneously holding it fixed (via scenarios) or using it to define subgroups (via groups) is contradictory.\nTo preserve statistical correctness and interpretability, population_margins skips variables that appear in vars if they also appear in groups or scenarios.\nPractical guidance:\nIf you need Stata-style dydx(x) over(x), consider whether you intend profile analysis instead. Use profile_margins(model, data, cartesian_grid(x=[...])); to evaluate derivatives at specific values of x.\nIf you want effects within strata of x, group by a coarser or external variable, or compute effects for other variables while stratifying by x.\nIf you want counterfactual predictions as x changes, use type=:predictions with scenarios=(:x = [...]) and omit x from vars.","category":"page"},{"location":"grouping/#Interpretation-Complexity","page":"Population Grouping","title":"Interpretation Complexity","text":"","category":"section"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"# For presentation, consider simpler patterns:\npresentation_analysis = population_margins(model, data;\n                                         groups=:education,\n                                         scenarios=(:policy = [0, 1]))\n\n# For comprehensive analysis, use full complexity:\nresearch_analysis = population_margins(model, data;\n                                     groups=:region = [:education, (:income, 4)],\n                                     scenarios=(:policy = [0, 1], :funding = [0.8, 1.2]))","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"","category":"page"},{"location":"grouping/","page":"Population Grouping","title":"Population Grouping","text":"The population grouping framework enables sophisticated econometric analysis while maintaining computational efficiency and statistical rigor. For related details on scenarios and reference grids, see Reference Grids and for performance optimization, see Performance Guide.","category":"page"},{"location":"population_scenarios/#Population-Scenarios-(Stata-at())-—-Population-Analysis","page":"Population Scenarios","title":"Population Scenarios (Stata at()) — Population Analysis","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"This page explains how counterfactual scenarios (Stata at()) are implemented for population analysis, why the design uses FormulaCompiler’s DataScenario system, and which Margins.jl functions rely on it.","category":"page"},{"location":"population_scenarios/#Scope-and-Intent","page":"Population Scenarios","title":"Scope and Intent","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Scenarios are supported in population_margins only (population-averaged effects/predictions under counterfactual covariates).\nprofile_margins does not accept scenarios; it uses explicit reference grids (e.g., means_grid, cartesian_grid).\nThe design prioritizes statistical correctness (proper delta-method SEs with full Σ) and zero-allocation per-row performance.","category":"page"},{"location":"population_scenarios/#Conceptual-Model","page":"Population Scenarios","title":"Conceptual Model","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Given a fitted model and a dataset, a scenario specifies a set of variable overrides to evaluate counterfactuals. For population analysis, we:","category":"page"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Keep the original rows and any grouping subset (if groups are used).\nEvaluate effects or predictions at the counterfactual covariates by overriding row values via DataScenario during evaluation (no data mutation).\nAverage over the selected rows (weighted or unweighted), compute the averaged parameter gradient, and apply the delta method with the full covariance matrix.","category":"page"},{"location":"population_scenarios/#API-Usage","page":"Population Scenarios","title":"API Usage","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"# Effects for x under counterfactual z\npopulation_margins(model, data;\n    type=:effects,\n    vars=[:x],\n    scenarios=(z=[0.0, 1.0])\n)\n\n# Predictions under multiple scenarios (Cartesian expansion)\npopulation_margins(model, data;\n    type=:predictions,\n    scenarios=(x=[-1.0, 0.0, 1.0], treated=[0, 1])\n)\n\n# Grouped scenarios\ngrouped = population_margins(model, data;\n    type=:effects,\n    vars=[:x],\n    groups=[:education, :gender],\n    scenarios=(policy=[\"none\", \"pilot\", \"full\"]))","category":"page"},{"location":"population_scenarios/#Architecture-Overview","page":"Population Scenarios","title":"Architecture Overview","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Scenario handling is built around FormulaCompiler’s DataScenario system:","category":"page"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"DataScenario: a lightweight structure that maps variable overrides (e.g., :z => 0.5) and supplies them to the compiled evaluator per-row.\nCore evaluation calls (internal):\n_predict_with_scenario(compiled, scenario, row, scale, β, link, row_buf)\n_gradient_with_scenario!(out, compiled, scenario, row, scale, β, link, row_buf)","category":"page"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Key properties:","category":"page"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Zero per-row allocations (reuse pre-allocated row and gradient buffers).\nO(1) memory per context (reuse scenarios; continuous FD constructs only minimal override sets).\nNo mutation of the data; categorical types remain safe (no re-pooling required).","category":"page"},{"location":"population_scenarios/#Computation-Details","page":"Population Scenarios","title":"Computation Details","text":"","category":"section"},{"location":"population_scenarios/#Continuous-Effects-under-Scenarios","page":"Population Scenarios","title":"Continuous Effects under Scenarios","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"For each row i in the context and variable x, FD constructs centered differences around x_i while merging user overrides for other variables.\nAverage per-row effects and per-row gradients across the context (weighted or unweighted) and apply the delta method with the averaged gradient: se = sqrt(ḡ' Σ ḡ).","category":"page"},{"location":"population_scenarios/#Categorical/Boolean-Effects-under-Scenarios","page":"Population Scenarios","title":"Categorical/Boolean Effects under Scenarios","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Build contrasts (baseline or pairwise), merge overrides for non-effect variables into each level scenario, compute per-row differences and gradients, then average as above and apply the delta method.","category":"page"},{"location":"population_scenarios/#Predictions-under-Scenarios","page":"Population Scenarios","title":"Predictions under Scenarios","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Construct a single DataScenario per context, evaluate predictions and gradients per-row, average (weighted/unweighted), and apply the delta method with the averaged gradient.","category":"page"},{"location":"population_scenarios/#Grouping-(groups-...)","page":"Population Scenarios","title":"Grouping (groups = ...)","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Group subsets are determined first (categorical crosses, quantile bins, thresholds).\nScenario evaluation occurs within each subset using the same overrides.\nLarge combination protection prevents explosion; invalid combinations error (error-first policy).","category":"page"},{"location":"population_scenarios/#Weights","page":"Population Scenarios","title":"Weights","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Weighted contexts use proper normalization by total weight: Σw is used for both effects and averaged gradients.\nSampling and frequency weights are supported; weights can be provided as a column Symbol or a vector.","category":"page"},{"location":"population_scenarios/#Column-Naming-and-Ordering","page":"Population Scenarios","title":"Column Naming and Ordering","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"Group variables appear unprefixed (e.g., education).\nScenario variables appear with at_ prefix (e.g., at_x).\nColumn order: context columns first (groups, then scenarios), then statistical columns.","category":"page"},{"location":"population_scenarios/#Programmatic-Identification","page":"Population Scenarios","title":"Programmatic Identification","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"groups, scenarios = Margins.context_columns(result)\n# groups == [:education, ...], scenarios == [:x, :policy, ...]","category":"page"},{"location":"population_scenarios/#Notes","page":"Population Scenarios","title":"Notes","text":"","category":"section"},{"location":"population_scenarios/","page":"Population Scenarios","title":"Population Scenarios","text":"FD step size h is a fixed scalar in the FD path; AD users should prefer backend=:ad where applicable.\nprofile_margins uses reference grids — do not pass scenarios there; use cartesian_grid/means_grid instead.","category":"page"},{"location":"stata_migration/#Stata-Migration-Guide","page":"Migration Guide","title":"Stata Migration Guide","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Complete translation reference for economists migrating from Stata's margins command","category":"page"},{"location":"stata_migration/#Basic-Command-Translation","page":"Migration Guide","title":"Basic Command Translation","text":"","category":"section"},{"location":"stata_migration/#Core-Margins-Commands","page":"Migration Guide","title":"Core Margins Commands","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Command Margins.jl Equivalent Notes\nmargins population_margins(model, data; type=:predictions) Average adjusted predictions\nmargins, dydx(*) population_margins(model, data; type=:effects) Average marginal effects (AME)\nmargins, at(means) profile_margins(model, data, means_grid(data); type=:predictions) Predictions at sample means\nmargins, at(means) dydx(*) profile_margins(model, data, means_grid(data); type=:effects) Marginal effects at means (MEM)\nmargins, dydx(*) atmeans profile_margins(model, data, means_grid(data); type=:effects) Alternative MEM syntax","category":"page"},{"location":"stata_migration/#Variable-Selection","page":"Migration Guide","title":"Variable Selection","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Command Margins.jl Equivalent Notes\nmargins, dydx(x1 x2) population_margins(model, data; type=:effects, vars=[:x1, :x2]) Specific variables only\nmargins, dydx(_continuous) population_margins(model, data; type=:effects) All continuous variables (automatic)\nmargins, eyex(x1) population_margins(model, data; type=:effects, vars=[:x1], measure=:elasticity) Elasticities","category":"page"},{"location":"stata_migration/#Grouping-and-Stratification","page":"Migration Guide","title":"Grouping and Stratification","text":"","category":"section"},{"location":"stata_migration/#Basic-Grouping","page":"Migration Guide","title":"Basic Grouping","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Command Margins.jl Equivalent Notes\nmargins education population_margins(model, data; groups=:education) Group predictions\nmargins education, dydx(*) population_margins(model, data; type=:effects, groups=:education) Group effects\nmargins, over(education) population_margins(model, data; groups=:education) Alternative syntax\nmargins education gender population_margins(model, data; groups=[:education, :gender]) Cross-tabulation\nmargins education#gender population_margins(model, data; groups=[:education, :gender]) Interaction syntax","category":"page"},{"location":"stata_migration/#Nested-Analysis","page":"Migration Guide","title":"Nested Analysis","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Command Margins.jl Equivalent Notes\nby region: margins education population_margins(model, data; groups=:region => :education) Nested grouping\nmargins education, over(region) population_margins(model, data; groups=[:education, :region]) Cross-tabulation alternative","category":"page"},{"location":"stata_migration/#Scenario-Analysis-(at()-Specification)","page":"Migration Guide","title":"Scenario Analysis (at() Specification)","text":"","category":"section"},{"location":"stata_migration/#Basic-Scenarios","page":"Migration Guide","title":"Basic Scenarios","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Command Margins.jl Equivalent Notes\nmargins, at(x=0) profile_margins(model, data, cartesian_grid(x=[0]); type=:predictions) Single scenario\nmargins, at(x=(0 1 2)) profile_margins(model, data, cartesian_grid(x=[0, 1, 2]); type=:predictions) Multiple values\nmargins, at(x=0 y=1) profile_margins(model, data, cartesian_grid(x=[0], y=[1]); type=:predictions) Multiple variables","category":"page"},{"location":"stata_migration/#Population-Level-Counterfactuals","page":"Migration Guide","title":"Population-Level Counterfactuals","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Key Difference: Stata's at() creates evaluation points, while Margins.jl's scenarios creates population counterfactuals.","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Approach Margins.jl Population Approach Notes\nmargins, at(treatment=(0 1)) population_margins(model, data; scenarios=(treatment=[0, 1])) Everyone untreated vs everyone treated\nmargins education, at(policy=(0 1)) population_margins(model, data; groups=:education, scenarios=(policy=[0, 1])) Policy effects by education","category":"page"},{"location":"stata_migration/#Profile-vs-Population-Interpretation","page":"Migration Guide","title":"Profile vs Population Interpretation","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Stata: margins, at(treatment=(0 1))\n# → Effects at two evaluation points\n\n# Margins.jl Profile Equivalent\nprofile_results = profile_margins(model, data, \n    cartesian_grid(treatment=[0, 1]);\n    type=:effects)\n\n# Margins.jl Population Alternative (often more relevant)  \npopulation_results = population_margins(model, data;\n    scenarios=(treatment=[0, 1]),\n    type=:effects)","category":"page"},{"location":"stata_migration/#Skip-Rule:-dydx(x)-with-over(x)-(and-scenarios)","page":"Migration Guide","title":"Skip Rule: dydx(x) with over(x) (and scenarios)","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Unlike Stata, population_margins intentionally skips computing the effect of a variable when that same variable appears in groups (Stata over()) or in scenarios (Stata at()). This avoids the contradiction of “compute the effect of x while holding x fixed” or “using x both as an effect variable and a grouping key.”","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Recommended translations:","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# 1) Stata: margins, dydx(x) over(x)\n# → Profile-style alternative: evaluate derivatives at specific x values\nmem_like = profile_margins(model, data,\n    cartesian_grid(x=[-2.0, 0.0, 2.0]);\n    type=:effects,\n    vars=[:x])\n\n# 2) Population stratification by x without contradiction:\n#    Create a derived bin variable and group by it, not by :x directly\ndf.x_bin = cut(df.x, 4)  # quartiles via user code; or use groups=(:x, 4)\nby_xbins = population_margins(model, df;\n    type=:effects,\n    vars=[:x],\n    groups=:x_bin)  # allowed since groups variable ≠ :x\n\n# 3) Effects of other variables within x strata (population approach)\neffects_in_xbins = population_margins(model, data;\n    type=:effects,\n    vars=[:z, :w],\n    groups=(:x, 4))\n\n# 4) Counterfactual predictions as x changes (not effects of x)\npreds_under_x = population_margins(model, data;\n    type=:predictions,\n    scenarios=(x=[-2.0, 0.0, 2.0]))","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"See also: “Skip Rule” note in the Population Grouping docs for rationale and guidance.","category":"page"},{"location":"stata_migration/#Short-example:-grouping-by-x_bin-to-compute-dydx(x)-across-strata","page":"Migration Guide","title":"Short example: grouping by x_bin to compute dydx(x) across strata","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"using Random\nusing DataFrames, CategoricalArrays\nusing Statistics  # for quantile\nusing GLM\nusing Margins\n\nRandom.seed!(42)\nn = 500\ndf = DataFrame(\n    y = rand(Bool, n),\n    x = randn(n),\n    z = randn(n)\n)\n\n# Fit a simple model\nm = glm(@formula(y ~ x + z), df, Binomial(), LogitLink())\n\n# Create quartile bins for x as a separate column \"x_bin\"\nedges = quantile(df.x, 0:0.25:1.0)\nlabels = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndf.x_bin = cut(df.x, edges; labels=labels, extend=true)\n\n# Now compute population AME of x within x_bin strata (no contradiction)\nres = population_margins(m, df;\n    type=:effects,\n    vars=[:x],\n    groups=:x_bin)\n\nDataFrame(res)  # Shows dydx(x) by Q1..Q4","category":"page"},{"location":"stata_migration/#Combined-Grouping-and-Scenarios","page":"Migration Guide","title":"Combined Grouping and Scenarios","text":"","category":"section"},{"location":"stata_migration/#Complex-Analysis-Patterns","page":"Migration Guide","title":"Complex Analysis Patterns","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Stata Pattern Margins.jl Equivalent Notes\nmargins education, at(treatment=(0 1)) population_margins(model, data; groups=:education, scenarios=(treatment=[0, 1])) Group × scenario analysis\nMultiple margins commands Single comprehensive call More efficient in Julia","category":"page"},{"location":"stata_migration/#Advanced-Patterns-Beyond-Stata","page":"Migration Guide","title":"Advanced Patterns Beyond Stata","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Margins.jl extends far beyond Stata's capabilities with features unavailable in Stata:","category":"page"},{"location":"stata_migration/#Continuous-Variable-Binning","page":"Migration Guide","title":"Continuous Variable Binning","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Stata approach (manual and cumbersome):\ngen income_q = .\n_pctile income, nq(4)\nreplace income_q = 1 if income <= r(r1)\nreplace income_q = 2 if income > r(r1) & income <= r(r2)\nreplace income_q = 3 if income > r(r2) & income <= r(r3)\nreplace income_q = 4 if income > r(r3)\nmargins income_q","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Julia approach (automatic):\npopulation_margins(model, data; groups=(:income, 4))  # Automatic Q1-Q4 quartiles","category":"page"},{"location":"stata_migration/#Custom-Policy-Thresholds","page":"Migration Guide","title":"Custom Policy Thresholds","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Stata approach:\ngen income_bracket = .\nreplace income_bracket = 1 if income < 25000\nreplace income_bracket = 2 if income >= 25000 & income < 50000\nreplace income_bracket = 3 if income >= 50000 & income < 75000\nreplace income_bracket = 4 if income >= 75000\nmargins income_bracket","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Julia approach:\npopulation_margins(model, data; groups=(:income, [25000, 50000, 75000]))","category":"page"},{"location":"stata_migration/#Hierarchical-Grouping","page":"Migration Guide","title":"Hierarchical Grouping","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Stata approach (requires multiple commands or complex by groups):\nby region: margins education\n* No native support for deep nesting","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Julia approach (native hierarchical support):\npopulation_margins(model, data; groups=:region => :education)\npopulation_margins(model, data; groups=:country => (:region => :education))  # Deep nesting","category":"page"},{"location":"stata_migration/#Multi-Variable-Scenarios","page":"Migration Guide","title":"Multi-Variable Scenarios","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Stata approach (requires multiple separate commands):\nmargins, at(treatment=0 policy=0)\nmargins, at(treatment=0 policy=1) \nmargins, at(treatment=1 policy=0)\nmargins, at(treatment=1 policy=1)","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Julia approach (automatic Cartesian product):\npopulation_margins(model, data; scenarios=(treatment=[0, 1], policy=[0, 1]))","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Note: scenarios in Julia are population‑level counterfactuals (everyone receives each setting in turn). For Stata’s point‑evaluation semantics of at(), use profile_margins(model, data, reference_grid) with a grid builder (e.g., means_grid, cartesian_grid) or an explicit DataFrame.","category":"page"},{"location":"stata_migration/#Complete-Workflow-Examples","page":"Migration Guide","title":"Complete Workflow Examples","text":"","category":"section"},{"location":"stata_migration/#Example-1:-Education-Policy-Analysis","page":"Migration Guide","title":"Example 1: Education Policy Analysis","text":"","category":"section"},{"location":"stata_migration/#Stata-Workflow","page":"Migration Guide","title":"Stata Workflow","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Fit model\nlogit outcome education income female urban policy_treatment\n\n* Basic effects\nmargins, dydx(*)\n\n* Effects by education\nmargins education, dydx(income)\n\n* Policy scenarios (multiple commands required)\nmargins education, at(policy_treatment=0)\nmargins education, at(policy_treatment=1)\n\n* Manual difference calculation needed for treatment effects","category":"page"},{"location":"stata_migration/#Julia-Workflow","page":"Migration Guide","title":"Julia Workflow","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Fit model  \nmodel = glm(@formula(outcome ~ education + income + female + urban + policy_treatment),\n            data, Binomial(), LogitLink())\n\n# Basic effects\nbasic_effects = population_margins(model, data; type=:effects)\n\n# Effects by education\neducation_effects = population_margins(model, data; \n                                     type=:effects, \n                                     vars=[:income],\n                                     groups=:education)\n\n# Policy scenarios (automatic treatment effect calculation)\npolicy_analysis = population_margins(model, data;\n                                   type=:effects,\n                                   groups=:education,\n                                   scenarios=(:policy_treatment => [0, 1]))\n\n# All results readily available as DataFrames\nDataFrame(policy_analysis)","category":"page"},{"location":"stata_migration/#Example-2:-Complex-Demographic-Analysis","page":"Migration Guide","title":"Example 2: Complex Demographic Analysis","text":"","category":"section"},{"location":"stata_migration/#Stata-Approach-(Cumbersome)","page":"Migration Guide","title":"Stata Approach (Cumbersome)","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"* Multiple manual commands needed:\nmargins education, over(region)\nmargins gender, over(region)  \nmargins education#gender, over(region)\n\n* Income quartiles require manual creation:\nxtile income_q4 = income, nq(4)\nmargins education, over(income_q4)\n\n* No native support for hierarchical analysis","category":"page"},{"location":"stata_migration/#Julia-Approach-(Comprehensive)","page":"Migration Guide","title":"Julia Approach (Comprehensive)","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Single comprehensive analysis\ncomprehensive_results = population_margins(model, data;\n    type=:effects,\n    groups=:region => [:education, :gender, (:income, 4)]\n)\n\n# Results: Region × (Education + Gender + Income-Quartiles) automatically computed\n# Professional Q1-Q4 labeling included\nDataFrame(comprehensive_results)","category":"page"},{"location":"stata_migration/#Performance-Comparisons","page":"Migration Guide","title":"Performance Comparisons","text":"","category":"section"},{"location":"stata_migration/#Computational-Advantages","page":"Migration Guide","title":"Computational Advantages","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Aspect Stata Margins.jl\nComplex grouping Multiple manual commands Single comprehensive call\nScenario analysis Manual looping/multiple commands Automatic Cartesian products\nLarge datasets Memory limitations Efficient O(n) scaling\nCustom thresholds Manual variable creation Automatic binning with labels\nHierarchical analysis Limited native support Unlimited nesting depth","category":"page"},{"location":"stata_migration/#Stata-Command-Count-Reduction","page":"Migration Guide","title":"Stata Command Count Reduction","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# This single Julia command:\nresult = population_margins(model, data;\n    groups=:region => [:education, (:income, 4)],\n    scenarios=(treatment=[0, 1], policy=[\"old\", \"new\"])\n)\n\n# Replaces ~30 individual Stata margins commands:\n# 4 regions × 3 education × 4 income × 2 treatment × 2 policy = 192 combinations\n# Plus manual variable creation, looping, and results compilation","category":"page"},{"location":"stata_migration/#Migration-Best-Practices","page":"Migration Guide","title":"Migration Best Practices","text":"","category":"section"},{"location":"stata_migration/#Workflow-Translation-Strategy","page":"Migration Guide","title":"Workflow Translation Strategy","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Start with basic commands: Translate simple margins and margins, dydx(*) first\nIdentify grouping patterns: Map Stata over() and by: to Julia groups  \nDistinguish scenarios vs profiles: Decide whether Stata at() should become Julia scenarios or at\nLeverage advanced features: Use continuous binning and hierarchical grouping where beneficial\nConsolidate analyses: Combine multiple Stata commands into single Julia calls","category":"page"},{"location":"stata_migration/#Common-Translation-Patterns","page":"Migration Guide","title":"Common Translation Patterns","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Pattern 1: Simple margins → population_margins\n# margins → population_margins(model, data; type=:predictions)\n\n# Pattern 2: Effects by groups → groups parameter  \n# margins education, dydx(*) → population_margins(model, data; type=:effects, groups=:education)\n\n# Pattern 3: Multiple at() values → scenarios or profile grids\n# margins, at(x=(0 1 2)) → profile_margins(model, data, cartesian_grid(x=[0, 1, 2]))\n# OR population_margins(model, data; scenarios=(x=[0, 1, 2]))  # for counterfactuals\n\n# Pattern 4: Complex manual analysis → comprehensive single call\n# Multiple Stata commands → single population_margins with groups + scenarios","category":"page"},{"location":"stata_migration/#Verification-Strategy","page":"Migration Guide","title":"Verification Strategy","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"# Verify translation accuracy by comparing key results:\n# 1. Basic AME should match Stata margins, dydx(*)\n# 2. Group means should match Stata margins groupvar\n# 3. Scenario analysis should match Stata at() where comparable","category":"page"},{"location":"stata_migration/#Julia-Advantages-for-Economists","page":"Migration Guide","title":"Julia Advantages for Economists","text":"","category":"section"},{"location":"stata_migration/#Research-Productivity","page":"Migration Guide","title":"Research Productivity","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Fewer commands: Complex analyses require single function calls\nAutomatic labeling: Professional statistical terminology (Q1-Q4, T1-T3, P1-P5)\nIntegrated workflows: Results immediately available as DataFrames for further analysis\nReproducible research: Single script replaces multiple Stata command sequences","category":"page"},{"location":"stata_migration/#Advanced-Capabilities","page":"Migration Guide","title":"Advanced Capabilities","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Hierarchical analysis: Organizational structures represented naturally\nPolicy thresholds: Custom economically-relevant cutpoints without manual coding\nScenario space exploration: Automatic Cartesian product expansion\nLarge dataset support: Memory-efficient computation for modern data sizes","category":"page"},{"location":"stata_migration/#Statistical-Rigor","page":"Migration Guide","title":"Statistical Rigor","text":"","category":"section"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"Zero tolerance for statistical errors: Package errors rather than producing invalid results\nBootstrap validation: All standard errors validated against bootstrap estimates  \nDelta method implementation: Proper covariance matrix handling throughout\nPublication quality: Results meet econometric publication standards","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"","category":"page"},{"location":"stata_migration/","page":"Migration Guide","title":"Migration Guide","text":"This guide provides complete translation patterns for migrating from Stata to Margins.jl. The Julia approach often simplifies complex analyses while providing more sophisticated capabilities. For detailed examples, see Examples. For comprehensive grouping documentation, see Population Grouping Framework.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Comprehensive workflow examples and implementation patterns","category":"page"},{"location":"examples/#Conceptual-Overview","page":"Examples","title":"Conceptual Overview","text":"","category":"section"},{"location":"examples/#Example-Organization","page":"Examples","title":"Example Organization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This guide demonstrates practical implementation of the two-dimensional analytical framework through concrete examples. Examples progress from basic usage patterns to advanced specification techniques, illustrating both population and profile analysis approaches across diverse econometric applications.","category":"page"},{"location":"examples/#Basic-Implementation","page":"Examples","title":"Basic Implementation","text":"","category":"section"},{"location":"examples/#Fundamental-Usage-Pattern","page":"Examples","title":"Fundamental Usage Pattern","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Random\nusing Margins, DataFrames, GLM\n\n# Generate sample data\nn = 1000\nRandom.seed!(06515)\ndf = DataFrame(\n    y = randn(n),\n    x1 = randn(n), \n    x2 = randn(n),\n    group = rand([\"A\", \"B\", \"C\"], n)\n)\n\n# Fit model\nmodel = lm(@formula(y ~ x1 + x2 + group), df)\n\n# Population average marginal effects (AME)\name_result = population_margins(model, df; type=:effects)\nDataFrame(ame_result)\n\n# Marginal effects at sample means (MEM)  \nmem_result = profile_margins(model, df, means_grid(df); type=:effects)\nDataFrame(mem_result)","category":"page"},{"location":"examples/#Advanced-Implementation-Patterns","page":"Examples","title":"Advanced Implementation Patterns","text":"","category":"section"},{"location":"examples/#Profile-Specification-Methods","page":"Examples","title":"Profile Specification Methods","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Margins.jl provides multiple approaches to specify evaluation profiles for profile_margins(), each optimized for different analytical requirements.","category":"page"},{"location":"examples/#1.-Table-Based-Reference-Grid-(Maximum-Control)","page":"Examples","title":"1. Table-Based Reference Grid (Maximum Control)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For exact control over evaluation points, pass a DataFrame directly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using DataFrames\n\n# Custom reference grid\nreference_grid = DataFrame(\n    x1 = [-1.0, 0.0, 1.0],\n    x2 = [10, 15, 20],\n    group = [\"A\", \"B\", \"A\"]  # Row order preserved as specified\n)\n\n# Predictions at specific points\npredictions = profile_margins(model, df, reference_grid; type=:predictions)\n\n# Effects at specific points  \neffects = profile_margins(model, df, reference_grid; type=:effects, vars=[:x1, :x2])","category":"page"},{"location":"examples/#2.-Cartesian-Product-Specification","page":"Examples","title":"2. Cartesian Product Specification","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For systematic scenario construction, use grid builders to specify value combinations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Systematic scenario grid (Cartesian product)\nscenarios = cartesian_grid(x1=[-1.0, 0.0, 1.0], x2=[10, 20], group=[\"A\", \"B\"])  \n# Creates 3×2×2 = 12 evaluation points\n\n# Effects across all scenarios\nscenario_effects = profile_margins(model, df, scenarios; type=:effects, vars=[:x1])\nDataFrame(scenario_effects)","category":"page"},{"location":"examples/#3.-At-Sample-Means-(Most-Common)","page":"Examples","title":"3. At Sample Means (Most Common)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For representative case analysis:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Effects at sample means - most interpretable approach\nmeans_effects = profile_margins(model, df, means_grid(df); type=:effects)\n\n# Predictions at sample means\nmeans_predictions = profile_margins(model, df, means_grid(df); type=:predictions)","category":"page"},{"location":"examples/#4.-Explicit-Profile-Tables","page":"Examples","title":"4. Explicit Profile Tables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For irregular or custom evaluation points, pass an explicit DataFrame:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"custom_profiles = DataFrame(\n    x1 = [-1.0, 0.0, 1.0],\n    x2 = [10, 15, 20],\n    group = [\"A\", \"B\", \"A\"]\n)\n\nresults = profile_margins(model, df, custom_profiles; type=:effects)","category":"page"},{"location":"examples/#5.-Categorical-Mixtures-for-Policy-Analysis","page":"Examples","title":"5. Categorical Mixtures for Policy Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For realistic population scenarios using categorical mixtures:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CategoricalArrays\n\n# Realistic policy scenarios with population composition\nmixture_grid = DataFrame(group=[mix(\"A\" => 0.5, \"B\" => 0.3, \"C\" => 0.2)])\npolicy_scenario = profile_margins(model, df, mixture_grid; type=:predictions)\n\n# Multiple policy scenarios\npolicy_grid = DataFrame(\n    x1 = [0, 1],  # Policy intervention levels\n    group = [mix(\"A\" => 0.6, \"B\" => 0.4), mix(\"A\" => 0.6, \"B\" => 0.4)]\n)\npolicy_effects = profile_margins(model, df, policy_grid; type=:effects)","category":"page"},{"location":"examples/#Economic-Analysis-Workflow","page":"Examples","title":"Economic Analysis Workflow","text":"","category":"section"},{"location":"examples/#Wage-Determination-Analysis","page":"Examples","title":"Wage Determination Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Complete econometric workflow using human capital theory:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GLM, CategoricalArrays, Random\n\n# Generate realistic econometric dataset\nRandom.seed!(06515)\nn = 2000\n\ndata = DataFrame(\n    # Demographics\n    age = rand(25:65, n),\n    female = rand([0, 1], n),\n    education = categorical(rand([\"HS\", \"College\", \"Graduate\"], n)),\n    \n    # Economic variables\n    experience = rand(0:40, n),\n    urban = rand([0, 1], n),\n    unemployment_rate = rand(3.0:0.1:12.0, n)\n)\n\n# Generate realistic log wages\neducation_effects = Dict(\"HS\" => 0.0, \"College\" => 0.4, \"Graduate\" => 0.8)\nedu_numeric = [education_effects[string(edu)] for edu in data.education]\n\ndata.log_wage = 1.5 .+ \n                0.05 .* data.age .+ \n                edu_numeric .+ \n                0.02 .* data.experience .- \n                0.15 .* data.female .+ \n                0.10 .* data.urban .- \n                0.03 .* data.unemployment_rate .+ \n                0.3 .* randn(n)\n\n# Fit wage equation\nwage_model = lm(@formula(log_wage ~ age + education + experience + \n                        female + urban + unemployment_rate), data)","category":"page"},{"location":"examples/#Population-Analysis","page":"Examples","title":"Population Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Population average marginal effects\name_results = population_margins(wage_model, data; type=:effects)\nprintln(\"Population Average Marginal Effects:\")\nprintln(DataFrame(ame_results))\n\n# Effects by gender subgroups  \ngender_effects = population_margins(wage_model, data; \n                                  type=:effects, \n                                  groups=:female)\nprintln(\"Effects by gender:\")\nprintln(DataFrame(gender_effects))","category":"page"},{"location":"examples/#Profile-Analysis","page":"Examples","title":"Profile Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Effects at sample means (representative person)\nmem_results = profile_margins(wage_model, data, means_grid(data); type=:effects)\nprintln(\"Effects for typical person:\")\nprintln(DataFrame(mem_results))\n\n# Policy scenarios: education and unemployment effects\npolicy_grid = cartesian_grid(education=[\"HS\", \"College\", \"Graduate\"],\n                             unemployment_rate=[3.0, 6.0, 9.0])\npolicy_analysis = profile_margins(wage_model, data, policy_grid; type=:predictions)\nprintln(\"Policy scenario predictions:\")\nprintln(DataFrame(policy_analysis))","category":"page"},{"location":"examples/#Logistic-Regression-Example","page":"Examples","title":"Logistic Regression Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Binary outcome analysis with proper probability interpretation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Generate binary outcome data\ndata.manager = [rand() < (1/(1+exp(-(-1.0 + 0.03*age + 0.5*edu + 0.02*exp - 0.3*fem)))) ? 1 : 0 \n                for (age,edu,exp,fem) in zip(data.age, edu_numeric, data.experience, data.female)]\n\n# Fit logistic model\nlogit_model = glm(@formula(manager ~ age + education + experience + female), \n                  data, Binomial(), LogitLink())\n\n# Effects on probability scale (most interpretable)\nprob_effects = population_margins(logit_model, data; \n                                type=:effects, \n                                scale=:response)\nprintln(\"Effects on probability of management position:\")\nprintln(DataFrame(prob_effects))\n\n# Gender gap analysis across education levels\ngender_grid = cartesian_grid(education=[\"HS\", \"College\", \"Graduate\"], female=[0, 1])\ngender_gap = profile_margins(logit_model, data, gender_grid;\n    type=:predictions, scale=:response)\nprintln(\"Gender gap in management probability by education:\")\nprintln(DataFrame(gender_gap))","category":"page"},{"location":"examples/#Elasticity-Analysis","page":"Examples","title":"Elasticity Analysis","text":"","category":"section"},{"location":"examples/#Basic-Elasticity-Computation","page":"Examples","title":"Basic Elasticity Computation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Population average elasticities\nelasticities = population_margins(wage_model, data; \n                                type=:effects, \n                                measure=:elasticity,\n                                vars=[:age, :experience])\nprintln(\"Population average elasticities:\")\nprintln(DataFrame(elasticities))\n\n# Elasticities at different education levels\nedu_grid = cartesian_grid(education=[\"HS\", \"College\", \"Graduate\"]) \nedu_elasticities = profile_margins(wage_model, data, edu_grid;\n    type=:effects, measure=:elasticity, vars=[:age, :experience])\nprintln(\"Elasticities by education level:\")\nprintln(DataFrame(edu_elasticities))","category":"page"},{"location":"examples/#Semi-Elasticities","page":"Examples","title":"Semi-Elasticities","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Semi-elasticity: % change in wages per unit change in unemployment\nunemployment_semi = population_margins(wage_model, data;\n                                     measure=:semielasticity_dyex,\n                                     vars=[:unemployment_rate])\nprintln(\"Unemployment semi-elasticity (% wage change per point):\")\nprintln(DataFrame(unemployment_semi))","category":"page"},{"location":"examples/#Advanced-Features","page":"Examples","title":"Advanced Features","text":"","category":"section"},{"location":"examples/#Advanced-Grouping-and-Stratification","page":"Examples","title":"Advanced Grouping and Stratification","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Basic categorical grouping\nurban_analysis = population_margins(wage_model, data; \n                                  type=:effects, \n                                  groups=:urban)\n\n# Cross-tabulated grouping\neducation_urban = population_margins(wage_model, data; \n                                   type=:effects, \n                                   groups=[:education, :urban])\n\n# Hierarchical grouping: education → urban within each education level\nnested_analysis = population_margins(wage_model, data;\n                                   type=:effects,\n                                   groups=:education => :urban)\n\n# Continuous binning: age quartiles\nage_quartiles = population_margins(wage_model, data;\n                                 type=:effects,\n                                 groups=(:age, 4))\n\n# Custom thresholds for policy analysis\nincome_thresholds = population_margins(wage_model, data;\n                                     type=:effects,\n                                     groups=(:log_wage, [2.0, 2.5, 3.0]))\n\n# Mixed categorical and continuous\ncomplex_groups = population_margins(wage_model, data;\n                                  type=:effects,\n                                  groups=[:education, (:age, 4)])","category":"page"},{"location":"examples/#Counterfactual-Scenario-Analysis","page":"Examples","title":"Counterfactual Scenario Analysis","text":"","category":"section"},{"location":"examples/#Skip-Rule-Example:-dydx(x)-across-x-strata-using-a-derived-bin-variable","page":"Examples","title":"Skip Rule Example: dydx(x) across x strata using a derived bin variable","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Statistics\nusing CategoricalArrays\n\n# Suppose we want dydx(age) across age strata without holding age fixed or using it as the grouping key directly.\n# Create an \"age_bin\" column (quartiles), then group by that derived column:\nedges = quantile(data.age, 0:0.25:1.0)\nlabels = [\"Q1\", \"Q2\", \"Q3\", \"Q4\"]\ndata.age_bin = cut(data.age, edges; labels=labels, extend=true)\n\nage_effects_by_bin = population_margins(wage_model, data;\n    type=:effects,\n    vars=[:age],\n    groups=:age_bin)\n\nDataFrame(age_effects_by_bin)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Policy scenarios: unemployment rate effects\nrecession_scenarios = population_margins(wage_model, data;\n                                       type=:effects,\n                                       scenarios=(:unemployment_rate => [3.0, 6.0, 12.0]))\n\n# Combined grouping and scenarios\neducation_recession = population_margins(wage_model, data;\n                                       type=:effects,\n                                       groups=:education,\n                                       scenarios=(:unemployment_rate => [3.0, 12.0]))\n\n# Multi-variable scenarios\ncomplex_policy = population_margins(wage_model, data;\n                                  type=:effects,\n                                  scenarios=(:urban => [0, 1], \n                                               :unemployment_rate => [3.0, 9.0]))","category":"page"},{"location":"examples/#Robust-Standard-Errors","page":"Examples","title":"Robust Standard Errors","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CovarianceMatrices\n\n# Heteroskedasticity-robust standard errors (HC1)\nrobust_effects = population_margins(wage_model, data; vcov=CovarianceMatrices.HC1, type=:effects)\nprintln(\"Robust standard errors:\")\nprintln(DataFrame(robust_effects))","category":"page"},{"location":"examples/#Performance-Comparison","page":"Examples","title":"Performance Comparison","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BenchmarkTools\n\n# Profile margins: O(1) constant time\nprintln(\"Profile margins performance (constant time):\")\n@btime profile_margins($wage_model, $data, means_grid($data); type=:effects)\n\n# Population margins: O(n) scaling  \nprintln(\"Population margins performance (scales with n):\")\n@btime population_margins($wage_model, $data; type=:effects)\n\n# Complex scenario analysis (still O(1) for profiles)\ncomplex_scenarios = cartesian_grid(age=[25, 35, 45, 55],\n                                   education=[\"HS\", \"College\", \"Graduate\"],\n                                   urban=[0, 1])\nprintln(\"Complex scenario performance (24 profiles, still O(1)):\")\n@btime profile_margins($wage_model, $data, $complex_scenarios; type=:effects)","category":"page"},{"location":"examples/#Stata-Migration-Examples","page":"Examples","title":"Stata Migration Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Direct equivalency for economists familiar with Stata:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Stata: margins, dydx(*)\nstata_ame = population_margins(wage_model, data; type=:effects)\n\n# Stata: margins, at(means) dydx(*)  \nstata_mem = profile_margins(wage_model, data, means_grid(data); type=:effects)\n\n# Stata: margins, at(age=(25 35 45) education=(1 2 3))\nstata_grid = cartesian_grid(age=[25, 35, 45], education=[\"HS\", \"College\", \"Graduate\"]) \nstata_scenarios = profile_margins(wage_model, data, stata_grid; type=:effects)\n\n# Stata: margins, over(female)\nstata_subgroups = population_margins(wage_model, data; \n                                   type=:effects, \n                                   groups=:female)","category":"page"},{"location":"examples/#MixedModels.jl-Examples","page":"Examples","title":"MixedModels.jl Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Minimal linear and generalized linear mixed models with population analysis.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Illustrative example (not executed in docs CI): MixedModels integration\nusing Random\nusing DataFrames, CategoricalArrays, MixedModels, StatsModels, Margins\n\n# Synthetic random-intercept dataset\nRandom.seed!(42)\nn_groups = 20; n_per = 30; n = n_groups * n_per\ngroup = repeat(1:n_groups, inner=n_per)\nx = randn(n)\nu = randn(n_groups)  # random intercepts\ny = 1.0 .+ 0.5 .* x .+ u[group] .+ 0.2 .* randn(n)\ndf = DataFrame(y=y, x=x, group=categorical(string.(group)))\n\n# Linear mixed model\nlmm = fit(MixedModel, @formula(y ~ 1 + x + (1 | group)), df)\n\n# Population AME for x (averaged across sample distribution)\name_lmm = population_margins(lmm, df; type=:effects, vars=[:x])\n\n# Generalized linear mixed model (binary outcome)\nη = -0.5 .+ 1.2 .* x .+ u[group]\np = 1.0 ./ (1 .+ exp.(-η))\nybin = rand.(Bernoulli.(p))\ndf_bin = DataFrame(y=ybin, x=x, group=df.group)\n\nglmm = GeneralizedLinearMixedModel(@formula(y ~ 1 + x + (1 | group)), df_bin, Binomial()) |> fit!\n\n# Probability-scale effects\nprob_effects_glmm = population_margins(glmm, df_bin; type=:effects, vars=[:x], scale=:response)","category":"page"},{"location":"examples/#Best-Practices","page":"Examples","title":"Best Practices","text":"","category":"section"},{"location":"examples/#When-to-Use-Population-vs-Profile","page":"Examples","title":"When to Use Population vs Profile","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Choose Population Analysis When:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Estimating true average effects across your sample\nSample heterogeneity is important for policy\nExternal validity to similar populations is the goal\nBroad policy applications affecting diverse groups","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Choose Profile Analysis When:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Understanding specific, concrete scenarios  \nCommunicating results to non-technical audiences\nSample is relatively homogeneous\nPolicy targets specific demographic profiles","category":"page"},{"location":"examples/#Performance-Guidelines","page":"Examples","title":"Performance Guidelines","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# For large datasets (>100k observations)\n# Profile margins remain fast regardless of size\nlarge_data_profiles = profile_margins(model, large_data, means_grid(large_data); type=:effects)\n\n# Population margins scale linearly - use selectively for very large data\nkey_population_effects = population_margins(model, large_data; \n                                          vars=[:key_variable], \n                                          type=:effects)","category":"page"},{"location":"examples/#Error-Handling","page":"Examples","title":"Error Handling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Graceful error handling for production workflows (TODO: WE DON'T WANT THIS)\nfunction robust_margins_analysis(model, data)\n    try\n        # Try high-accuracy automatic differentiation\n        return population_margins(model, data; backend=:ad, type=:effects)\n    catch e\n        @warn \"AD backend failed, using finite differences\" exception=e\n        return population_margins(model, data; backend=:fd, type=:effects)\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples demonstrate the full range of Margins.jl capabilities. For detailed API documentation, see API Reference. For performance optimization, see Performance Guide.","category":"page"},{"location":"#Margins.jl","page":"Introduction","title":"Margins.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Marginal effects for Julia","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Margins.jl provides a rigorous computational framework for marginal effects analysis in econometric applications. The package implements a systematic approach to marginal effects computation through a conceptually unified framework that distinguishes between population-level and profile-specific analyses. The computational architecture achieves constant-time performance for profile analysis while maintaining statistical validity through comprehensive delta-method standard error computation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package integrates seamlessly with the established JuliaStats ecosystem, providing compatibility with StatsModels.jl for model specification, GLM.jl for generalized linear models, and CovarianceMatrices.jl for robust standard errors. The implementation builds upon FormulaCompiler.jl to achieve efficient and mathematically precise marginal effect computation suitable for publication-grade econometric analysis.","category":"page"},{"location":"#Implementation-Overview","page":"Introduction","title":"Implementation Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Random\nusing CategoricalArrays, DataFrames, GLM, Margins\n\n# Generate sample data\nn = 1000\nRandom.seed!(06515)\ndf = DataFrame(\n    y = randn(n),\n    x1 = randn(n), \n    x2 = randn(n),\n    group = categorical(rand([\"A\", \"B\", \"C\"], n))\n)\n\n# Fit model\nmodel = lm(@formula(y ~ x1 + x2 + group), df)\n\n# Population analysis: effects averaged across sample distribution\name_result = population_margins(model, df; type=:effects)\nDataFrame(ame_result)\n\n# Profile analysis: effects at representative points\nmem_result = profile_margins(model, df, means_grid(df); type=:effects)\nDataFrame(mem_result)","category":"page"},{"location":"#Methodological-Framework","page":"Introduction","title":"Methodological Framework","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Marginal Effects Framework Overview  This package addresses two core questions in marginal effects analysis:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Effects: \"How much does Y change when I change X?\" (like: \"How much do wages increase per year of education?\")\nPredictions: \"What value of Y should I expect for specific values of X?\" (like: \"What wage should I expect for someone with 16 years of education?\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The methodological foundation of Margins.jl rests upon a two-dimensional analytical framework that systematically addresses the fundamental questions arising in marginal effects analysis. This framework distinguishes between the evaluation context and the analytical target, thereby providing a comprehensive approach to econometric inference.","category":"page"},{"location":"#Evaluation-Context","page":"Introduction","title":"Evaluation Context","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The choice of evaluation context determines the distributional properties of the marginal effects estimates. Population analysis computes effects averaged across the observed sample distribution, yielding estimates that reflect the heterogeneity present in the data generating process. Profile analysis evaluates effects at specific covariate combinations, providing inference at representative or theoretically meaningful points in the covariate space.","category":"page"},{"location":"#Analytical-Targets","page":"Introduction","title":"Analytical Targets","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The analytical target specifies the statistical quantity of interest within the chosen evaluation context. Effects analysis computes marginal effects through appropriate differentiation of the conditional expectation function, utilizing analytical derivatives for continuous variables and discrete contrasts for categorical variables. Predictions analysis evaluates adjusted predictions, providing fitted values that incorporate the full uncertainty structure of the estimated model.","category":"page"},{"location":"#Analytical-Framework-Implementation","page":"Introduction","title":"Analytical Framework Implementation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"# Population Analysis: Sample Distribution Averaging\npopulation_margins(model, data; type=:effects)      # Average Marginal Effects\npopulation_margins(model, data; type=:predictions)  # Average Adjusted Predictions\n\n# Profile Analysis: Representative Point Evaluation\nprofile_margins(model, data, means_grid(data); type=:effects)      # Effects at Sample Means\nprofile_margins(model, data, means_grid(data); type=:predictions)  # Predictions at Sample Means","category":"page"},{"location":"#Computational-Architecture-and-Statistical-Properties","page":"Introduction","title":"Computational Architecture and Statistical Properties","text":"","category":"section"},{"location":"#Performance-Characteristics","page":"Introduction","title":"Performance Characteristics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The computational implementation achieves constant-time complexity for profile analysis through optimized evaluation algorithms that scale independently of dataset size. Population analysis exhibits linear scaling with respect to sample size while maintaining minimal per-observation computational overhead through zero-allocation implementations built upon the FormulaCompiler.jl foundation. The architecture has been empirically validated across datasets ranging from small-scale experimental studies to large administrative datasets exceeding one million observations. Detailed performance analysis is provided in the Performance Guide.","category":"page"},{"location":"#Statistical-Inference-Framework","page":"Introduction","title":"Statistical Inference Framework","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Statistical inference employs rigorous delta-method standard error computation with full integration of the model's covariance matrix structure. The implementation prioritizes statistical validity over computational convenience, implementing an error-first policy whereby invalid statistical operations generate explicit errors rather than approximate results. All statistical computations have been validated through bootstrap comparison studies to ensure coverage probability accuracy suitable for econometric research applications and academic publication standards.","category":"page"},{"location":"#Extended-Analytical-Capabilities","page":"Introduction","title":"Extended Analytical Capabilities","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package supports comprehensive elasticity analysis through parametric specification of effect measures, including standard elasticities and semi-elasticity variants for both dependent and independent variable transformations. Policy analysis applications are supported through categorical mixture specifications that enable realistic population composition modeling. The inference framework accommodates robust and clustered standard error computation through integration with CovarianceMatrices.jl, while flexible subgroup analysis capabilities facilitate stratified inference across multiple dimensions of heterogeneity. Comprehensive coverage of these advanced methodological features is provided in Advanced Features.","category":"page"},{"location":"#Implementation-Examples","page":"Introduction","title":"Implementation Examples","text":"","category":"section"},{"location":"#Profile-Specification","page":"Introduction","title":"Profile Specification","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Multiple ways to specify evaluation points:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# At sample means (most common)\nprofile_margins(model, data, means_grid(data); type=:effects)\n\n# Custom scenarios\nscenarios = cartesian_grid(x1=[0, 1, 2], group=[\"A\", \"B\"]) \nprofile_margins(model, data, scenarios; type=:effects)\n\n# Complex realistic scenarios with categorical mixtures\nusing CategoricalArrays\nmixture_grid = DataFrame(group=[mix(\"A\" => 0.5, \"B\" => 0.3, \"C\" => 0.2)])\nprofile_margins(model, data, mixture_grid; type=:predictions)\n\n# Pre-built reference grids (maximum control)\nreference_grid = DataFrame(x1=[0, 1], x2=[0, 0], group=[\"A\", \"A\"])  \nprofile_margins(model, data, reference_grid; type=:effects)","category":"page"},{"location":"#Elasticity-Analysis","page":"Introduction","title":"Elasticity Analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"# Population average elasticities\npopulation_margins(model, data; type=:effects, measure=:elasticity)\n\n# Elasticities at representative scenarios  \nprofile_margins(model, data, means_grid(data); type=:effects, measure=:elasticity)\n\n# Semi-elasticities  \npopulation_margins(model, data; measure=:semielasticity_dyex)  # change Y per % change X\npopulation_margins(model, data; measure=:semielasticity_eydx)  # % change Y per unit X","category":"page"},{"location":"#Subgroup-Analysis","page":"Introduction","title":"Subgroup Analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"# Effects by categorical groups\npopulation_margins(model, data; type=:effects, groups=:region)\n\n# Multiple grouping variables  \npopulation_margins(model, data; type=:effects, groups=[:region, :year])\n\n# Complex nested grouping\npopulation_margins(model, data; type=:effects, groups=[:region, :income_quartile])","category":"page"},{"location":"#Statistical-Validity-and-Methodological-Standards","page":"Introduction","title":"Statistical Validity and Methodological Standards","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package implements rigorous statistical principles designed to meet the standards required for econometric research and academic publication. Delta-method standard error computation incorporates the complete covariance matrix structure of the underlying statistical model, ensuring appropriate propagation of parameter uncertainty through the marginal effects calculations. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The implementation follows an error-first philosophy whereby statistical operations that cannot guarantee validity generate explicit errors rather than potentially misleading approximate results. This approach prioritizes statistical correctness over computational convenience, reflecting the fundamental requirement that econometric software produce results suitable for peer-reviewed research applications.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All statistical procedures have undergone comprehensive validation through bootstrap comparison studies and theoretical verification, ensuring that confidence intervals, hypothesis tests, and other inferential procedures maintain appropriate coverage probabilities and Type I error rates across diverse model specifications and data characteristics.  ","category":"page"},{"location":"#Integration-with-JuliaStats","page":"Introduction","title":"Integration with JuliaStats","text":"","category":"section"},{"location":"#Model-Compatibility","page":"Introduction","title":"Model Compatibility","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package provides comprehensive compatibility with models following the StatsModels.jl interface specifications. Support encompasses linear models, logistic regression, Poisson models, and other generalized linear model families through GLM.jl integration. Mixed effects modeling is accommodated through MixedModels.jl compatibility for both linear and generalized linear mixed model specifications. Extensions to custom model types are supported provided they implement the standard coef() and vcov() accessor methods.","category":"page"},{"location":"#Data-Integration-Framework","page":"Introduction","title":"Data Integration Framework","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Data handling utilizes the Tables.jl interface to ensure compatibility with diverse data sources including DataFrames, CSV files, and database result sets. The specialized result types (EffectsResult and PredictionsResult) implement the Tables.jl protocol to enable seamless conversion to DataFrame format for downstream analysis and reporting. This design provides maximum flexibility in data pipeline integration while maintaining type stability and computational efficiency.","category":"page"},{"location":"#Robust-Standard-Errors","page":"Introduction","title":"Robust Standard Errors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"# Using CovarianceMatrices.jl\nusing CovarianceMatrices\n\n# Robust standard errors (HC1)\npopulation_margins(model, data; vcov=CovarianceMatrices.HC1)\n\n# Clustered standard errors  \npopulation_margins(model, data; vcov=CovarianceMatrices.Clustered(:firm_id))","category":"page"},{"location":"#Computational-Performance-Analysis","page":"Introduction","title":"Computational Performance Analysis","text":"","category":"section"},{"location":"#Constant-Time-Profile-Evaluation","page":"Introduction","title":"Constant-Time Profile Evaluation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Profile analysis achieves computational complexity independent of dataset size through optimized algorithms that evaluate marginal effects at specified covariate combinations without full dataset traversal. This constant-time property holds across diverse scenario specifications, enabling efficient analysis of complex policy counterfactuals and sensitivity analyses regardless of the underlying sample size.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Profile margins exhibit O(1) complexity characteristics\n@time profile_margins(model, small_data, means_grid(small_data))    # baseline timing\n@time profile_margins(model, large_data, means_grid(large_data))    # identical complexity\n\n# Complex scenario specifications maintain constant-time properties\nscenarios = (x1=[0,1,2], x2=[10,20,30], group=[\"A\",\"B\"])  # 18 profiles\nscenarios = cartesian_grid(x1=[0,1,2], x2=[10,20,30], group=[\"A\",\"B\"])  # 18 profiles\n@time profile_margins(model, huge_data, scenarios)  # remains constant time","category":"page"},{"location":"#Linear-Scaling-in-Population-Analysis","page":"Introduction","title":"Linear Scaling in Population Analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Population analysis exhibits optimal linear scaling characteristics with respect to sample size while maintaining minimal per-observation computational overhead through zero-allocation implementations. The computational architecture ensures predictable performance scaling suitable for large-scale econometric applications and administrative dataset analysis.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Population margins demonstrate O(n) scaling with optimized per-row processing\n@time population_margins(model, data_1k)    # baseline linear scaling\n@time population_margins(model, data_10k)   # proportional computational cost\n@time population_margins(model, data_100k)  # maintained efficiency at scale","category":"page"},{"location":"#Documentation-Organization","page":"Introduction","title":"Documentation Organization","text":"","category":"section"},{"location":"#Conceptual-Foundation","page":"Introduction","title":"Conceptual Foundation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Mathematical Foundation: Theoretical basis and statistical properties\nComparison Guide: Methodological comparison with alternative approaches","category":"page"},{"location":"#Implementation-Reference","page":"Introduction","title":"Implementation Reference","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"API Reference: Complete function specifications and parameters\nPerformance Guide: Computational characteristics and benchmarks\nExamples: Executable workflows and application demonstrations","category":"page"},{"location":"#Migration-and-Integration","page":"Introduction","title":"Migration and Integration","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Stata Migration: Command equivalence and workflow translation\nAdvanced Features: Extended analytical capabilities","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Technical support and bug reports should be directed to the GitHub Issues repository.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"Margins\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Requirements: Julia ≥ 1.10","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use Margins.jl in your research, please cite:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{margins_jl,\n  author = {Feltham, Eric M.},\n  title = {Margins.jl: Marginal Effects and Adjusted Predictions for Julia Statistical Models},\n  url = {https://github.com/emfeltham/Margins.jl},\n  version = {2.0.0},\n  year = {2025}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Margins.jl builds upon FormulaCompiler.jl for high-performance statistical computation. Please also cite:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{formulacompiler_jl,\n  author = {Feltham, Eric M.},\n  title = {FormulaCompiler.jl: High-Performance Formula Evaluation and Automatic Differentiation for Julia},\n  url = {https://github.com/emfeltham/FormulaCompiler.jl},\n  version = {1.0.0},\n  year = {2025}\n}","category":"page"}]
}
