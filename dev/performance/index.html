<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance Guide · Margins.jl</title><meta name="title" content="Performance Guide · Margins.jl"/><meta property="og:title" content="Performance Guide · Margins.jl"/><meta property="twitter:title" content="Performance Guide · Margins.jl"/><meta name="description" content="Documentation for Margins.jl."/><meta property="og:description" content="Documentation for Margins.jl."/><meta property="twitter:description" content="Documentation for Margins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Margins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li><a class="tocitem" href="../computational_architecture/">Computational Architecture</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../reference_grids/">Reference Grids</a></li><li><a class="tocitem" href="../profile_margins/">Profile Analysis</a></li><li><a class="tocitem" href="../population_scenarios/">Population Scenarios</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../grouping/">Population Grouping</a></li><li><a class="tocitem" href="../backend_selection/">Backend Selection</a></li><li class="is-active"><a class="tocitem" href>Performance Guide</a><ul class="internal"><li><a class="tocitem" href="#Conceptual-Framework"><span>Conceptual Framework</span></a></li><li><a class="tocitem" href="#Implementation-Performance"><span>Implementation Performance</span></a></li><li><a class="tocitem" href="#Performance-Characteristics"><span>Performance Characteristics</span></a></li><li><a class="tocitem" href="#Dataset-Size-Guidelines"><span>Dataset Size Guidelines</span></a></li><li><a class="tocitem" href="#Optimization-Principles"><span>Optimization Principles</span></a></li><li><a class="tocitem" href="#Memory-Management"><span>Memory Management</span></a></li><li><a class="tocitem" href="#Performance-Best-Practices"><span>Performance Best Practices</span></a></li><li><a class="tocitem" href="#Troubleshooting-Performance-Issues"><span>Troubleshooting Performance Issues</span></a></li><li><a class="tocitem" href="#FormulaCompiler.jl-Integration"><span>FormulaCompiler.jl Integration</span></a></li><li><a class="tocitem" href="#Production-Deployment-Guidelines"><span>Production Deployment Guidelines</span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><a class="tocitem" href="../stata_migration/">Migration Guide</a></li><li><a class="tocitem" href="../comparison/">Package Comparison</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Performance Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Performance Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl/" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance-Guide"><a class="docs-heading-anchor" href="#Performance-Guide">Performance Guide</a><a id="Performance-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guide" title="Permalink"></a></h1><p><em>Computational characteristics and optimization strategies</em></p><h2 id="Conceptual-Framework"><a class="docs-heading-anchor" href="#Conceptual-Framework">Conceptual Framework</a><a id="Conceptual-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Conceptual-Framework" title="Permalink"></a></h2><h3 id="Performance-Design-Principles"><a class="docs-heading-anchor" href="#Performance-Design-Principles">Performance Design Principles</a><a id="Performance-Design-Principles-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Design-Principles" title="Permalink"></a></h3><p>Margins.jl achieves computational efficiency through architectural design that respects the fundamental mathematical structure of marginal effects analysis. Performance optimization preserves statistical correctness while exploiting the distinct computational requirements of population versus profile analysis.</p><h3 id="Algorithmic-Complexity-Characteristics"><a class="docs-heading-anchor" href="#Algorithmic-Complexity-Characteristics">Algorithmic Complexity Characteristics</a><a id="Algorithmic-Complexity-Characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithmic-Complexity-Characteristics" title="Permalink"></a></h3><ul><li><strong>Profile Analysis</strong>: O(1) constant-time complexity independent of dataset size</li><li><strong>Population Analysis</strong>: O(n) linear scaling with optimized per-observation computational cost</li><li><strong>Statistical Integrity</strong>: All performance optimizations maintain mathematical validity</li></ul><h2 id="Implementation-Performance"><a class="docs-heading-anchor" href="#Implementation-Performance">Implementation Performance</a><a id="Implementation-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Performance" title="Permalink"></a></h2><h2 id="Performance-Characteristics"><a class="docs-heading-anchor" href="#Performance-Characteristics">Performance Characteristics</a><a id="Performance-Characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Characteristics" title="Permalink"></a></h2><h3 id="Profile-Analysis:-O(1)-Constant-Time"><a class="docs-heading-anchor" href="#Profile-Analysis:-O(1)-Constant-Time">Profile Analysis: O(1) Constant Time</a><a id="Profile-Analysis:-O(1)-Constant-Time-1"></a><a class="docs-heading-anchor-permalink" href="#Profile-Analysis:-O(1)-Constant-Time" title="Permalink"></a></h3><p>Profile margins achieve <strong>constant-time performance</strong> regardless of dataset size:</p><pre><code class="language-julia hljs">using BenchmarkTools, Margins

# Performance is independent of dataset size
@btime profile_margins($model, $data_1k, means_grid($data_1k); type=:effects)     # constant time
@btime profile_margins($model, $data_100k, means_grid($data_100k); type=:effects) # same complexity
@btime profile_margins($model, data_1M, means_grid(data_1M); type=:effects)       # same complexity

# Complex scenarios also O(1)
scenarios = cartesian_grid(x1=[0,1,2], x2=[10,20,30], group=[&quot;A&quot;,&quot;B&quot;])  # 18 profiles
@btime profile_margins($model, $huge_data, scenarios)                       # still constant time</code></pre><p><strong>Why this matters</strong>: Profile analysis cost is <strong>independent of sample size</strong>, making it efficient for large-scale econometric analysis.</p><h3 id="Population-Analysis:-Optimized-O(n)-Scaling"><a class="docs-heading-anchor" href="#Population-Analysis:-Optimized-O(n)-Scaling">Population Analysis: Optimized O(n) Scaling</a><a id="Population-Analysis:-Optimized-O(n)-Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Analysis:-Optimized-O(n)-Scaling" title="Permalink"></a></h3><p>Population margins scale linearly with optimized per-row costs:</p><pre><code class="language-julia hljs"># Linear scaling with low per-row computational cost
@btime population_margins($model, $data_1k)    # scales with dataset size
@btime population_margins($model, $data_10k)   # with efficient per-row processing  
@btime population_margins($model, $data_100k)  # minimal allocation overhead

# Memory footprint remains zero (both backends)
@allocated population_margins(model, data_1k; backend=:fd)    # 0 bytes
@allocated population_margins(model, data_10k; backend=:fd)   # 0 bytes
@allocated population_margins(model, data_100k; backend=:fd)  # 0 bytes

@allocated population_margins(model, data_1k; backend=:ad)    # 0 bytes
@allocated population_margins(model, data_10k; backend=:ad)   # 0 bytes
@allocated population_margins(model, data_100k; backend=:ad)  # 0 bytes</code></pre><p><strong>Why this matters</strong>: Population analysis maintains <strong>constant allocation footprint</strong> while delivering consistent per-row performance.</p><h2 id="Dataset-Size-Guidelines"><a class="docs-heading-anchor" href="#Dataset-Size-Guidelines">Dataset Size Guidelines</a><a id="Dataset-Size-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Size-Guidelines" title="Permalink"></a></h2><h3 id="Performance-Expectations-by-Scale"><a class="docs-heading-anchor" href="#Performance-Expectations-by-Scale">Performance Expectations by Scale</a><a id="Performance-Expectations-by-Scale-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Expectations-by-Scale" title="Permalink"></a></h3><table><tr><th style="text-align: right">Dataset Size</th><th style="text-align: right">Population Margins</th><th style="text-align: right">Profile Margins</th><th style="text-align: right">Recommended Workflow</th></tr><tr><td style="text-align: right"><strong>&lt; 1k</strong></td><td style="text-align: right">Fast</td><td style="text-align: right">Constant time</td><td style="text-align: right">Use either approach freely</td></tr><tr><td style="text-align: right"><strong>1k-10k</strong></td><td style="text-align: right">Fast</td><td style="text-align: right">Constant time</td><td style="text-align: right">Profile preferred for scenarios</td></tr><tr><td style="text-align: right"><strong>10k-100k</strong></td><td style="text-align: right">Scales linearly</td><td style="text-align: right">Constant time</td><td style="text-align: right">Profile for exploration, population for final analysis</td></tr><tr><td style="text-align: right"><strong>100k-1M</strong></td><td style="text-align: right">Scales appropriately</td><td style="text-align: right">Constant time</td><td style="text-align: right">Profile strongly preferred</td></tr><tr><td style="text-align: right"><strong>&gt; 1M</strong></td><td style="text-align: right">Scales with dataset size</td><td style="text-align: right">Constant time</td><td style="text-align: right">Profile analysis, selective population</td></tr></table><h3 id="Backend-Selection-by-Use-Case"><a class="docs-heading-anchor" href="#Backend-Selection-by-Use-Case">Backend Selection by Use Case</a><a id="Backend-Selection-by-Use-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-Selection-by-Use-Case" title="Permalink"></a></h3><p>For detailed backend selection guidance including domain-sensitive functions and reliability considerations, see <strong><a href="../backend_selection/">Backend Selection Guide</a></strong>.</p><p><strong>Quick summary:</strong></p><ul><li><strong><code>:ad</code></strong> - Required for log(), sqrt(), 1/x functions; higher reliability</li><li><strong><code>:fd</code></strong> - Zero allocation, optimal for production and large datasets</li></ul><pre><code class="language-julia hljs"># Production configuration (memory-optimized)
population_margins(model, data; backend=:fd, scale=:link)

# Development/high-reliability configuration  
profile_margins(model, data, means_grid(data); backend=:ad, scale=:response)

# Domain-sensitive functions (log, sqrt) - AD required
population_margins(model, data; backend=:ad)  # Required for log(x), sqrt(x)</code></pre><h2 id="Optimization-Principles"><a class="docs-heading-anchor" href="#Optimization-Principles">Optimization Principles</a><a id="Optimization-Principles-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Principles" title="Permalink"></a></h2><h3 id="Core-Performance-Philosophy"><a class="docs-heading-anchor" href="#Core-Performance-Philosophy">Core Performance Philosophy</a><a id="Core-Performance-Philosophy-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Performance-Philosophy" title="Permalink"></a></h3><p><strong>Statistical Correctness First</strong>: Performance optimizations maintain statistical validity</p><ul><li>Delta-method standard errors use full covariance matrix</li><li>All gradient computations maintain mathematical precision</li><li>Bootstrap validation ensures statistical accuracy</li><li>Never change estimators, gradients, or SE math to &quot;optimize&quot;</li></ul><p><strong>Zero-Allocation Patterns</strong>: Eliminate unnecessary memory allocations</p><ul><li>Pre-allocated buffers reused across computations</li><li>FormulaCompiler.jl provides zero-allocation evaluation primitives</li><li>Constant memory footprint regardless of dataset size</li><li>O(1) allocations in production paths: constant allocation count w.r.t. sample size</li></ul><p><strong>Computational Efficiency</strong>: Optimize hot paths without changing methodology</p><ul><li>Compiled formula evaluation with caching</li><li>Efficient gradient accumulation patterns</li><li>Scalar operations over broadcast temporaries</li><li>Zero dynamic growth: avoid <code>push!</code> in hot paths; size outputs up-front</li></ul><h3 id="Backend-Performance-Characteristics"><a class="docs-heading-anchor" href="#Backend-Performance-Characteristics">Backend Performance Characteristics</a><a id="Backend-Performance-Characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-Performance-Characteristics" title="Permalink"></a></h3><h4 id="Automatic-Differentiation-(:ad)-**RECOMMENDED-DEFAULT**"><a class="docs-heading-anchor" href="#Automatic-Differentiation-(:ad)-**RECOMMENDED-DEFAULT**">Automatic Differentiation (<code>:ad</code>) - <strong>RECOMMENDED DEFAULT</strong></a><a id="Automatic-Differentiation-(:ad)-**RECOMMENDED-DEFAULT**-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-(:ad)-**RECOMMENDED-DEFAULT**" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Zero allocation after warmup
population_margins(model, data; backend=:ad)  # 0 bytes allocated</code></pre><p><strong>Advantages</strong>:</p><ul><li>Zero allocation after warmup</li><li>Machine precision accuracy (exact derivatives)</li><li>Robust domain handling (handles log, sqrt, 1/x safely)</li><li>Suitable for complex formulas</li></ul><p><strong>Use cases</strong>: Most applications - provides good performance and reliability</p><h4 id="Finite-Differences-(:fd)"><a class="docs-heading-anchor" href="#Finite-Differences-(:fd)">Finite Differences (<code>:fd</code>)</a><a id="Finite-Differences-(:fd)-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Differences-(:fd)" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Zero allocation after warmup
population_margins(model, data; backend=:fd)  # 0 bytes allocated</code></pre><p><strong>Advantages</strong>:</p><ul><li>Zero allocation in production paths</li><li>Simple numerical implementation</li><li>Good accuracy for well-conditioned functions</li></ul><p><strong>Use cases</strong>: Simple linear formulas where marginal speed differences matter</p><h2 id="Memory-Management"><a class="docs-heading-anchor" href="#Memory-Management">Memory Management</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></h2><h3 id="Allocation-Patterns"><a class="docs-heading-anchor" href="#Allocation-Patterns">Allocation Patterns</a><a id="Allocation-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Patterns" title="Permalink"></a></h3><p>Margins.jl achieves zero-allocation performance for computational workflows:</p><pre><code class="language-julia hljs"># Profile margins: constant allocation regardless of data size
@allocated profile_margins(model, small_data, means_grid(small_data))  # small constant allocation
@allocated profile_margins(model, large_data, means_grid(large_data))  # same allocation pattern

# Population margins: zero allocation after warmup (both backends)
@allocated population_margins(model, data_1k; backend=:fd)   # 0 bytes
@allocated population_margins(model, data_10k; backend=:fd)  # 0 bytes
@allocated population_margins(model, data_1k; backend=:ad)   # 0 bytes
@allocated population_margins(model, data_10k; backend=:ad)  # 0 bytes</code></pre><h3 id="Memory-Efficiency-Best-Practices"><a class="docs-heading-anchor" href="#Memory-Efficiency-Best-Practices">Memory Efficiency Best Practices</a><a id="Memory-Efficiency-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Efficiency-Best-Practices" title="Permalink"></a></h3><h4 id="For-Large-Datasets"><a class="docs-heading-anchor" href="#For-Large-Datasets">For Large Datasets</a><a id="For-Large-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#For-Large-Datasets" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Use profile analysis for exploration (O(1) memory)
scenarios = cartesian_grid(x1=[-1, 0, 1], treatment=[0, 1])
results = profile_margins(model, large_data, scenarios)

# Use population analysis with zero-allocation backends
key_effects = population_margins(model, large_data; vars=[:treatment], backend=:ad)  # Recommended
# OR
key_effects = population_margins(model, large_data; vars=[:treatment], backend=:fd)  # Also zero allocation</code></pre><h4 id="For-Batch-Processing"><a class="docs-heading-anchor" href="#For-Batch-Processing">For Batch Processing</a><a id="For-Batch-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#For-Batch-Processing" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Process multiple models with zero allocation
models = [model1, model2, model3]
results = []

for model in models
    # Each call has zero allocation (either backend)
    result = population_margins(model, data; backend=:ad)  # Recommended: zero allocation
    push!(results, DataFrame(result))
end</code></pre><h2 id="Performance-Best-Practices"><a class="docs-heading-anchor" href="#Performance-Best-Practices">Performance Best Practices</a><a id="Performance-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Best-Practices" title="Permalink"></a></h2><h3 id="High-Performance-Usage-Patterns"><a class="docs-heading-anchor" href="#High-Performance-Usage-Patterns">High-Performance Usage Patterns</a><a id="High-Performance-Usage-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#High-Performance-Usage-Patterns" title="Permalink"></a></h3><p>For optimal performance in production environments, follow these proven patterns:</p><h4 id="Compilation-and-Caching"><a class="docs-heading-anchor" href="#Compilation-and-Caching">Compilation and Caching</a><a id="Compilation-and-Caching-1"></a><a class="docs-heading-anchor-permalink" href="#Compilation-and-Caching" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Good: Compile once, use multiple times
compiled = FormulaCompiler.compile_formula(model, data)  # Expensive, do once
de = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=vars)  # Do once

# Multiple analysis calls reuse compiled objects automatically
result1 = population_margins(model, data; type=:effects)     
result2 = profile_margins(model, data, means_grid(data); type=:effects)

# Avoid: Forcing recompilation in loops
for subset in data_subsets
    # Each call may recompile unnecessarily
    result = population_margins(fit_model(subset), subset)  
end</code></pre><h4 id="Memory-Efficient-Data-Processing"><a class="docs-heading-anchor" href="#Memory-Efficient-Data-Processing">Memory-Efficient Data Processing</a><a id="Memory-Efficient-Data-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Efficient-Data-Processing" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Good: Pre-allocate result structures for known sizes
n_effects = length(vars) * length(scenarios)
result_buffer = DataFrame(
    term = Vector{String}(undef, n_effects),
    estimate = Vector{Float64}(undef, n_effects),
    se = Vector{Float64}(undef, n_effects)
)

# Good: Use scalar operations in hot paths
for i in eachindex(estimates)
    μ = GLM.linkinv(link, η[i])      # Scalar operation
    se[i] = sqrt(gradients[i]&#39; * Σ * gradients[i])
end

# Avoid: Growing DataFrames with push! in loops
results = DataFrame()
for scenario in scenarios
    result = population_margins(model, scenario_data)
    push!(results, DataFrame(result))  # Expensive growth
end</code></pre><h4 id="FormulaCompiler-Integration-Patterns"><a class="docs-heading-anchor" href="#FormulaCompiler-Integration-Patterns">FormulaCompiler Integration Patterns</a><a id="FormulaCompiler-Integration-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#FormulaCompiler-Integration-Patterns" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Good: Let FormulaCompiler handle the optimization
# Use built-in primitives for zero-allocation paths
population_margins(model, data; backend=:fd)  # Uses optimized accumulation

# Good: Cache compiled objects for batch processing
models = [model1, model2, model3]
cached_compilations = Dict()

for model in models
    # Compilation is cached automatically by model signature
    result = population_margins(model, data; backend=:ad)
end</code></pre><h3 id="Performance-Validation"><a class="docs-heading-anchor" href="#Performance-Validation">Performance Validation</a><a id="Performance-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Validation" title="Permalink"></a></h3><h4 id="Checking-Allocation-Patterns"><a class="docs-heading-anchor" href="#Checking-Allocation-Patterns">Checking Allocation Patterns</a><a id="Checking-Allocation-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-Allocation-Patterns" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Verify zero-allocation performance
using BenchmarkTools

# Both backends should show 0 allocation after warmup
@allocated population_margins(model, data; backend=:ad)  # Expected: 0 bytes  
@allocated population_margins(model, data; backend=:fd)  # Expected: 0 bytes

# Profile margins should have constant allocation regardless of data size
@allocated profile_margins(model, small_data, means_grid(small_data))  # Small constant
@allocated profile_margins(model, large_data, means_grid(large_data))  # Same constant</code></pre><h4 id="Performance-Monitoring"><a class="docs-heading-anchor" href="#Performance-Monitoring">Performance Monitoring</a><a id="Performance-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Monitoring" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Production monitoring pattern
function monitored_margins(model, data; max_alloc_kb=10, kwargs...)
    alloc_before = Base.gc_num().poolalloc
    
    result = population_margins(model, data; kwargs...)
    
    alloc_after = Base.gc_num().poolalloc
    alloc_kb = (alloc_after - alloc_before) / 1024
    
    if alloc_kb &gt; max_alloc_kb
        @warn &quot;Excessive allocation detected: $(alloc_kb)KB&quot;
    end
    
    return result
end</code></pre><h2 id="Troubleshooting-Performance-Issues"><a class="docs-heading-anchor" href="#Troubleshooting-Performance-Issues">Troubleshooting Performance Issues</a><a id="Troubleshooting-Performance-Issues-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-Performance-Issues" title="Permalink"></a></h2><h3 id="Diagnostic-Tools"><a class="docs-heading-anchor" href="#Diagnostic-Tools">Diagnostic Tools</a><a id="Diagnostic-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostic-Tools" title="Permalink"></a></h3><h4 id="Memory-Allocation-Checking"><a class="docs-heading-anchor" href="#Memory-Allocation-Checking">Memory Allocation Checking</a><a id="Memory-Allocation-Checking-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Allocation-Checking" title="Permalink"></a></h4><pre><code class="language-julia hljs">using BenchmarkTools

# Check allocation patterns
@allocated population_margins(model, data)  # Should be constant across dataset sizes

# Benchmark performance
@btime population_margins($model, $data)     # Timing analysis</code></pre><h4 id="Performance-Profiling"><a class="docs-heading-anchor" href="#Performance-Profiling">Performance Profiling</a><a id="Performance-Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Profiling" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Profile hot paths (advanced)
using Profile

@profile for i in 1:100
    population_margins(model, data; backend=:fd)
end
Profile.print()</code></pre><h3 id="Common-Issues-and-Solutions"><a class="docs-heading-anchor" href="#Common-Issues-and-Solutions">Common Issues and Solutions</a><a id="Common-Issues-and-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Issues-and-Solutions" title="Permalink"></a></h3><h4 id="Issue:-Profile-margins-slower-than-expected"><a class="docs-heading-anchor" href="#Issue:-Profile-margins-slower-than-expected">Issue: Profile margins slower than expected</a><a id="Issue:-Profile-margins-slower-than-expected-1"></a><a class="docs-heading-anchor-permalink" href="#Issue:-Profile-margins-slower-than-expected" title="Permalink"></a></h4><p><strong>Diagnosis</strong>: Reference grid specification or DataFrame dispatch issues <strong>Solution</strong>: Use proper reference grid builders</p><pre><code class="language-julia hljs"># Correct: O(1) performance with reference grids
profile_margins(model, data, means_grid(data); type=:effects)
profile_margins(model, data, cartesian_grid(x=[0,1,2]); type=:effects)

# Avoid: Improper reference grid specification
# Always use reference grid builders or explicit DataFrames</code></pre><h4 id="Issue:-Population-margins-allocating-excessively"><a class="docs-heading-anchor" href="#Issue:-Population-margins-allocating-excessively">Issue: Population margins allocating excessively</a><a id="Issue:-Population-margins-allocating-excessively-1"></a><a class="docs-heading-anchor-permalink" href="#Issue:-Population-margins-allocating-excessively" title="Permalink"></a></h4><p><strong>Diagnosis</strong>: Hot loop allocation patterns or data format issues <strong>Solution</strong>: Check backend and use efficient data formats</p><pre><code class="language-julia hljs"># Efficient: Both backends should be zero allocation
result = population_margins(model, data; backend=:ad)  # Recommended
result = population_margins(model, data; backend=:fd)  # Also zero allocation

# Efficient data format
data_nt = Tables.columntable(data)  # Convert once for multiple analyses
result = population_margins(model, data_nt; backend=:ad)</code></pre><h4 id="Issue:-Inconsistent-performance-across-runs"><a class="docs-heading-anchor" href="#Issue:-Inconsistent-performance-across-runs">Issue: Inconsistent performance across runs</a><a id="Issue:-Inconsistent-performance-across-runs-1"></a><a class="docs-heading-anchor-permalink" href="#Issue:-Inconsistent-performance-across-runs" title="Permalink"></a></h4><p><strong>Diagnosis</strong>: Compilation effects, memory pressure, or GC interference <strong>Solution</strong>: Proper warmup and consistent configuration</p><pre><code class="language-julia hljs"># Proper benchmarking protocol
# 1. Warmup run
population_margins(model, small_sample)  

# 2. Clear compilation effects  
GC.gc()

# 3. Consistent benchmark
@btime population_margins($model, $data; backend=:ad)  </code></pre><h4 id="Issue:-Memory-allocation-growing-with-dataset-size"><a class="docs-heading-anchor" href="#Issue:-Memory-allocation-growing-with-dataset-size">Issue: Memory allocation growing with dataset size</a><a id="Issue:-Memory-allocation-growing-with-dataset-size-1"></a><a class="docs-heading-anchor-permalink" href="#Issue:-Memory-allocation-growing-with-dataset-size" title="Permalink"></a></h4><p><strong>Diagnosis</strong>: O(n) allocation pattern indicating performance regression <strong>Solution</strong>: Verify zero-allocation backends and check for loops</p><pre><code class="language-julia hljs"># Expected: constant allocation across dataset sizes
@allocated population_margins(model, data_1k; backend=:ad)    # Should be 0 bytes
@allocated population_margins(model, data_10k; backend=:ad)   # Should be 0 bytes  
@allocated population_margins(model, data_100k; backend=:ad)  # Should be 0 bytes

# If allocations grow with n:
# 1. Check backend selection (:ad and :fd both should be zero allocation)  
# 2. Verify data format (Tables.jl-compatible)
# 3. Check for custom vcov functions that may allocate</code></pre><h4 id="Issue:-Slow-compilation-on-first-run"><a class="docs-heading-anchor" href="#Issue:-Slow-compilation-on-first-run">Issue: Slow compilation on first run</a><a id="Issue:-Slow-compilation-on-first-run-1"></a><a class="docs-heading-anchor-permalink" href="#Issue:-Slow-compilation-on-first-run" title="Permalink"></a></h4><p><strong>Diagnosis</strong>: Normal FormulaCompiler compilation overhead <strong>Solution</strong>: Accept first-run cost, subsequent runs benefit from caching</p><pre><code class="language-julia hljs"># Expected pattern:
@time population_margins(model, data)        # Slower (compilation)
@time population_margins(model, data)        # Faster (cached)

# For production: accept compilation cost or precompile key models</code></pre><h2 id="FormulaCompiler.jl-Integration"><a class="docs-heading-anchor" href="#FormulaCompiler.jl-Integration">FormulaCompiler.jl Integration</a><a id="FormulaCompiler.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#FormulaCompiler.jl-Integration" title="Permalink"></a></h2><h3 id="Zero-Allocation-Foundations"><a class="docs-heading-anchor" href="#Zero-Allocation-Foundations">Zero-Allocation Foundations</a><a id="Zero-Allocation-Foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-Allocation-Foundations" title="Permalink"></a></h3><p>Margins.jl achieves performance through tight integration with FormulaCompiler.jl:</p><h4 id="Compiled-Formula-Evaluation"><a class="docs-heading-anchor" href="#Compiled-Formula-Evaluation">Compiled Formula Evaluation</a><a id="Compiled-Formula-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Compiled-Formula-Evaluation" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Single compilation, multiple evaluations
compiled = FormulaCompiler.compile_formula(model, data)  # Once
# Reused across all margin computations - zero allocation per evaluation</code></pre><h4 id="Derivative-Computation"><a class="docs-heading-anchor" href="#Derivative-Computation">Derivative Computation</a><a id="Derivative-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Computation" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Pre-built derivative evaluators
de = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=vars)  # Once  
# Reused for all marginal effects - zero allocation per derivative</code></pre><h4 id="Buffer-Management"><a class="docs-heading-anchor" href="#Buffer-Management">Buffer Management</a><a id="Buffer-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Buffer-Management" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Pre-allocated buffers prevent runtime allocation
η_buf = Vector{Float64}(undef, n_profiles)      # Linear predictor buffer
g_buf = Vector{Float64}(undef, n_vars)          # Gradient buffer  
gβ_accumulator = Vector{Float64}(undef, n_coef) # Parameter gradient buffer</code></pre><h3 id="Advanced-Performance-Patterns"><a class="docs-heading-anchor" href="#Advanced-Performance-Patterns">Advanced Performance Patterns</a><a id="Advanced-Performance-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Performance-Patterns" title="Permalink"></a></h3><h4 id="Caching-Strategies"><a class="docs-heading-anchor" href="#Caching-Strategies">Caching Strategies</a><a id="Caching-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Caching-Strategies" title="Permalink"></a></h4><pre><code class="language-julia hljs"># FormulaCompiler artifacts are cached automatically
# Multiple margin calls on same model/data reuse compilation
result1 = population_margins(model, data; type=:effects)      # Compiles
result2 = profile_margins(model, data, means_grid(data); type=:effects)  # Reuses compilation</code></pre><h4 id="Batch-Processing-Optimization"><a class="docs-heading-anchor" href="#Batch-Processing-Optimization">Batch Processing Optimization</a><a id="Batch-Processing-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Processing-Optimization" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Process multiple scenarios efficiently
scenarios = cartesian_grid(x1=[0,1,2], group=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])  # 9 profiles

# Single compilation, multiple scenario evaluations
results = profile_margins(model, data, scenarios; type=:effects)  # Efficient</code></pre><h2 id="Production-Deployment-Guidelines"><a class="docs-heading-anchor" href="#Production-Deployment-Guidelines">Production Deployment Guidelines</a><a id="Production-Deployment-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Production-Deployment-Guidelines" title="Permalink"></a></h2><h3 id="Recommended-Configuration"><a class="docs-heading-anchor" href="#Recommended-Configuration">Recommended Configuration</a><a id="Recommended-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs"># High-performance production settings
result = population_margins(
    model, data;
    backend = :fd,           # Zero allocation (explicitly requested)
    scale = :link,           # Link scale
    type = :effects          # Core functionality
)</code></pre><h3 id="Monitoring-and-Validation"><a class="docs-heading-anchor" href="#Monitoring-and-Validation">Monitoring and Validation</a><a id="Monitoring-and-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Monitoring-and-Validation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Performance monitoring in production
function production_margins(model, data; kwargs...)
    # Allocation monitoring
    alloc_before = Base.gc_num().poolalloc
    
    result = population_margins(model, data; backend=:fd, kwargs...)
    
    alloc_after = Base.gc_num().poolalloc
    alloc_diff = alloc_after - alloc_before
    
    # Log excessive allocations
    if alloc_diff &gt; 10000  # 10KB threshold
        @warn &quot;Excessive allocation detected&quot; alloc_diff
    end
    
    return result
end</code></pre><h3 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Robust production wrapper
# Note: No implicit backend fallbacks. Select `backend` explicitly.</code></pre><hr/><p><em>This performance guide ensures you can leverage Margins.jl&#39;s full computational potential while maintaining statistical rigor in production environments. For conceptual background on why Population vs Profile matters for performance, see <a href="../mathematical_foundation/">Mathematical Foundation</a>. For comprehensive API usage, see <a href="../api/">API Reference</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../backend_selection/">« Backend Selection</a><a class="docs-footer-nextpage" href="../advanced/">Advanced Features »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 13 September 2025 03:12">Saturday 13 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
