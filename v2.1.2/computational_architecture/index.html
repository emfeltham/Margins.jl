<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computational Architecture · Margins.jl</title><meta name="title" content="Computational Architecture · Margins.jl"/><meta property="og:title" content="Computational Architecture · Margins.jl"/><meta property="twitter:title" content="Computational Architecture · Margins.jl"/><meta name="description" content="Documentation for Margins.jl."/><meta property="og:description" content="Documentation for Margins.jl."/><meta property="twitter:description" content="Documentation for Margins.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Margins.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Margins.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../mathematical_foundation/">Mathematical Foundation</a></li><li class="is-active"><a class="tocitem" href>Computational Architecture</a><ul class="internal"><li><a class="tocitem" href="#FormulaCompiler.jl:-The-Foundation"><span>FormulaCompiler.jl: The Foundation</span></a></li><li><a class="tocitem" href="#Computational-Kernels"><span>Computational Kernels</span></a></li><li><a class="tocitem" href="#Data-Type-Architecture"><span>Data Type Architecture</span></a></li><li><a class="tocitem" href="#Statistical-Computation-Architecture"><span>Statistical Computation Architecture</span></a></li><li><a class="tocitem" href="#Performance-Implications-of-Architecture"><span>Performance Implications of Architecture</span></a></li><li><a class="tocitem" href="#Integration-with-JuliaStats-Ecosystem"><span>Integration with JuliaStats Ecosystem</span></a></li><li><a class="tocitem" href="#Extensibility-Architecture"><span>Extensibility Architecture</span></a></li><li><a class="tocitem" href="#Architectural-Principles"><span>Architectural Principles</span></a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../reference_grids/">Reference Grids</a></li><li><a class="tocitem" href="../profile_margins/">Profile Analysis</a></li><li><a class="tocitem" href="../population_scenarios/">Population Scenarios</a></li><li><a class="tocitem" href="../second_differences/">Second Differences</a></li><li><a class="tocitem" href="../weights/">Weights</a></li><li><a class="tocitem" href="../grouping/">Population Grouping</a></li><li><a class="tocitem" href="../backend_selection/">Backend Selection</a></li><li><a class="tocitem" href="../performance/">Performance Guide</a></li><li><a class="tocitem" href="../advanced/">Advanced Features</a></li></ul></li><li><a class="tocitem" href="../stata_migration/">Migration Guide</a></li><li><a class="tocitem" href="../comparison/">Package Comparison</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Computational Architecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computational Architecture</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/emfeltham/Margins.jl/" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Computational-Architecture"><a class="docs-heading-anchor" href="#Computational-Architecture">Computational Architecture</a><a id="Computational-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Architecture" title="Permalink"></a></h1><p><em>The foundational computational engine powering Margins.jl</em></p><h2 id="FormulaCompiler.jl:-The-Foundation"><a class="docs-heading-anchor" href="#FormulaCompiler.jl:-The-Foundation">FormulaCompiler.jl: The Foundation</a><a id="FormulaCompiler.jl:-The-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#FormulaCompiler.jl:-The-Foundation" title="Permalink"></a></h2><p>Margins.jl is built on <a href="https://github.com/emfeltham/FormulaCompiler.jl">FormulaCompiler.jl</a>, a high-performance formula evaluation and differentiation engine specifically designed for econometric analysis. This architectural foundation helps explain how Margins.jl achieves both statistical correctness and exceptional performance.</p><h3 id="Why-FormulaCompiler.jl-Matters"><a class="docs-heading-anchor" href="#Why-FormulaCompiler.jl-Matters">Why FormulaCompiler.jl Matters</a><a id="Why-FormulaCompiler.jl-Matters-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FormulaCompiler.jl-Matters" title="Permalink"></a></h3><p>FormulaCompiler.jl provides the <strong>zero-allocation computational core</strong> that enables Margins.jl to:</p><ol><li><strong>Process large econometric datasets efficiently</strong>: O(1) profile margins regardless of dataset size</li><li><strong>Maintain statistical rigor</strong>: Exact derivatives for delta-method standard errors  </li><li><strong>Support complex formulas</strong>: Nested functions like <code>log(1 + income)</code> with proper differentiation</li><li><strong>Handle mixed data types</strong>: Automatic Float64 conversion for derivatives without runtime cost</li><li><strong>Ensure numerical stability</strong>: Machine-precision accuracy for gradient computations</li></ol><p><strong>Without FormulaCompiler.jl</strong>, marginal effects computation would require either:</p><ul><li>Slow symbolic differentiation (intractable for large datasets)</li><li>Unreliable numerical approximations (compromising statistical validity)</li><li>Massive memory allocations (preventing large-scale analysis)</li></ul><h3 id="The-Compilation-Strategy"><a class="docs-heading-anchor" href="#The-Compilation-Strategy">The Compilation Strategy</a><a id="The-Compilation-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#The-Compilation-Strategy" title="Permalink"></a></h3><p>FormulaCompiler.jl transforms regression formulas into highly optimized computational kernels:</p><h4 id="Formula-Compilation"><a class="docs-heading-anchor" href="#Formula-Compilation">Formula Compilation</a><a id="Formula-Compilation-1"></a><a class="docs-heading-anchor-permalink" href="#Formula-Compilation" title="Permalink"></a></h4><pre><code class="language-julia hljs"># From StatsModels.jl formula...
@formula(y ~ log(income) + age + education)

# ...to zero-allocation evaluator
compiled = FormulaCompiler.compile_formula(model, data)
# Single compilation, reused across all margin computations</code></pre><h4 id="Derivative-System"><a class="docs-heading-anchor" href="#Derivative-System">Derivative System</a><a id="Derivative-System-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-System" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Automatic derivative evaluators for marginal effects
de = FormulaCompiler.build_derivative_evaluator(compiled, data; vars=[:income, :age])
# Zero allocation per derivative computation</code></pre><h4 id="Type-Safe-Overrides"><a class="docs-heading-anchor" href="#Type-Safe-Overrides">Type-Safe Overrides</a><a id="Type-Safe-Overrides-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Safe-Overrides" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Efficient scenario analysis with fractional specifications
overrides = Dict(:income =&gt; 50000, :treatment =&gt; 0.5)  # 50% treatment probability
result = FormulaCompiler.evaluate_scenario(compiled, overrides)
# Supports categorical mixtures and continuous overrides seamlessly</code></pre><h2 id="Computational-Kernels"><a class="docs-heading-anchor" href="#Computational-Kernels">Computational Kernels</a><a id="Computational-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Kernels" title="Permalink"></a></h2><h3 id="Zero-Allocation-Formula-Evaluation"><a class="docs-heading-anchor" href="#Zero-Allocation-Formula-Evaluation">Zero-Allocation Formula Evaluation</a><a id="Zero-Allocation-Formula-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-Allocation-Formula-Evaluation" title="Permalink"></a></h3><p>The core of all marginal effects computation is formula evaluation. FormulaCompiler.jl achieves <strong>~7 nanoseconds per evaluation</strong> with zero allocations:</p><pre><code class="language-julia hljs"># Population margins: evaluate formula n times (once per observation)
for i in 1:n_observations
    η[i] = compiled_evaluator(data_row[i])  # 7ns, 0 bytes
end

# Profile margins: evaluate formula k times (once per scenario)  
for j in 1:n_scenarios
    η[j] = compiled_evaluator(scenario[j])   # 7ns, 0 bytes, independent of n_observations
end</code></pre><p><strong>Key insight</strong>: Profile margins achieve <strong>O(1) scaling</strong> because they evaluate formulas only at specified scenarios, not across the entire dataset.</p><h3 id="Derivative-Computation"><a class="docs-heading-anchor" href="#Derivative-Computation">Derivative Computation</a><a id="Derivative-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative-Computation" title="Permalink"></a></h3><p>Marginal effects require computing ∂η/∂x for each variable. FormulaCompiler.jl provides two backends:</p><h4 id="Automatic-Differentiation-(:ad)-**RECOMMENDED**"><a class="docs-heading-anchor" href="#Automatic-Differentiation-(:ad)-**RECOMMENDED**">Automatic Differentiation (<code>:ad</code>) - <strong>RECOMMENDED</strong></a><a id="Automatic-Differentiation-(:ad)-**RECOMMENDED**-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-(:ad)-**RECOMMENDED**" title="Permalink"></a></h4><ul><li><strong>Accuracy</strong>: Machine precision (exact derivatives)</li><li><strong>Allocation</strong>: Zero bytes after warmup</li><li><strong>Domain safety</strong>: Handles log(), sqrt(), 1/x functions correctly</li><li><strong>Use case</strong>: Default choice for reliability and accuracy</li></ul><h4 id="Finite-Differences-(:fd)"><a class="docs-heading-anchor" href="#Finite-Differences-(:fd)">Finite Differences (<code>:fd</code>)</a><a id="Finite-Differences-(:fd)-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Differences-(:fd)" title="Permalink"></a></h4><ul><li><strong>Accuracy</strong>: Numerical approximation (typically sufficient)</li><li><strong>Allocation</strong>: Zero bytes in all cases</li><li><strong>Performance</strong>: Slightly faster for simple formulas</li><li><strong>Use case</strong>: Production optimization when domain is well-behaved</li></ul><h3 id="Buffer-Management-System"><a class="docs-heading-anchor" href="#Buffer-Management-System">Buffer Management System</a><a id="Buffer-Management-System-1"></a><a class="docs-heading-anchor-permalink" href="#Buffer-Management-System" title="Permalink"></a></h3><p>Margins.jl pre-allocates computational buffers to achieve zero-allocation performance:</p><pre><code class="language-julia hljs"># Pre-allocated in MarginsEngine struct
struct MarginsEngine
    η_buf::Vector{Float64}          # Linear predictor evaluations
    g_buf::Vector{Float64}          # Gradient computations  
    gβ_accumulator::Vector{Float64} # Parameter gradient accumulation
    # ... other buffers
end</code></pre><p>These buffers are <strong>reused across all computations</strong>, eliminating runtime allocations while maintaining thread safety.</p><h2 id="Data-Type-Architecture"><a class="docs-heading-anchor" href="#Data-Type-Architecture">Data Type Architecture</a><a id="Data-Type-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Type-Architecture" title="Permalink"></a></h2><h3 id="Mixed-Type-Handling"><a class="docs-heading-anchor" href="#Mixed-Type-Handling">Mixed Type Handling</a><a id="Mixed-Type-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-Type-Handling" title="Permalink"></a></h3><p>FormulaCompiler.jl automatically handles the mixed data types common in econometric analysis:</p><h4 id="Integer-Variables"><a class="docs-heading-anchor" href="#Integer-Variables">Integer Variables</a><a id="Integer-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-Variables" title="Permalink"></a></h4><ul><li><strong>Runtime behavior</strong>: Automatic Float64 conversion during derivative computation</li><li><strong>Performance impact</strong>: Zero (conversion happens during compilation, not evaluation)</li><li><strong>Mathematical correctness</strong>: Preserves exact derivative computation</li><li><strong>Example</strong>: <code>age::Int64</code> treated as continuous for marginal effects</li></ul><h4 id="Categorical-Variables"><a class="docs-heading-anchor" href="#Categorical-Variables">Categorical Variables</a><a id="Categorical-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Variables" title="Permalink"></a></h4><ul><li><strong>Bool variables</strong>: Treated as categorical with fractional override support</li><li><strong>CategoricalArray</strong>: Supports both baseline and pairwise contrasts</li><li><strong>Frequency weighting</strong>: Unspecified categoricals use sample composition</li><li><strong>Example</strong>: <code>treatment::Bool</code> supports <code>0.7</code> for 70% treatment probability</li></ul><h4 id="Continuous-Variables"><a class="docs-heading-anchor" href="#Continuous-Variables">Continuous Variables</a><a id="Continuous-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-Variables" title="Permalink"></a></h4><ul><li><strong>Float64</strong>: Native support with full arithmetic operations</li><li><strong>Complex expressions</strong>: <code>log(1 + income)</code>, <code>sqrt(age)</code> handled correctly</li><li><strong>Chain rule</strong>: Automatic differentiation through nested functions</li></ul><h3 id="Type-Safe-Scenario-System"><a class="docs-heading-anchor" href="#Type-Safe-Scenario-System">Type-Safe Scenario System</a><a id="Type-Safe-Scenario-System-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Safe-Scenario-System" title="Permalink"></a></h3><p>FormulaCompiler.jl enables sophisticated scenario analysis while maintaining type safety:</p><pre><code class="language-julia hljs"># Representative scenarios with mixed types
scenarios = (
    :income =&gt; [30000, 50000, 80000],        # Continuous override
    :education =&gt; [&quot;High School&quot;, &quot;College&quot;], # Categorical override  
    :treatment =&gt; [0.2, 0.8]                 # Fractional Bool override
)

# Automatic Cartesian product: 3×2×2 = 12 scenarios
# Each scenario maintains type consistency and statistical validity</code></pre><h2 id="Statistical-Computation-Architecture"><a class="docs-heading-anchor" href="#Statistical-Computation-Architecture">Statistical Computation Architecture</a><a id="Statistical-Computation-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-Computation-Architecture" title="Permalink"></a></h2><h3 id="Delta-Method-Standard-Errors"><a class="docs-heading-anchor" href="#Delta-Method-Standard-Errors">Delta-Method Standard Errors</a><a id="Delta-Method-Standard-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Delta-Method-Standard-Errors" title="Permalink"></a></h3><p>The statistical rigor of Margins.jl depends on proper delta-method computation:</p><pre><code class="language-julia hljs"># Delta-method formula: Var(g(β)) = g&#39;(β) Σ g&#39;(β)ᵀ
# Where g&#39;(β) = ∂(marginal_effect)/∂β and Σ = vcov(model)

# FormulaCompiler.jl computes g&#39;(β) with zero allocation:
gradient = FormulaCompiler.compute_parameter_gradient(compiled, β, data_point)
variance = gradient&#39; * vcov_matrix * gradient
standard_error = sqrt(variance)</code></pre><p><strong>Critical</strong>: This computation requires <strong>exact derivatives</strong> to ensure statistical validity. Approximate gradients would compromise the mathematical foundation of inference.</p><h3 id="Covariance-Matrix-Integration"><a class="docs-heading-anchor" href="#Covariance-Matrix-Integration">Covariance Matrix Integration</a><a id="Covariance-Matrix-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Matrix-Integration" title="Permalink"></a></h3><p>FormulaCompiler.jl integrates seamlessly with Julia&#39;s covariance matrix ecosystem:</p><ul><li><strong>GLM.jl</strong>: Uses <code>vcov(model)</code> automatically</li><li><strong>CovarianceMatrices.jl</strong>: Supports robust/clustered standard errors</li><li><strong>MixedModels.jl</strong>: Compatible with mixed model covariance structures</li><li><strong>Custom matrices</strong>: Accepts user-provided covariance matrices</li></ul><h2 id="Performance-Implications-of-Architecture"><a class="docs-heading-anchor" href="#Performance-Implications-of-Architecture">Performance Implications of Architecture</a><a id="Performance-Implications-of-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Implications-of-Architecture" title="Permalink"></a></h2><h3 id="Why-Profile-Margins-Are-O(1)"><a class="docs-heading-anchor" href="#Why-Profile-Margins-Are-O(1)">Why Profile Margins Are O(1)</a><a id="Why-Profile-Margins-Are-O(1)-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Profile-Margins-Are-O(1)" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Profile margins evaluate k scenarios (typically 1-50)
n_scenarios = length(expand_scenarios(at_specification))
computational_cost = n_scenarios * 7ns  # Independent of dataset size

# Population margins evaluate n observations  
computational_cost = n_observations * 7ns  # Scales with data</code></pre><p><strong>Architectural insight</strong>: Profile margins achieve constant-time performance because FormulaCompiler.jl <strong>decouples</strong> formula evaluation from data size.</p><h3 id="Memory-Architecture"><a class="docs-heading-anchor" href="#Memory-Architecture">Memory Architecture</a><a id="Memory-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Architecture" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Constant memory footprint regardless of dataset size:
memory_usage = sizeof(η_buf) + sizeof(g_buf) + sizeof(gβ_accumulator) + compilation_cache
# Total: ~few KB, independent of whether you have 1k or 1M observations</code></pre><h3 id="Compilation-Caching"><a class="docs-heading-anchor" href="#Compilation-Caching">Compilation Caching</a><a id="Compilation-Caching-1"></a><a class="docs-heading-anchor-permalink" href="#Compilation-Caching" title="Permalink"></a></h3><p>FormulaCompiler.jl automatically caches compiled evaluators:</p><pre><code class="language-julia hljs"># First call: compilation cost
result1 = population_margins(model, data)  # ~milliseconds (compile + compute)

# Subsequent calls: pure computation  
result2 = profile_margins(model, data, means_grid(data))  # ~microseconds (reuse compilation)</code></pre><h2 id="Integration-with-JuliaStats-Ecosystem"><a class="docs-heading-anchor" href="#Integration-with-JuliaStats-Ecosystem">Integration with JuliaStats Ecosystem</a><a id="Integration-with-JuliaStats-Ecosystem-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-JuliaStats-Ecosystem" title="Permalink"></a></h2><h3 id="StatsModels.jl-Integration"><a class="docs-heading-anchor" href="#StatsModels.jl-Integration">StatsModels.jl Integration</a><a id="StatsModels.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#StatsModels.jl-Integration" title="Permalink"></a></h3><p>FormulaCompiler.jl directly processes StatsModels.jl formulas:</p><pre><code class="language-julia hljs"># From StatsModels formula specification...
formula = @formula(log_wage ~ education + experience + education&amp;experience)

# ...to compiled computational kernel with proper derivatives
compiled = FormulaCompiler.compile_formula(formula, model, data)
# Handles interaction terms, transformations, and categorical expansions</code></pre><h3 id="GLM.jl-Integration"><a class="docs-heading-anchor" href="#GLM.jl-Integration">GLM.jl Integration</a><a id="GLM.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#GLM.jl-Integration" title="Permalink"></a></h3><p>Link functions are handled transparently:</p><pre><code class="language-julia hljs"># For GLMs, chain rule automatically applied:
# ∂μ/∂x = (∂μ/∂η) × (∂η/∂x)
# Where μ = linkinv(η) and ∂μ/∂η computed by FormulaCompiler.jl

# Both link scale (:link) and response scale (:response) supported
margin_link = compute_margin(compiled, :link)      # Direct derivative
margin_response = compute_margin(compiled, :response)  # Chain rule applied</code></pre><h3 id="MixedModels.jl-Integration"><a class="docs-heading-anchor" href="#MixedModels.jl-Integration">MixedModels.jl Integration</a><a id="MixedModels.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#MixedModels.jl-Integration" title="Permalink"></a></h3><p>Mixed models require special covariance matrix handling:</p><pre><code class="language-julia hljs"># FormulaCompiler.jl extracts fixed effects for differentiation:
β_fixed = fixef(mixed_model)
V_fixed = vcov(mixed_model)  # Fixed effects covariance only

# Marginal effects computed relative to fixed effects:
# Random effects treated as integrated out (conditional on data)</code></pre><h2 id="Extensibility-Architecture"><a class="docs-heading-anchor" href="#Extensibility-Architecture">Extensibility Architecture</a><a id="Extensibility-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Extensibility-Architecture" title="Permalink"></a></h2><h3 id="Custom-Function-Support"><a class="docs-heading-anchor" href="#Custom-Function-Support">Custom Function Support</a><a id="Custom-Function-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Function-Support" title="Permalink"></a></h3><p>FormulaCompiler.jl supports user-defined functions with automatic differentiation:</p><pre><code class="language-julia hljs"># Custom transformations with exact derivatives
my_transform(x) = log(1 + exp(x))  # Softplus function

# Automatic differentiation handles custom functions:
@formula(y ~ my_transform(income) + age)  # Works seamlessly</code></pre><h3 id="Backend-Extensibility"><a class="docs-heading-anchor" href="#Backend-Extensibility">Backend Extensibility</a><a id="Backend-Extensibility-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-Extensibility" title="Permalink"></a></h3><p>The architecture supports additional computational backends:</p><pre><code class="language-julia hljs"># Current backends
population_margins(model, data; backend=:ad)  # Automatic differentiation
population_margins(model, data; backend=:fd)  # Finite differences

# Future extensibility:  
# population_margins(model, data; backend=:symbolic)  # Symbolic differentiation
# population_margins(model, data; backend=:gpu)      # GPU acceleration</code></pre><h2 id="Architectural-Principles"><a class="docs-heading-anchor" href="#Architectural-Principles">Architectural Principles</a><a id="Architectural-Principles-1"></a><a class="docs-heading-anchor-permalink" href="#Architectural-Principles" title="Permalink"></a></h2><h3 id="1.-Separation-of-Concerns"><a class="docs-heading-anchor" href="#1.-Separation-of-Concerns">1. Separation of Concerns</a><a id="1.-Separation-of-Concerns-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Separation-of-Concerns" title="Permalink"></a></h3><ul><li><strong>FormulaCompiler.jl</strong>: Low-level computational primitives</li><li><strong>Margins.jl</strong>: High-level statistical interface and methodology</li><li><strong>Result</strong>: Clean abstraction boundaries and maintainable code</li></ul><h3 id="2.-Performance-Without-Compromise"><a class="docs-heading-anchor" href="#2.-Performance-Without-Compromise">2. Performance Without Compromise</a><a id="2.-Performance-Without-Compromise-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Performance-Without-Compromise" title="Permalink"></a></h3><ul><li><strong>Statistical integrity</strong>: Performance optimizations maintain statistical validity</li><li><strong>Exact computation</strong>: Delta-method standard errors use exact derivatives</li><li><strong>Memory efficiency</strong>: Zero-allocation core with pre-allocated buffers</li></ul><h3 id="3.-Type-Safety-and-Correctness"><a class="docs-heading-anchor" href="#3.-Type-Safety-and-Correctness">3. Type Safety and Correctness</a><a id="3.-Type-Safety-and-Correctness-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Type-Safety-and-Correctness" title="Permalink"></a></h3><ul><li><strong>Compile-time checks</strong>: Type errors caught during formula compilation</li><li><strong>Runtime safety</strong>: Automatic type conversions preserve mathematical properties  </li><li><strong>Statistical validity</strong>: Architecture enforces proper delta-method computation</li></ul><h3 id="4.-JuliaStats-Ecosystem-Compatibility"><a class="docs-heading-anchor" href="#4.-JuliaStats-Ecosystem-Compatibility">4. JuliaStats Ecosystem Compatibility</a><a id="4.-JuliaStats-Ecosystem-Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#4.-JuliaStats-Ecosystem-Compatibility" title="Permalink"></a></h3><ul><li><strong>Protocol adherence</strong>: Follows established conventions (vcov, predict, etc.)</li><li><strong>Seamless integration</strong>: Works with existing model types and data formats</li><li><strong>Future compatibility</strong>: Architecture supports ecosystem evolution</li></ul><hr/><p><em>This computational architecture enables Margins.jl to deliver both statistical rigor and exceptional performance for econometric analysis. For performance-specific guidance, see <a href="../performance/">Performance Guide</a>. For the mathematical foundation, see <a href="../mathematical_foundation/">Mathematical Foundation</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mathematical_foundation/">« Mathematical Foundation</a><a class="docs-footer-nextpage" href="../reference_grids/">Reference Grids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 20:27">Wednesday 25 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
